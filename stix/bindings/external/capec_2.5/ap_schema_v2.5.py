#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Thu Apr 11 15:08:01 2013 by generateDS.py version 2.9a.
#

import sys
import getopt
import re as re_

import cybox_core
import base64
from datetime import datetime, tzinfo, timedelta

etree_ = None
Verbose_import_ = False
(   XMLParser_import_none, XMLParser_import_lxml,
    XMLParser_import_elementtree
    ) = range(3)
XMLParser_import_library = None
try:
    # lxml
    from lxml import etree as etree_
    XMLParser_import_library = XMLParser_import_lxml
    if Verbose_import_:
        print("running with lxml.etree")
except ImportError:
    try:
        # cElementTree from Python 2.5+
        import xml.etree.cElementTree as etree_
        XMLParser_import_library = XMLParser_import_elementtree
        if Verbose_import_:
            print("running with cElementTree on Python 2.5+")
    except ImportError:
        try:
            # ElementTree from Python 2.5+
            import xml.etree.ElementTree as etree_
            XMLParser_import_library = XMLParser_import_elementtree
            if Verbose_import_:
                print("running with ElementTree on Python 2.5+")
        except ImportError:
            try:
                # normal cElementTree install
                import cElementTree as etree_
                XMLParser_import_library = XMLParser_import_elementtree
                if Verbose_import_:
                    print("running with cElementTree")
            except ImportError:
                try:
                    # normal ElementTree install
                    import elementtree.ElementTree as etree_
                    XMLParser_import_library = XMLParser_import_elementtree
                    if Verbose_import_:
                        print("running with ElementTree")
                except ImportError:
                    raise ImportError(
                        "Failed to import ElementTree from any known place")

def parsexml_(*args, **kwargs):
    if (XMLParser_import_library == XMLParser_import_lxml and
        'parser' not in kwargs):
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        kwargs['parser'] = etree_.ETCompatXMLParser()
    doc = etree_.parse(*args, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError, exp:

    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(tzinfo):
            def __init__(self, offset, name):
                self.__offset = timedelta(minutes = offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node, input_name=''):
            return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_integer_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of integers')
            return input_data
        def gds_format_float(self, input_data, input_name=''):
            return '%f' % input_data
        def gds_validate_float(self, input_data, node, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_float_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of floats')
            return input_data
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_double_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of doubles')
            return input_data
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return input_data
        def gds_validate_datetime(self, input_data, node, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = input_data.strftime('%Y-%m-%dT%H:%M:%S')
            else:
                _svalue = input_data.strftime('%Y-%m-%dT%H:%M:%S.%f')
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_parse_datetime(self, input_data, node, input_name=''):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'GMT')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime.strptime(
                        input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime.strptime(
                        input_data, '%Y-%m-%dT%H:%M:%S')
            return dt.replace(tzinfo = tz)

        def gds_validate_date(self, input_data, node, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = input_data.strftime('%Y-%m-%d')
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_parse_date(self, input_data, node, input_name=''):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'GMT')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            return datetime.strptime(input_data,
                '%Y-%m-%d').replace(tzinfo = tz)
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')

#
# Support/utility functions.
#

def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')

def quote_xml(inStr):
    if not inStr:
        return ''
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1

def quote_attrib(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1

def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1

def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text

def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass

def raise_parse_error(node, msg):
    if XMLParser_import_library == XMLParser_import_lxml:
        msg = '%s (element %s/line %d)' % (
            msg, node.tag, node.sourceline, )
    else:
        msg = '%s (element %s)' % (msg, node.tag, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace, pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace, name, pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' %
                (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' %
                (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' %
                (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' %
                (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' %
                (self.name, base64.b64encode(self.value), self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n'
                % (self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n'
                % (self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s",\n' % \
                (self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container

def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#

class RelationshipType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Relationship_Views=None, Relationship_Chains=None, Relationship_Target_Form=None, Relationship_Nature=None, Relationship_Target_ID=None, Relationship_Description=None):
        self.Relationship_Views = Relationship_Views
        self.Relationship_Chains = Relationship_Chains
        self.Relationship_Target_Form = Relationship_Target_Form
        if Relationship_Nature is None:
            self.Relationship_Nature = []
        else:
            self.Relationship_Nature = Relationship_Nature
        self.Relationship_Target_ID = Relationship_Target_ID
        self.Relationship_Description = Relationship_Description
    def factory(*args_, **kwargs_):
        if RelationshipType.subclass:
            return RelationshipType.subclass(*args_, **kwargs_)
        else:
            return RelationshipType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Relationship_Views(self): return self.Relationship_Views
    def set_Relationship_Views(self, Relationship_Views): self.Relationship_Views = Relationship_Views
    def get_Relationship_Chains(self): return self.Relationship_Chains
    def set_Relationship_Chains(self, Relationship_Chains): self.Relationship_Chains = Relationship_Chains
    def get_Relationship_Target_Form(self): return self.Relationship_Target_Form
    def set_Relationship_Target_Form(self, Relationship_Target_Form): self.Relationship_Target_Form = Relationship_Target_Form
    def get_Relationship_Nature(self): return self.Relationship_Nature
    def set_Relationship_Nature(self, Relationship_Nature): self.Relationship_Nature = Relationship_Nature
    def add_Relationship_Nature(self, value): self.Relationship_Nature.append(value)
    def insert_Relationship_Nature(self, index, value): self.Relationship_Nature[index] = value
    def get_Relationship_Target_ID(self): return self.Relationship_Target_ID
    def set_Relationship_Target_ID(self, Relationship_Target_ID): self.Relationship_Target_ID = Relationship_Target_ID
    def get_Relationship_Description(self): return self.Relationship_Description
    def set_Relationship_Description(self, Relationship_Description): self.Relationship_Description = Relationship_Description
    def hasContent_(self):
        if (
            self.Relationship_Views is not None or
            self.Relationship_Chains is not None or
            self.Relationship_Target_Form is not None or
            self.Relationship_Nature or
            self.Relationship_Target_ID is not None or
            self.Relationship_Description is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='capec:', name_='RelationshipType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RelationshipType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='RelationshipType'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='RelationshipType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Relationship_Views is not None:
            self.Relationship_Views.export(outfile, level, 'capec:', name_='Relationship_Views', pretty_print=pretty_print)
        if self.Relationship_Chains is not None:
            self.Relationship_Chains.export(outfile, level, 'capec:', name_='Relationship_Chains', pretty_print=pretty_print)
        if self.Relationship_Target_Form is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRelationship_Target_Form>%s</%sRelationship_Target_Form>%s' % ('capec:', self.gds_format_string(quote_xml(self.Relationship_Target_Form).encode(ExternalEncoding), input_name='Relationship_Target_Form'), 'capec:', eol_))
        for Relationship_Nature_ in self.Relationship_Nature:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRelationship_Nature>%s</%sRelationship_Nature>%s' % ('capec:', self.gds_format_string(quote_xml(Relationship_Nature_).encode(ExternalEncoding), input_name='Relationship_Nature'), 'capec:', eol_))
        if self.Relationship_Target_ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRelationship_Target_ID>%s</%sRelationship_Target_ID>%s' % ('capec:', self.gds_format_integer(self.Relationship_Target_ID, input_name='Relationship_Target_ID'), 'capec:', eol_))
        if self.Relationship_Description is not None:
            self.Relationship_Description.export(outfile, level, 'capec:', name_='Relationship_Description', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='RelationshipType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Relationship_Views is not None:
            showIndent(outfile, level)
            outfile.write('Relationship_Views=model_.Relationship_ViewsType(\n')
            self.Relationship_Views.exportLiteral(outfile, level, name_='Relationship_Views')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Relationship_Chains is not None:
            showIndent(outfile, level)
            outfile.write('Relationship_Chains=model_.Relationship_ChainsType(\n')
            self.Relationship_Chains.exportLiteral(outfile, level, name_='Relationship_Chains')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Relationship_Target_Form is not None:
            showIndent(outfile, level)
            outfile.write('Relationship_Target_Form=%s,\n' % quote_python(self.Relationship_Target_Form).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('Relationship_Nature=[\n')
        level += 1
        for Relationship_Nature_ in self.Relationship_Nature:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Relationship_Nature_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Relationship_Target_ID is not None:
            showIndent(outfile, level)
            outfile.write('Relationship_Target_ID=%d,\n' % self.Relationship_Target_ID)
        if self.Relationship_Description is not None:
            outfile.write('Relationship_Description=model_.Structured_Text_Type(\n')
            self.Relationship_Description.exportLiteral(outfile, level, name_='Relationship_Description')
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Relationship_Views':
            obj_ = Relationship_ViewsType.factory()
            obj_.build(child_)
            self.set_Relationship_Views(obj_)
        elif nodeName_ == 'Relationship_Chains':
            obj_ = Relationship_ChainsType.factory()
            obj_.build(child_)
            self.set_Relationship_Chains(obj_)
        elif nodeName_ == 'Relationship_Target_Form':
            Relationship_Target_Form_ = child_.text
            Relationship_Target_Form_ = self.gds_validate_string(Relationship_Target_Form_, node, 'Relationship_Target_Form')
            self.Relationship_Target_Form = Relationship_Target_Form_
        elif nodeName_ == 'Relationship_Nature':
            Relationship_Nature_ = child_.text
            Relationship_Nature_ = self.gds_validate_string(Relationship_Nature_, node, 'Relationship_Nature')
            self.Relationship_Nature.append(Relationship_Nature_)
        elif nodeName_ == 'Relationship_Target_ID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Relationship_Target_ID')
            self.Relationship_Target_ID = ival_
        elif nodeName_ == 'Relationship_Description':
            obj_ = Structured_Text_Type.factory()
            obj_.build(child_)
            self.set_Relationship_Description(obj_)
# end class RelationshipType

class cybox_core.ObservablesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Observable=None):
        if Observable is None:
            self.Observable = []
        else:
            self.Observable = Observable
    def factory(*args_, **kwargs_):
        if cybox_core.ObservablesType.subclass:
            return cybox_core.ObservablesType.subclass(*args_, **kwargs_)
        else:
            return cybox_core.ObservablesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Observable(self): return self.Observable
    def set_Observable(self, Observable): self.Observable = Observable
    def add_Observable(self, value): self.Observable.append(value)
    def insert_Observable(self, index, value): self.Observable[index] = value
    def hasContent_(self):
        if (
            self.Observable
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='capec:', name_='cybox_core.ObservablesType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cybox_core.ObservablesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='cybox_core.ObservablesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='cybox_core.ObservablesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Observable_ in self.Observable:
            Observable_.export(outfile, level, 'capec:', name_='Observable', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='cybox_core.ObservablesType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Observable=[\n')
        level += 1
        for Observable_ in self.Observable:
            showIndent(outfile, level)
            outfile.write('model_.ObservableType48(\n')
            Observable_.exportLiteral(outfile, level, name_='ObservableType48')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Observable':
            obj_ = ObservableType48.factory()
            obj_.build(child_)
            self.Observable.append(obj_)
# end class cybox_core.ObservablesType

class Structured_Text_Type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Text_Title=None, Text=None, Code_Example_Language=None, Code=None, Comment=None, Images=None, Block=None):
        if Text_Title is None:
            self.Text_Title = []
        else:
            self.Text_Title = Text_Title
        if Text is None:
            self.Text = []
        else:
            self.Text = Text
        if Code_Example_Language is None:
            self.Code_Example_Language = []
        else:
            self.Code_Example_Language = Code_Example_Language
        if Code is None:
            self.Code = []
        else:
            self.Code = Code
        if Comment is None:
            self.Comment = []
        else:
            self.Comment = Comment
        self.Images = Images
        self.Block = Block
    def factory(*args_, **kwargs_):
        if Structured_Text_Type.subclass:
            return Structured_Text_Type.subclass(*args_, **kwargs_)
        else:
            return Structured_Text_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Text_Title(self): return self.Text_Title
    def set_Text_Title(self, Text_Title): self.Text_Title = Text_Title
    def add_Text_Title(self, value): self.Text_Title.append(value)
    def insert_Text_Title(self, index, value): self.Text_Title[index] = value
    def get_Text(self): return self.Text
    def set_Text(self, Text): self.Text = Text
    def add_Text(self, value): self.Text.append(value)
    def insert_Text(self, index, value): self.Text[index] = value
    def get_Code_Example_Language(self): return self.Code_Example_Language
    def set_Code_Example_Language(self, Code_Example_Language): self.Code_Example_Language = Code_Example_Language
    def add_Code_Example_Language(self, value): self.Code_Example_Language.append(value)
    def insert_Code_Example_Language(self, index, value): self.Code_Example_Language[index] = value
    def validate_Language_Type(self, value):
        # Validate type Language_Type, a restriction on xs:string.
        pass
    def get_Code(self): return self.Code
    def set_Code(self, Code): self.Code = Code
    def add_Code(self, value): self.Code.append(value)
    def insert_Code(self, index, value): self.Code[index] = value
    def get_Comment(self): return self.Comment
    def set_Comment(self, Comment): self.Comment = Comment
    def add_Comment(self, value): self.Comment.append(value)
    def insert_Comment(self, index, value): self.Comment[index] = value
    def get_Images(self): return self.Images
    def set_Images(self, Images): self.Images = Images
    def get_Block(self): return self.Block
    def set_Block(self, Block): self.Block = Block
    def hasContent_(self):
        if (
            self.Text_Title or
            self.Text or
            self.Code_Example_Language or
            self.Code or
            self.Comment or
            self.Images is not None or
            self.Block is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='capec:', name_='Structured_Text_Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Structured_Text_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Structured_Text_Type'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Structured_Text_Type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Text_Title_ in self.Text_Title:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sText_Title>%s</%sText_Title>%s' % ('capec:', self.gds_format_string(quote_xml(Text_Title_).encode(ExternalEncoding), input_name='Text_Title'), 'capec:', eol_))
        for Text_ in self.Text:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sText>%s</%sText>%s' % ('capec:', self.gds_format_string(quote_xml(Text_).encode(ExternalEncoding), input_name='Text'), 'capec:', eol_))
        for Code_Example_Language_ in self.Code_Example_Language:
            outfile.write('<%sCode_Example_Language>%s</%sCode_Example_Language>%s' % ('capec:', self.gds_format_string(quote_xml(Code_Example_Language_).encode(ExternalEncoding), input_name='Code_Example_Language'), 'capec:', eol_))
        for Code_ in self.Code:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCode>%s</%sCode>%s' % ('capec:', self.gds_format_string(quote_xml(Code_).encode(ExternalEncoding), input_name='Code'), 'capec:', eol_))
        for Comment_ in self.Comment:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sComment>%s</%sComment>%s' % ('capec:', self.gds_format_string(quote_xml(Comment_).encode(ExternalEncoding), input_name='Comment'), 'capec:', eol_))
        if self.Images is not None:
            self.Images.export(outfile, level, 'capec:', name_='Images', pretty_print=pretty_print)
        if self.Block is not None:
            self.Block.export(outfile, level, 'capec:', name_='Block', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='Structured_Text_Type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Text_Title=[\n')
        level += 1
        for Text_Title_ in self.Text_Title:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Text_Title_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Text=[\n')
        level += 1
        for Text_ in self.Text:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Text_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Code_Example_Language=[\n')
        level += 1
        for Code_Example_Language_ in self.Code_Example_Language:
            outfile.write('%s,\n' % quote_python(Code_Example_Language_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Code=[\n')
        level += 1
        for Code_ in self.Code:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Code_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Comment=[\n')
        level += 1
        for Comment_ in self.Comment:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Comment_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Images is not None:
            showIndent(outfile, level)
            outfile.write('Images=model_.ImagesType(\n')
            self.Images.exportLiteral(outfile, level, name_='Images')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Block is not None:
            showIndent(outfile, level)
            outfile.write('Block=model_.Block(\n')
            self.Block.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Text_Title':
            Text_Title_ = child_.text
            Text_Title_ = self.gds_validate_string(Text_Title_, node, 'Text_Title')
            self.Text_Title.append(Text_Title_)
        elif nodeName_ == 'Text':
            Text_ = child_.text
            Text_ = self.gds_validate_string(Text_, node, 'Text')
            self.Text.append(Text_)
        elif nodeName_ == 'Code_Example_Language':
            obj_ = Language_Type.factory()
            obj_.build(child_)
            self.Code_Example_Language.append(obj_)
        elif nodeName_ == 'Code':
            Code_ = child_.text
            Code_ = self.gds_validate_string(Code_, node, 'Code')
            self.Code.append(Code_)
        elif nodeName_ == 'Comment':
            Comment_ = child_.text
            Comment_ = self.gds_validate_string(Comment_, node, 'Comment')
            self.Comment.append(Comment_)
        elif nodeName_ == 'Images':
            obj_ = ImagesType.factory()
            obj_.build(child_)
            self.set_Images(obj_)
        elif nodeName_ == 'Block':
            obj_ = Block.factory()
            obj_.build(child_)
            self.set_Block(obj_)
# end class Structured_Text_Type

class Reference_List_Type(GeneratedsSuper):
    """The References_List_Type contains one or more Reference elements,
    each of which provide further reading and insight into the item.
    This should be filled out as appropriate."""
    subclass = None
    superclass = None
    def __init__(self, Reference=None):
        if Reference is None:
            self.Reference = []
        else:
            self.Reference = Reference
    def factory(*args_, **kwargs_):
        if Reference_List_Type.subclass:
            return Reference_List_Type.subclass(*args_, **kwargs_)
        else:
            return Reference_List_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Reference(self): return self.Reference
    def set_Reference(self, Reference): self.Reference = Reference
    def add_Reference(self, value): self.Reference.append(value)
    def insert_Reference(self, index, value): self.Reference[index] = value
    def hasContent_(self):
        if (
            self.Reference
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='capec:', name_='Reference_List_Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Reference_List_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Reference_List_Type'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Reference_List_Type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Reference_ in self.Reference:
            Reference_.export(outfile, level, 'capec:', name_='Reference', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='Reference_List_Type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Reference=[\n')
        level += 1
        for Reference_ in self.Reference:
            outfile.write('model_.Reference_Type(\n')
            Reference_.exportLiteral(outfile, level, name_='Reference_Type')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Reference':
            obj_ = Reference_Type.factory()
            obj_.build(child_)
            self.Reference.append(obj_)
# end class Reference_List_Type

class Reference_Type(GeneratedsSuper):
    """The id attribute is optional and is used as a mechanism forciting
    text in the entry. If an id is provided, it is placed between
    brackets and precedes this reference and the matching id should
    be used inside of the text for the attack pattern itself where
    this reference is applicable. All reference ids assigned within
    an entry must be unique."""
    subclass = None
    superclass = None
    def __init__(self, Reference_ID=None, Reference_Description=None, Reference_Author=None, Reference_Title=None, Reference_Section=None, Reference_Edition=None, Reference_Publication=None, Reference_Publisher=None, Reference_Date=None, Reference_PubDate=None, Reference_Link=None):
        self.Reference_ID = _cast(None, Reference_ID)
        self.Reference_Description = Reference_Description
        if Reference_Author is None:
            self.Reference_Author = []
        else:
            self.Reference_Author = Reference_Author
        self.Reference_Title = Reference_Title
        self.Reference_Section = Reference_Section
        self.Reference_Edition = Reference_Edition
        self.Reference_Publication = Reference_Publication
        self.Reference_Publisher = Reference_Publisher
        self.Reference_Date = Reference_Date
        self.Reference_PubDate = Reference_PubDate
        self.Reference_Link = Reference_Link
    def factory(*args_, **kwargs_):
        if Reference_Type.subclass:
            return Reference_Type.subclass(*args_, **kwargs_)
        else:
            return Reference_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Reference_Description(self): return self.Reference_Description
    def set_Reference_Description(self, Reference_Description): self.Reference_Description = Reference_Description
    def get_Reference_Author(self): return self.Reference_Author
    def set_Reference_Author(self, Reference_Author): self.Reference_Author = Reference_Author
    def add_Reference_Author(self, value): self.Reference_Author.append(value)
    def insert_Reference_Author(self, index, value): self.Reference_Author[index] = value
    def get_Reference_Title(self): return self.Reference_Title
    def set_Reference_Title(self, Reference_Title): self.Reference_Title = Reference_Title
    def get_Reference_Section(self): return self.Reference_Section
    def set_Reference_Section(self, Reference_Section): self.Reference_Section = Reference_Section
    def get_Reference_Edition(self): return self.Reference_Edition
    def set_Reference_Edition(self, Reference_Edition): self.Reference_Edition = Reference_Edition
    def get_Reference_Publication(self): return self.Reference_Publication
    def set_Reference_Publication(self, Reference_Publication): self.Reference_Publication = Reference_Publication
    def get_Reference_Publisher(self): return self.Reference_Publisher
    def set_Reference_Publisher(self, Reference_Publisher): self.Reference_Publisher = Reference_Publisher
    def get_Reference_Date(self): return self.Reference_Date
    def set_Reference_Date(self, Reference_Date): self.Reference_Date = Reference_Date
    def get_Reference_PubDate(self): return self.Reference_PubDate
    def set_Reference_PubDate(self, Reference_PubDate): self.Reference_PubDate = Reference_PubDate
    def get_Reference_Link(self): return self.Reference_Link
    def set_Reference_Link(self, Reference_Link): self.Reference_Link = Reference_Link
    def get_Reference_ID(self): return self.Reference_ID
    def set_Reference_ID(self, Reference_ID): self.Reference_ID = Reference_ID
    def hasContent_(self):
        if (
            self.Reference_Description is not None or
            self.Reference_Author or
            self.Reference_Title is not None or
            self.Reference_Section is not None or
            self.Reference_Edition is not None or
            self.Reference_Publication is not None or
            self.Reference_Publisher is not None or
            self.Reference_Date is not None or
            self.Reference_PubDate is not None or
            self.Reference_Link is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='capec:', name_='Reference_Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Reference_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Reference_Type'):
        if self.Reference_ID is not None and 'Reference_ID' not in already_processed:
            already_processed.add('Reference_ID')
            outfile.write(' Reference_ID=%s' % (self.gds_format_string(quote_attrib(self.Reference_ID).encode(ExternalEncoding), input_name='Reference_ID'), ))
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Reference_Type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Reference_Description is not None:
            self.Reference_Description.export(outfile, level, 'capec:', name_='Reference_Description', pretty_print=pretty_print)
        for Reference_Author_ in self.Reference_Author:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sReference_Author>%s</%sReference_Author>%s' % ('capec:', self.gds_format_string(quote_xml(Reference_Author_).encode(ExternalEncoding), input_name='Reference_Author'), 'capec:', eol_))
        if self.Reference_Title is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sReference_Title>%s</%sReference_Title>%s' % ('capec:', self.gds_format_string(quote_xml(self.Reference_Title).encode(ExternalEncoding), input_name='Reference_Title'), 'capec:', eol_))
        if self.Reference_Section is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sReference_Section>%s</%sReference_Section>%s' % ('capec:', self.gds_format_string(quote_xml(self.Reference_Section).encode(ExternalEncoding), input_name='Reference_Section'), 'capec:', eol_))
        if self.Reference_Edition is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sReference_Edition>%s</%sReference_Edition>%s' % ('capec:', self.gds_format_string(quote_xml(self.Reference_Edition).encode(ExternalEncoding), input_name='Reference_Edition'), 'capec:', eol_))
        if self.Reference_Publication is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sReference_Publication>%s</%sReference_Publication>%s' % ('capec:', self.gds_format_string(quote_xml(self.Reference_Publication).encode(ExternalEncoding), input_name='Reference_Publication'), 'capec:', eol_))
        if self.Reference_Publisher is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sReference_Publisher>%s</%sReference_Publisher>%s' % ('capec:', self.gds_format_string(quote_xml(self.Reference_Publisher).encode(ExternalEncoding), input_name='Reference_Publisher'), 'capec:', eol_))
        if self.Reference_Date is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sReference_Date>%s</%sReference_Date>%s' % ('capec:', self.gds_format_date(self.Reference_Date, input_name='Reference_Date'), 'capec:', eol_))
        if self.Reference_PubDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sReference_PubDate>%s</%sReference_PubDate>%s' % ('capec:', self.gds_format_string(quote_xml(self.Reference_PubDate).encode(ExternalEncoding), input_name='Reference_PubDate'), 'capec:', eol_))
        if self.Reference_Link is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sReference_Link>%s</%sReference_Link>%s' % ('capec:', self.gds_format_string(quote_xml(self.Reference_Link).encode(ExternalEncoding), input_name='Reference_Link'), 'capec:', eol_))
    def exportLiteral(self, outfile, level, name_='Reference_Type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Reference_ID is not None and 'Reference_ID' not in already_processed:
            already_processed.add('Reference_ID')
            showIndent(outfile, level)
            outfile.write('Reference_ID = "%s",\n' % (self.Reference_ID,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Reference_Description is not None:
            outfile.write('Reference_Description=model_.Structured_Text_Type(\n')
            self.Reference_Description.exportLiteral(outfile, level, name_='Reference_Description')
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Reference_Author=[\n')
        level += 1
        for Reference_Author_ in self.Reference_Author:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Reference_Author_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Reference_Title is not None:
            showIndent(outfile, level)
            outfile.write('Reference_Title=%s,\n' % quote_python(self.Reference_Title).encode(ExternalEncoding))
        if self.Reference_Section is not None:
            showIndent(outfile, level)
            outfile.write('Reference_Section=%s,\n' % quote_python(self.Reference_Section).encode(ExternalEncoding))
        if self.Reference_Edition is not None:
            showIndent(outfile, level)
            outfile.write('Reference_Edition=%s,\n' % quote_python(self.Reference_Edition).encode(ExternalEncoding))
        if self.Reference_Publication is not None:
            showIndent(outfile, level)
            outfile.write('Reference_Publication=%s,\n' % quote_python(self.Reference_Publication).encode(ExternalEncoding))
        if self.Reference_Publisher is not None:
            showIndent(outfile, level)
            outfile.write('Reference_Publisher=%s,\n' % quote_python(self.Reference_Publisher).encode(ExternalEncoding))
        if self.Reference_Date is not None:
            showIndent(outfile, level)
            outfile.write('Reference_Date=datetime_.strptime("%s", "%%Y-%%m-%%d"),\n' % self.gds_format_date(self.Reference_Date, input_name='Reference_Date'))
        if self.Reference_PubDate is not None:
            showIndent(outfile, level)
            outfile.write('Reference_PubDate=%s,\n' % quote_python(self.Reference_PubDate).encode(ExternalEncoding))
        if self.Reference_Link is not None:
            showIndent(outfile, level)
            outfile.write('Reference_Link=%s,\n' % quote_python(self.Reference_Link).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Reference_ID', node)
        if value is not None and 'Reference_ID' not in already_processed:
            already_processed.add('Reference_ID')
            self.Reference_ID = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Reference_Description':
            obj_ = Structured_Text_Type.factory()
            obj_.build(child_)
            self.set_Reference_Description(obj_)
        elif nodeName_ == 'Reference_Author':
            Reference_Author_ = child_.text
            Reference_Author_ = self.gds_validate_string(Reference_Author_, node, 'Reference_Author')
            self.Reference_Author.append(Reference_Author_)
        elif nodeName_ == 'Reference_Title':
            Reference_Title_ = child_.text
            Reference_Title_ = self.gds_validate_string(Reference_Title_, node, 'Reference_Title')
            self.Reference_Title = Reference_Title_
        elif nodeName_ == 'Reference_Section':
            Reference_Section_ = child_.text
            Reference_Section_ = self.gds_validate_string(Reference_Section_, node, 'Reference_Section')
            self.Reference_Section = Reference_Section_
        elif nodeName_ == 'Reference_Edition':
            Reference_Edition_ = child_.text
            Reference_Edition_ = self.gds_validate_string(Reference_Edition_, node, 'Reference_Edition')
            self.Reference_Edition = Reference_Edition_
        elif nodeName_ == 'Reference_Publication':
            Reference_Publication_ = child_.text
            Reference_Publication_ = self.gds_validate_string(Reference_Publication_, node, 'Reference_Publication')
            self.Reference_Publication = Reference_Publication_
        elif nodeName_ == 'Reference_Publisher':
            Reference_Publisher_ = child_.text
            Reference_Publisher_ = self.gds_validate_string(Reference_Publisher_, node, 'Reference_Publisher')
            self.Reference_Publisher = Reference_Publisher_
        elif nodeName_ == 'Reference_Date':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_, node, 'Reference_Date')
            self.Reference_Date = dval_
        elif nodeName_ == 'Reference_PubDate':
            Reference_PubDate_ = child_.text
            Reference_PubDate_ = self.gds_validate_string(Reference_PubDate_, node, 'Reference_PubDate')
            self.Reference_PubDate = Reference_PubDate_
        elif nodeName_ == 'Reference_Link':
            Reference_Link_ = child_.text
            Reference_Link_ = self.gds_validate_string(Reference_Link_, node, 'Reference_Link')
            self.Reference_Link = Reference_Link_
# end class Reference_Type

class Custom_Attack_StepType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Attack_Step_Title=None, Attack_Step_Description=None, Attack_Step_Techniques=None, Indicators=None, Outcomes=None, Security_Controls=None, Observables=None, extensiontype_=None):
        self.Attack_Step_Title = Attack_Step_Title
        self.Attack_Step_Description = Attack_Step_Description
        self.Attack_Step_Techniques = Attack_Step_Techniques
        self.Indicators = Indicators
        self.Outcomes = Outcomes
        self.Security_Controls = Security_Controls
        self.Observables = Observables
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if Custom_Attack_StepType.subclass:
            return Custom_Attack_StepType.subclass(*args_, **kwargs_)
        else:
            return Custom_Attack_StepType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Attack_Step_Title(self): return self.Attack_Step_Title
    def set_Attack_Step_Title(self, Attack_Step_Title): self.Attack_Step_Title = Attack_Step_Title
    def get_Attack_Step_Description(self): return self.Attack_Step_Description
    def set_Attack_Step_Description(self, Attack_Step_Description): self.Attack_Step_Description = Attack_Step_Description
    def get_Attack_Step_Techniques(self): return self.Attack_Step_Techniques
    def set_Attack_Step_Techniques(self, Attack_Step_Techniques): self.Attack_Step_Techniques = Attack_Step_Techniques
    def get_Indicators(self): return self.Indicators
    def set_Indicators(self, Indicators): self.Indicators = Indicators
    def get_Outcomes(self): return self.Outcomes
    def set_Outcomes(self, Outcomes): self.Outcomes = Outcomes
    def get_Security_Controls(self): return self.Security_Controls
    def set_Security_Controls(self, Security_Controls): self.Security_Controls = Security_Controls
    def get_Observables(self): return self.Observables
    def set_Observables(self, Observables): self.Observables = Observables
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.Attack_Step_Title is not None or
            self.Attack_Step_Description is not None or
            self.Attack_Step_Techniques is not None or
            self.Indicators is not None or
            self.Outcomes is not None or
            self.Security_Controls is not None or
            self.Observables is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='capec:', name_='Custom_Attack_StepType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Custom_Attack_StepType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Custom_Attack_StepType'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Custom_Attack_StepType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Attack_Step_Title is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAttack_Step_Title>%s</%sAttack_Step_Title>%s' % ('capec:', self.gds_format_string(quote_xml(self.Attack_Step_Title).encode(ExternalEncoding), input_name='Attack_Step_Title'), 'capec:', eol_))
        if self.Attack_Step_Description is not None:
            self.Attack_Step_Description.export(outfile, level, 'capec:', name_='Attack_Step_Description', pretty_print=pretty_print)
        if self.Attack_Step_Techniques is not None:
            self.Attack_Step_Techniques.export(outfile, level, 'capec:', name_='Attack_Step_Techniques', pretty_print=pretty_print)
        if self.Indicators is not None:
            self.Indicators.export(outfile, level, 'capec:', name_='Indicators', pretty_print=pretty_print)
        if self.Outcomes is not None:
            self.Outcomes.export(outfile, level, 'capec:', name_='Outcomes', pretty_print=pretty_print)
        if self.Security_Controls is not None:
            self.Security_Controls.export(outfile, level, 'capec:', name_='Security_Controls', pretty_print=pretty_print)
        if self.Observables is not None:
            self.Observables.export(outfile, level, 'capec:', name_='Observables', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='Custom_Attack_StepType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Attack_Step_Title is not None:
            showIndent(outfile, level)
            outfile.write('Attack_Step_Title=%s,\n' % quote_python(self.Attack_Step_Title).encode(ExternalEncoding))
        if self.Attack_Step_Description is not None:
            outfile.write('Attack_Step_Description=model_.Structured_Text_Type(\n')
            self.Attack_Step_Description.exportLiteral(outfile, level, name_='Attack_Step_Description')
            outfile.write('),\n')
        if self.Attack_Step_Techniques is not None:
            showIndent(outfile, level)
            outfile.write('Attack_Step_Techniques=model_.Attack_Step_TechniquesType(\n')
            self.Attack_Step_Techniques.exportLiteral(outfile, level, name_='Attack_Step_Techniques')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Indicators is not None:
            showIndent(outfile, level)
            outfile.write('Indicators=model_.IndicatorsType(\n')
            self.Indicators.exportLiteral(outfile, level, name_='Indicators')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Outcomes is not None:
            showIndent(outfile, level)
            outfile.write('Outcomes=model_.OutcomesType(\n')
            self.Outcomes.exportLiteral(outfile, level, name_='Outcomes')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Security_Controls is not None:
            showIndent(outfile, level)
            outfile.write('Security_Controls=model_.Security_ControlsType(\n')
            self.Security_Controls.exportLiteral(outfile, level, name_='Security_Controls')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Observables is not None:
            outfile.write('Observables=model_.cybox_core.ObservablesType(\n')
            self.Observables.exportLiteral(outfile, level, name_='Observables')
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Attack_Step_Title':
            Attack_Step_Title_ = child_.text
            Attack_Step_Title_ = self.gds_validate_string(Attack_Step_Title_, node, 'Attack_Step_Title')
            self.Attack_Step_Title = Attack_Step_Title_
        elif nodeName_ == 'Attack_Step_Description':
            obj_ = Structured_Text_Type.factory()
            obj_.build(child_)
            self.set_Attack_Step_Description(obj_)
        elif nodeName_ == 'Attack_Step_Techniques':
            obj_ = Attack_Step_TechniquesType.factory()
            obj_.build(child_)
            self.set_Attack_Step_Techniques(obj_)
        elif nodeName_ == 'Indicators':
            obj_ = IndicatorsType.factory()
            obj_.build(child_)
            self.set_Indicators(obj_)
        elif nodeName_ == 'Outcomes':
            obj_ = OutcomesType.factory()
            obj_.build(child_)
            self.set_Outcomes(obj_)
        elif nodeName_ == 'Security_Controls':
            obj_ = Security_ControlsType.factory()
            obj_.build(child_)
            self.set_Security_Controls(obj_)
        elif nodeName_ == 'Observables':
            obj_ = cybox_core.ObservablesType.factory()
            obj_.build(child_)
            self.set_Observables(obj_)
# end class Custom_Attack_StepType

class Target_Attack_SurfaceType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Common_Attack_Surface_Description=None, Target_Attack_Surface_Description=None):
        self.Common_Attack_Surface_Description = Common_Attack_Surface_Description
        self.Target_Attack_Surface_Description = Target_Attack_Surface_Description
    def factory(*args_, **kwargs_):
        if Target_Attack_SurfaceType.subclass:
            return Target_Attack_SurfaceType.subclass(*args_, **kwargs_)
        else:
            return Target_Attack_SurfaceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Common_Attack_Surface_Description(self): return self.Common_Attack_Surface_Description
    def set_Common_Attack_Surface_Description(self, Common_Attack_Surface_Description): self.Common_Attack_Surface_Description = Common_Attack_Surface_Description
    def get_Target_Attack_Surface_Description(self): return self.Target_Attack_Surface_Description
    def set_Target_Attack_Surface_Description(self, Target_Attack_Surface_Description): self.Target_Attack_Surface_Description = Target_Attack_Surface_Description
    def hasContent_(self):
        if (
            self.Common_Attack_Surface_Description is not None or
            self.Target_Attack_Surface_Description is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='capec:', name_='Target_Attack_SurfaceType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Target_Attack_SurfaceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Target_Attack_SurfaceType'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Target_Attack_SurfaceType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Common_Attack_Surface_Description is not None:
            self.Common_Attack_Surface_Description.export(outfile, level, 'capec:', name_='Common_Attack_Surface_Description', pretty_print=pretty_print)
        if self.Target_Attack_Surface_Description is not None:
            self.Target_Attack_Surface_Description.export(outfile, level, 'capec:', name_='Target_Attack_Surface_Description', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='Target_Attack_SurfaceType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Common_Attack_Surface_Description is not None:
            showIndent(outfile, level)
            outfile.write('Common_Attack_Surface_Description=model_.Common_Attack_Surface_DescriptionType(\n')
            self.Common_Attack_Surface_Description.exportLiteral(outfile, level, name_='Common_Attack_Surface_Description')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Target_Attack_Surface_Description is not None:
            outfile.write('Target_Attack_Surface_Description=model_.Target_Attack_Surface_DescriptionType(\n')
            self.Target_Attack_Surface_Description.exportLiteral(outfile, level, name_='Target_Attack_Surface_Description')
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Common_Attack_Surface_Description':
            obj_ = Common_Attack_Surface_DescriptionType.factory()
            obj_.build(child_)
            self.set_Common_Attack_Surface_Description(obj_)
        elif nodeName_ == 'Target_Attack_Surface_Description':
            obj_ = Target_Attack_Surface_DescriptionType.factory()
            obj_.build(child_)
            self.set_Target_Attack_Surface_Description(obj_)
# end class Target_Attack_SurfaceType

class Target_Attack_Surface_DescriptionType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Targeted_OSI_Layers=None, Target_Attack_Surface_Localities=None, Target_Attack_Surface_Types=None, Target_Functional_Services=None, extensiontype_=None):
        self.Targeted_OSI_Layers = Targeted_OSI_Layers
        self.Target_Attack_Surface_Localities = Target_Attack_Surface_Localities
        self.Target_Attack_Surface_Types = Target_Attack_Surface_Types
        self.Target_Functional_Services = Target_Functional_Services
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if Target_Attack_Surface_DescriptionType.subclass:
            return Target_Attack_Surface_DescriptionType.subclass(*args_, **kwargs_)
        else:
            return Target_Attack_Surface_DescriptionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Targeted_OSI_Layers(self): return self.Targeted_OSI_Layers
    def set_Targeted_OSI_Layers(self, Targeted_OSI_Layers): self.Targeted_OSI_Layers = Targeted_OSI_Layers
    def get_Target_Attack_Surface_Localities(self): return self.Target_Attack_Surface_Localities
    def set_Target_Attack_Surface_Localities(self, Target_Attack_Surface_Localities): self.Target_Attack_Surface_Localities = Target_Attack_Surface_Localities
    def get_Target_Attack_Surface_Types(self): return self.Target_Attack_Surface_Types
    def set_Target_Attack_Surface_Types(self, Target_Attack_Surface_Types): self.Target_Attack_Surface_Types = Target_Attack_Surface_Types
    def get_Target_Functional_Services(self): return self.Target_Functional_Services
    def set_Target_Functional_Services(self, Target_Functional_Services): self.Target_Functional_Services = Target_Functional_Services
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.Targeted_OSI_Layers is not None or
            self.Target_Attack_Surface_Localities is not None or
            self.Target_Attack_Surface_Types is not None or
            self.Target_Functional_Services is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='capec:', name_='Target_Attack_Surface_DescriptionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Target_Attack_Surface_DescriptionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Target_Attack_Surface_DescriptionType'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Target_Attack_Surface_DescriptionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Targeted_OSI_Layers is not None:
            self.Targeted_OSI_Layers.export(outfile, level, 'capec:', name_='Targeted_OSI_Layers', pretty_print=pretty_print)
        if self.Target_Attack_Surface_Localities is not None:
            self.Target_Attack_Surface_Localities.export(outfile, level, 'capec:', name_='Target_Attack_Surface_Localities', pretty_print=pretty_print)
        if self.Target_Attack_Surface_Types is not None:
            self.Target_Attack_Surface_Types.export(outfile, level, 'capec:', name_='Target_Attack_Surface_Types', pretty_print=pretty_print)
        if self.Target_Functional_Services is not None:
            self.Target_Functional_Services.export(outfile, level, 'capec:', name_='Target_Functional_Services', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='Target_Attack_Surface_DescriptionType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Targeted_OSI_Layers is not None:
            showIndent(outfile, level)
            outfile.write('Targeted_OSI_Layers=model_.Targeted_OSI_LayersType(\n')
            self.Targeted_OSI_Layers.exportLiteral(outfile, level, name_='Targeted_OSI_Layers')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Target_Attack_Surface_Localities is not None:
            showIndent(outfile, level)
            outfile.write('Target_Attack_Surface_Localities=model_.Target_Attack_Surface_LocalitiesType(\n')
            self.Target_Attack_Surface_Localities.exportLiteral(outfile, level, name_='Target_Attack_Surface_Localities')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Target_Attack_Surface_Types is not None:
            showIndent(outfile, level)
            outfile.write('Target_Attack_Surface_Types=model_.Target_Attack_Surface_TypesType(\n')
            self.Target_Attack_Surface_Types.exportLiteral(outfile, level, name_='Target_Attack_Surface_Types')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Target_Functional_Services is not None:
            showIndent(outfile, level)
            outfile.write('Target_Functional_Services=model_.Target_Functional_ServicesType(\n')
            self.Target_Functional_Services.exportLiteral(outfile, level, name_='Target_Functional_Services')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Targeted_OSI_Layers':
            obj_ = Targeted_OSI_LayersType.factory()
            obj_.build(child_)
            self.set_Targeted_OSI_Layers(obj_)
        elif nodeName_ == 'Target_Attack_Surface_Localities':
            obj_ = Target_Attack_Surface_LocalitiesType.factory()
            obj_.build(child_)
            self.set_Target_Attack_Surface_Localities(obj_)
        elif nodeName_ == 'Target_Attack_Surface_Types':
            obj_ = Target_Attack_Surface_TypesType.factory()
            obj_.build(child_)
            self.set_Target_Attack_Surface_Types(obj_)
        elif nodeName_ == 'Target_Functional_Services':
            obj_ = Target_Functional_ServicesType.factory()
            obj_.build(child_)
            self.set_Target_Functional_Services(obj_)
# end class Target_Attack_Surface_DescriptionType

class Relevant_Attack_Surface_ElementsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Relevant_Functional_Services=None, Relevant_Protocols=None, Relevant_Protocol_Headers=None, Relevant_Command_Structures=None):
        self.Relevant_Functional_Services = Relevant_Functional_Services
        self.Relevant_Protocols = Relevant_Protocols
        self.Relevant_Protocol_Headers = Relevant_Protocol_Headers
        self.Relevant_Command_Structures = Relevant_Command_Structures
    def factory(*args_, **kwargs_):
        if Relevant_Attack_Surface_ElementsType.subclass:
            return Relevant_Attack_Surface_ElementsType.subclass(*args_, **kwargs_)
        else:
            return Relevant_Attack_Surface_ElementsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Relevant_Functional_Services(self): return self.Relevant_Functional_Services
    def set_Relevant_Functional_Services(self, Relevant_Functional_Services): self.Relevant_Functional_Services = Relevant_Functional_Services
    def get_Relevant_Protocols(self): return self.Relevant_Protocols
    def set_Relevant_Protocols(self, Relevant_Protocols): self.Relevant_Protocols = Relevant_Protocols
    def get_Relevant_Protocol_Headers(self): return self.Relevant_Protocol_Headers
    def set_Relevant_Protocol_Headers(self, Relevant_Protocol_Headers): self.Relevant_Protocol_Headers = Relevant_Protocol_Headers
    def get_Relevant_Command_Structures(self): return self.Relevant_Command_Structures
    def set_Relevant_Command_Structures(self, Relevant_Command_Structures): self.Relevant_Command_Structures = Relevant_Command_Structures
    def hasContent_(self):
        if (
            self.Relevant_Functional_Services is not None or
            self.Relevant_Protocols is not None or
            self.Relevant_Protocol_Headers is not None or
            self.Relevant_Command_Structures is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='capec:', name_='Relevant_Attack_Surface_ElementsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Relevant_Attack_Surface_ElementsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Relevant_Attack_Surface_ElementsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Relevant_Attack_Surface_ElementsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Relevant_Functional_Services is not None:
            self.Relevant_Functional_Services.export(outfile, level, 'capec:', name_='Relevant_Functional_Services', pretty_print=pretty_print)
        if self.Relevant_Protocols is not None:
            self.Relevant_Protocols.export(outfile, level, 'capec:', name_='Relevant_Protocols', pretty_print=pretty_print)
        if self.Relevant_Protocol_Headers is not None:
            self.Relevant_Protocol_Headers.export(outfile, level, 'capec:', name_='Relevant_Protocol_Headers', pretty_print=pretty_print)
        if self.Relevant_Command_Structures is not None:
            self.Relevant_Command_Structures.export(outfile, level, 'capec:', name_='Relevant_Command_Structures', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='Relevant_Attack_Surface_ElementsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Relevant_Functional_Services is not None:
            showIndent(outfile, level)
            outfile.write('Relevant_Functional_Services=model_.Relevant_Functional_ServicesType(\n')
            self.Relevant_Functional_Services.exportLiteral(outfile, level, name_='Relevant_Functional_Services')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Relevant_Protocols is not None:
            showIndent(outfile, level)
            outfile.write('Relevant_Protocols=model_.Relevant_ProtocolsType(\n')
            self.Relevant_Protocols.exportLiteral(outfile, level, name_='Relevant_Protocols')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Relevant_Protocol_Headers is not None:
            showIndent(outfile, level)
            outfile.write('Relevant_Protocol_Headers=model_.Relevant_Protocol_HeadersType(\n')
            self.Relevant_Protocol_Headers.exportLiteral(outfile, level, name_='Relevant_Protocol_Headers')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Relevant_Command_Structures is not None:
            showIndent(outfile, level)
            outfile.write('Relevant_Command_Structures=model_.Relevant_Command_StructuresType(\n')
            self.Relevant_Command_Structures.exportLiteral(outfile, level, name_='Relevant_Command_Structures')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Relevant_Functional_Services':
            obj_ = Relevant_Functional_ServicesType.factory()
            obj_.build(child_)
            self.set_Relevant_Functional_Services(obj_)
        elif nodeName_ == 'Relevant_Protocols':
            obj_ = Relevant_ProtocolsType.factory()
            obj_.build(child_)
            self.set_Relevant_Protocols(obj_)
        elif nodeName_ == 'Relevant_Protocol_Headers':
            obj_ = Relevant_Protocol_HeadersType.factory()
            obj_.build(child_)
            self.set_Relevant_Protocol_Headers(obj_)
        elif nodeName_ == 'Relevant_Command_Structures':
            obj_ = Relevant_Command_StructuresType.factory()
            obj_.build(child_)
            self.set_Relevant_Command_Structures(obj_)
# end class Relevant_Attack_Surface_ElementsType

class Common_ConsequenceType(GeneratedsSuper):
    """The Common_Consequence_ID stores the value for the related
    Common_Consequence entry identifier as a string. Only one
    Common_Consequence_ID element can exist for each
    Common_Consequence element (ex: CC-1). However,
    Common_Consequences across CAPEC with the same ID should only
    vary in small details."""
    subclass = None
    superclass = None
    def __init__(self, Common_Consequence_ID=None, Consequence_Scope=None, Consequence_Technical_Impact=None, Consequence_Note=None):
        self.Common_Consequence_ID = _cast(None, Common_Consequence_ID)
        if Consequence_Scope is None:
            self.Consequence_Scope = []
        else:
            self.Consequence_Scope = Consequence_Scope
        if Consequence_Technical_Impact is None:
            self.Consequence_Technical_Impact = []
        else:
            self.Consequence_Technical_Impact = Consequence_Technical_Impact
        self.Consequence_Note = Consequence_Note
    def factory(*args_, **kwargs_):
        if Common_ConsequenceType.subclass:
            return Common_ConsequenceType.subclass(*args_, **kwargs_)
        else:
            return Common_ConsequenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Consequence_Scope(self): return self.Consequence_Scope
    def set_Consequence_Scope(self, Consequence_Scope): self.Consequence_Scope = Consequence_Scope
    def add_Consequence_Scope(self, value): self.Consequence_Scope.append(value)
    def insert_Consequence_Scope(self, index, value): self.Consequence_Scope[index] = value
    def get_Consequence_Technical_Impact(self): return self.Consequence_Technical_Impact
    def set_Consequence_Technical_Impact(self, Consequence_Technical_Impact): self.Consequence_Technical_Impact = Consequence_Technical_Impact
    def add_Consequence_Technical_Impact(self, value): self.Consequence_Technical_Impact.append(value)
    def insert_Consequence_Technical_Impact(self, index, value): self.Consequence_Technical_Impact[index] = value
    def get_Consequence_Note(self): return self.Consequence_Note
    def set_Consequence_Note(self, Consequence_Note): self.Consequence_Note = Consequence_Note
    def get_Common_Consequence_ID(self): return self.Common_Consequence_ID
    def set_Common_Consequence_ID(self, Common_Consequence_ID): self.Common_Consequence_ID = Common_Consequence_ID
    def hasContent_(self):
        if (
            self.Consequence_Scope or
            self.Consequence_Technical_Impact or
            self.Consequence_Note is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='capec:', name_='Common_ConsequenceType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Common_ConsequenceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Common_ConsequenceType'):
        if self.Common_Consequence_ID is not None and 'Common_Consequence_ID' not in already_processed:
            already_processed.add('Common_Consequence_ID')
            outfile.write(' Common_Consequence_ID=%s' % (self.gds_format_string(quote_attrib(self.Common_Consequence_ID).encode(ExternalEncoding), input_name='Common_Consequence_ID'), ))
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Common_ConsequenceType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Consequence_Scope_ in self.Consequence_Scope:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sConsequence_Scope>%s</%sConsequence_Scope>%s' % ('capec:', self.gds_format_string(quote_xml(Consequence_Scope_).encode(ExternalEncoding), input_name='Consequence_Scope'), 'capec:', eol_))
        for Consequence_Technical_Impact_ in self.Consequence_Technical_Impact:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sConsequence_Technical_Impact>%s</%sConsequence_Technical_Impact>%s' % ('capec:', self.gds_format_string(quote_xml(Consequence_Technical_Impact_).encode(ExternalEncoding), input_name='Consequence_Technical_Impact'), 'capec:', eol_))
        if self.Consequence_Note is not None:
            self.Consequence_Note.export(outfile, level, 'capec:', name_='Consequence_Note', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='Common_ConsequenceType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Common_Consequence_ID is not None and 'Common_Consequence_ID' not in already_processed:
            already_processed.add('Common_Consequence_ID')
            showIndent(outfile, level)
            outfile.write('Common_Consequence_ID = "%s",\n' % (self.Common_Consequence_ID,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Consequence_Scope=[\n')
        level += 1
        for Consequence_Scope_ in self.Consequence_Scope:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Consequence_Scope_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Consequence_Technical_Impact=[\n')
        level += 1
        for Consequence_Technical_Impact_ in self.Consequence_Technical_Impact:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Consequence_Technical_Impact_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Consequence_Note is not None:
            outfile.write('Consequence_Note=model_.Structured_Text_Type(\n')
            self.Consequence_Note.exportLiteral(outfile, level, name_='Consequence_Note')
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Common_Consequence_ID', node)
        if value is not None and 'Common_Consequence_ID' not in already_processed:
            already_processed.add('Common_Consequence_ID')
            self.Common_Consequence_ID = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Consequence_Scope':
            Consequence_Scope_ = child_.text
            Consequence_Scope_ = self.gds_validate_string(Consequence_Scope_, node, 'Consequence_Scope')
            self.Consequence_Scope.append(Consequence_Scope_)
        elif nodeName_ == 'Consequence_Technical_Impact':
            Consequence_Technical_Impact_ = child_.text
            Consequence_Technical_Impact_ = self.gds_validate_string(Consequence_Technical_Impact_, node, 'Consequence_Technical_Impact')
            self.Consequence_Technical_Impact.append(Consequence_Technical_Impact_)
        elif nodeName_ == 'Consequence_Note':
            obj_ = Structured_Text_Type.factory()
            obj_.build(child_)
            self.set_Consequence_Note(obj_)
# end class Common_ConsequenceType

class Attack_PatternType(GeneratedsSuper):
    """The Status attribute defines the status level for this view."""
    subclass = None
    superclass = None
    def __init__(self, Status=None, Pattern_Completeness=None, Pattern_Abstraction=None, ID=0, Name=None, Description=None, Alternate_Terms=None, Target_Attack_Surface=None, Attack_Prerequisites=None, Typical_Severity=None, Typical_Likelihood_of_Exploit=None, Methods_of_Attack=None, Examples_Instances=None, Attacker_Skills_or_Knowledge_Required=None, Resources_Required=None, Probing_Techniques=None, Indicators_Warnings_of_Attack=None, Obfuscation_Techniques=None, Solutions_and_Mitigations=None, Attack_Motivation_Consequences=None, Injection_Vector=None, Payload=None, Activation_Zone=None, Payload_Activation_Impact=None, Related_Weaknesses=None, Related_Vulnerabilities=None, Related_Attack_Patterns=None, Relevant_Security_Requirements=None, Relevant_Design_Patterns=None, Relevant_Security_Patterns=None, Related_Security_Principles=None, Related_Guidelines=None, Purposes=None, CIA_Impact=None, Technical_Context=None, Keywords=None, References=None, Other_Notes=None, Maintenance_Notes=None, Content_History=None):
        self.Status = _cast(None, Status)
        self.Pattern_Completeness = _cast(None, Pattern_Completeness)
        self.Pattern_Abstraction = _cast(None, Pattern_Abstraction)
        self.ID = _cast(int, ID)
        self.Name = _cast(None, Name)
        self.Description = Description
        self.Alternate_Terms = Alternate_Terms
        self.Target_Attack_Surface = Target_Attack_Surface
        self.Attack_Prerequisites = Attack_Prerequisites
        self.Typical_Severity = Typical_Severity
        self.Typical_Likelihood_of_Exploit = Typical_Likelihood_of_Exploit
        self.Methods_of_Attack = Methods_of_Attack
        self.Examples_Instances = Examples_Instances
        self.Attacker_Skills_or_Knowledge_Required = Attacker_Skills_or_Knowledge_Required
        self.Resources_Required = Resources_Required
        self.Probing_Techniques = Probing_Techniques
        self.Indicators_Warnings_of_Attack = Indicators_Warnings_of_Attack
        self.Obfuscation_Techniques = Obfuscation_Techniques
        self.Solutions_and_Mitigations = Solutions_and_Mitigations
        self.Attack_Motivation_Consequences = Attack_Motivation_Consequences
        self.Injection_Vector = Injection_Vector
        self.Payload = Payload
        self.Activation_Zone = Activation_Zone
        self.Payload_Activation_Impact = Payload_Activation_Impact
        self.Related_Weaknesses = Related_Weaknesses
        self.Related_Vulnerabilities = Related_Vulnerabilities
        self.Related_Attack_Patterns = Related_Attack_Patterns
        self.Relevant_Security_Requirements = Relevant_Security_Requirements
        self.Relevant_Design_Patterns = Relevant_Design_Patterns
        self.Relevant_Security_Patterns = Relevant_Security_Patterns
        self.Related_Security_Principles = Related_Security_Principles
        self.Related_Guidelines = Related_Guidelines
        self.Purposes = Purposes
        self.CIA_Impact = CIA_Impact
        self.Technical_Context = Technical_Context
        self.Keywords = Keywords
        self.References = References
        self.Other_Notes = Other_Notes
        self.Maintenance_Notes = Maintenance_Notes
        self.Content_History = Content_History
    def factory(*args_, **kwargs_):
        if Attack_PatternType.subclass:
            return Attack_PatternType.subclass(*args_, **kwargs_)
        else:
            return Attack_PatternType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_Alternate_Terms(self): return self.Alternate_Terms
    def set_Alternate_Terms(self, Alternate_Terms): self.Alternate_Terms = Alternate_Terms
    def get_Target_Attack_Surface(self): return self.Target_Attack_Surface
    def set_Target_Attack_Surface(self, Target_Attack_Surface): self.Target_Attack_Surface = Target_Attack_Surface
    def get_Attack_Prerequisites(self): return self.Attack_Prerequisites
    def set_Attack_Prerequisites(self, Attack_Prerequisites): self.Attack_Prerequisites = Attack_Prerequisites
    def get_Typical_Severity(self): return self.Typical_Severity
    def set_Typical_Severity(self, Typical_Severity): self.Typical_Severity = Typical_Severity
    def get_Typical_Likelihood_of_Exploit(self): return self.Typical_Likelihood_of_Exploit
    def set_Typical_Likelihood_of_Exploit(self, Typical_Likelihood_of_Exploit): self.Typical_Likelihood_of_Exploit = Typical_Likelihood_of_Exploit
    def get_Methods_of_Attack(self): return self.Methods_of_Attack
    def set_Methods_of_Attack(self, Methods_of_Attack): self.Methods_of_Attack = Methods_of_Attack
    def get_Examples_Instances(self): return self.Examples_Instances
    def set_Examples_Instances(self, Examples_Instances): self.Examples_Instances = Examples_Instances
    def get_Attacker_Skills_or_Knowledge_Required(self): return self.Attacker_Skills_or_Knowledge_Required
    def set_Attacker_Skills_or_Knowledge_Required(self, Attacker_Skills_or_Knowledge_Required): self.Attacker_Skills_or_Knowledge_Required = Attacker_Skills_or_Knowledge_Required
    def get_Resources_Required(self): return self.Resources_Required
    def set_Resources_Required(self, Resources_Required): self.Resources_Required = Resources_Required
    def get_Probing_Techniques(self): return self.Probing_Techniques
    def set_Probing_Techniques(self, Probing_Techniques): self.Probing_Techniques = Probing_Techniques
    def get_Indicators_Warnings_of_Attack(self): return self.Indicators_Warnings_of_Attack
    def set_Indicators_Warnings_of_Attack(self, Indicators_Warnings_of_Attack): self.Indicators_Warnings_of_Attack = Indicators_Warnings_of_Attack
    def get_Obfuscation_Techniques(self): return self.Obfuscation_Techniques
    def set_Obfuscation_Techniques(self, Obfuscation_Techniques): self.Obfuscation_Techniques = Obfuscation_Techniques
    def get_Solutions_and_Mitigations(self): return self.Solutions_and_Mitigations
    def set_Solutions_and_Mitigations(self, Solutions_and_Mitigations): self.Solutions_and_Mitigations = Solutions_and_Mitigations
    def get_Attack_Motivation_Consequences(self): return self.Attack_Motivation_Consequences
    def set_Attack_Motivation_Consequences(self, Attack_Motivation_Consequences): self.Attack_Motivation_Consequences = Attack_Motivation_Consequences
    def get_Injection_Vector(self): return self.Injection_Vector
    def set_Injection_Vector(self, Injection_Vector): self.Injection_Vector = Injection_Vector
    def get_Payload(self): return self.Payload
    def set_Payload(self, Payload): self.Payload = Payload
    def get_Activation_Zone(self): return self.Activation_Zone
    def set_Activation_Zone(self, Activation_Zone): self.Activation_Zone = Activation_Zone
    def get_Payload_Activation_Impact(self): return self.Payload_Activation_Impact
    def set_Payload_Activation_Impact(self, Payload_Activation_Impact): self.Payload_Activation_Impact = Payload_Activation_Impact
    def get_Related_Weaknesses(self): return self.Related_Weaknesses
    def set_Related_Weaknesses(self, Related_Weaknesses): self.Related_Weaknesses = Related_Weaknesses
    def get_Related_Vulnerabilities(self): return self.Related_Vulnerabilities
    def set_Related_Vulnerabilities(self, Related_Vulnerabilities): self.Related_Vulnerabilities = Related_Vulnerabilities
    def get_Related_Attack_Patterns(self): return self.Related_Attack_Patterns
    def set_Related_Attack_Patterns(self, Related_Attack_Patterns): self.Related_Attack_Patterns = Related_Attack_Patterns
    def get_Relevant_Security_Requirements(self): return self.Relevant_Security_Requirements
    def set_Relevant_Security_Requirements(self, Relevant_Security_Requirements): self.Relevant_Security_Requirements = Relevant_Security_Requirements
    def get_Relevant_Design_Patterns(self): return self.Relevant_Design_Patterns
    def set_Relevant_Design_Patterns(self, Relevant_Design_Patterns): self.Relevant_Design_Patterns = Relevant_Design_Patterns
    def get_Relevant_Security_Patterns(self): return self.Relevant_Security_Patterns
    def set_Relevant_Security_Patterns(self, Relevant_Security_Patterns): self.Relevant_Security_Patterns = Relevant_Security_Patterns
    def get_Related_Security_Principles(self): return self.Related_Security_Principles
    def set_Related_Security_Principles(self, Related_Security_Principles): self.Related_Security_Principles = Related_Security_Principles
    def get_Related_Guidelines(self): return self.Related_Guidelines
    def set_Related_Guidelines(self, Related_Guidelines): self.Related_Guidelines = Related_Guidelines
    def get_Purposes(self): return self.Purposes
    def set_Purposes(self, Purposes): self.Purposes = Purposes
    def get_CIA_Impact(self): return self.CIA_Impact
    def set_CIA_Impact(self, CIA_Impact): self.CIA_Impact = CIA_Impact
    def get_Technical_Context(self): return self.Technical_Context
    def set_Technical_Context(self, Technical_Context): self.Technical_Context = Technical_Context
    def get_Keywords(self): return self.Keywords
    def set_Keywords(self, Keywords): self.Keywords = Keywords
    def get_References(self): return self.References
    def set_References(self, References): self.References = References
    def get_Other_Notes(self): return self.Other_Notes
    def set_Other_Notes(self, Other_Notes): self.Other_Notes = Other_Notes
    def get_Maintenance_Notes(self): return self.Maintenance_Notes
    def set_Maintenance_Notes(self, Maintenance_Notes): self.Maintenance_Notes = Maintenance_Notes
    def get_Content_History(self): return self.Content_History
    def set_Content_History(self, Content_History): self.Content_History = Content_History
    def get_Status(self): return self.Status
    def set_Status(self, Status): self.Status = Status
    def get_Pattern_Completeness(self): return self.Pattern_Completeness
    def set_Pattern_Completeness(self, Pattern_Completeness): self.Pattern_Completeness = Pattern_Completeness
    def get_Pattern_Abstraction(self): return self.Pattern_Abstraction
    def set_Pattern_Abstraction(self, Pattern_Abstraction): self.Pattern_Abstraction = Pattern_Abstraction
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def hasContent_(self):
        if (
            self.Description is not None or
            self.Alternate_Terms is not None or
            self.Target_Attack_Surface is not None or
            self.Attack_Prerequisites is not None or
            self.Typical_Severity is not None or
            self.Typical_Likelihood_of_Exploit is not None or
            self.Methods_of_Attack is not None or
            self.Examples_Instances is not None or
            self.Attacker_Skills_or_Knowledge_Required is not None or
            self.Resources_Required is not None or
            self.Probing_Techniques is not None or
            self.Indicators_Warnings_of_Attack is not None or
            self.Obfuscation_Techniques is not None or
            self.Solutions_and_Mitigations is not None or
            self.Attack_Motivation_Consequences is not None or
            self.Injection_Vector is not None or
            self.Payload is not None or
            self.Activation_Zone is not None or
            self.Payload_Activation_Impact is not None or
            self.Related_Weaknesses is not None or
            self.Related_Vulnerabilities is not None or
            self.Related_Attack_Patterns is not None or
            self.Relevant_Security_Requirements is not None or
            self.Relevant_Design_Patterns is not None or
            self.Relevant_Security_Patterns is not None or
            self.Related_Security_Principles is not None or
            self.Related_Guidelines is not None or
            self.Purposes is not None or
            self.CIA_Impact is not None or
            self.Technical_Context is not None or
            self.Keywords is not None or
            self.References is not None or
            self.Other_Notes is not None or
            self.Maintenance_Notes is not None or
            self.Content_History is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='capec:', name_='Attack_PatternType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Attack_PatternType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='capec:', name_='Attack_PatternType'):
        if self.Status is not None and 'Status' not in already_processed:
            already_processed.add('Status')
            outfile.write(' Status=%s' % (quote_attrib(self.Status), ))
        if self.Pattern_Completeness is not None and 'Pattern_Completeness' not in already_processed:
            already_processed.add('Pattern_Completeness')
            outfile.write(' Pattern_Completeness=%s' % (self.gds_format_string(quote_attrib(self.Pattern_Completeness).encode(ExternalEncoding), input_name='Pattern_Completeness'), ))
        if self.Pattern_Abstraction is not None and 'Pattern_Abstraction' not in already_processed:
            already_processed.add('Pattern_Abstraction')
            outfile.write(' Pattern_Abstraction=%s' % (self.gds_format_string(quote_attrib(self.Pattern_Abstraction).encode(ExternalEncoding), input_name='Pattern_Abstraction'), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID="%s"' % self.gds_format_integer(self.ID, input_name='ID'))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.add('Name')
            outfile.write(' Name=%s' % (self.gds_format_string(quote_attrib(self.Name).encode(ExternalEncoding), input_name='Name'), ))
    def exportChildren(self, outfile, level, namespace_='capec:', name_='Attack_PatternType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Description is not None:
            self.Description.export(outfile, level, 'capec:', name_='Description', pretty_print=pretty_print)
        if self.Alternate_Terms is not None:
            self.Alternate_Terms.export(outfile, level, 'capec:', name_='Alternate_Terms', pretty_print=pretty_print)
        if self.Target_Attack_Surface is not None:
            self.Target_Attack_Surface.export(outfile, level, 'capec:', name_='Target_Attack_Surface', pretty_print=pretty_print)
        if self.Attack_Prerequisites is not None:
            self.Attack_Prerequisites.export(outfile, level, 'capec:', name_='Attack_Prerequisites', pretty_print=pretty_print)
        if self.Typical_Severity is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTypical_Severity>%s</%sTypical_Severity>%s' % ('capec:', self.gds_format_string(quote_xml(self.Typical_Severity).encode(ExternalEncoding), input_name='Typical_Severity'), 'capec:', eol_))
        if self.Typical_Likelihood_of_Exploit is not None:
            self.Typical_Likelihood_of_Exploit.export(outfile, level, 'capec:', name_='Typical_Likelihood_of_Exploit', pretty_print=pretty_print)
        if self.Methods_of_Attack is not None:
            self.Methods_of_Attack.export(outfile, level, 'capec:', name_='Methods_of_Attack', pretty_print=pretty_print)
        if self.Examples_Instances is not None:
            self.Examples_Instances.export(outfile, level, 'capec:', name_='Examples-Instances', pretty_print=pretty_print)
        if self.Attacker_Skills_or_Knowledge_Required is not None:
            self.Attacker_Skills_or_Knowledge_Required.export(outfile, level, 'capec:', name_='Attacker_Skills_or_Knowledge_Required', pretty_print=pretty_print)
        if self.Resources_Required is not None:
            self.Resources_Required.export(outfile, level, 'capec:', name_='Resources_Required', pretty_print=pretty_print)
        if self.Probing_Techniques is not None:
            self.Probing_Techniques.export(outfile, level, 'capec:', name_='Probing_Techniques', pretty_print=pretty_print)
        if self.Indicators_Warnings_of_Attack is not None:
            self.Indicators_Warnings_of_Attack.export(outfile, level, 'capec:', name_='Indicators-Warnings_of_Attack', pretty_print=pretty_print)
        if self.Obfuscation_Techniques is not None:
            self.Obfuscation_Techniques.export(outfile, level, 'capec:', name_='Obfuscation_Techniques', pretty_print=pretty_print)
        if self.Solutions_and_Mitigations is not None:
            self.Solutions_and_Mitigations.export(outfile, level, 'capec:', name_='Solutions_and_Mitigations', pretty_print=pretty_print)
        if self.Attack_Motivation_Consequences is not None:
            self.Attack_Motivation_Consequences.export(outfile, level, 'capec:', name_='Attack_Motivation-Consequences', pretty_print=pretty_print)
        if self.Injection_Vector is not None:
            self.Injection_Vector.export(outfile, level, 'capec:', name_='Injection_Vector', pretty_print=pretty_print)
        if self.Payload is not None:
            self.Payload.export(outfile, level, 'capec:', name_='Payload', pretty_print=pretty_print)
        if self.Activation_Zone is not None:
            self.Activation_Zone.export(outfile, level, 'capec:', name_='Activation_Zone', pretty_print=pretty_print)
        if self.Payload_Activation_Impact is not None:
            self.Payload_Activation_Impact.export(outfile, level, 'capec:', name_='Payload_Activation_Impact', pretty_print=pretty_print)
        if self.Related_Weaknesses is not None:
            self.Related_Weaknesses.export(outfile, level, 'capec:', name_='Related_Weaknesses', pretty_print=pretty_print)
        if self.Related_Vulnerabilities is not None:
            self.Related_Vulnerabilities.export(outfile, level, 'capec:', name_='Related_Vulnerabilities', pretty_print=pretty_print)
        if self.Related_Attack_Patterns is not None:
            self.Related_Attack_Patterns.export(outfile, level, 'capec:', name_='Related_Attack_Patterns', pretty_print=pretty_print)
        if self.Relevant_Security_Requirements is not None:
            self.Relevant_Security_Requirements.export(outfile, level, 'capec:', name_='Relevant_Security_Requirements', pretty_print=pretty_print)
        if self.Relevant_Design_Patterns is not None:
            self.Relevant_Design_Patterns.export(outfile, level, 'capec:', name_='Relevant_Design_Patterns', pretty_print=pretty_print)
        if self.Relevant_Security_Patterns is not None:
            self.Relevant_Security_Patterns.export(outfile, level, 'capec:', name_='Relevant_Security_Patterns', pretty_print=pretty_print)
        if self.Related_Security_Principles is not None:
            self.Related_Security_Principles.export(outfile, level, 'capec:', name_='Related_Security_Principles', pretty_print=pretty_print)
        if self.Related_Guidelines is not None:
            self.Related_Guidelines.export(outfile, level, 'capec:', name_='Related_Guidelines', pretty_print=pretty_print)
        if self.Purposes is not None:
            self.Purposes.export(outfile, level, 'capec:', name_='Purposes', pretty_print=pretty_print)
        if self.CIA_Impact is not None:
            self.CIA_Impact.export(outfile, level, 'capec:', name_='CIA_Impact', pretty_print=pretty_print)
        if self.Technical_Context is not None:
            self.Technical_Context.export(outfile, level, 'capec:', name_='Technical_Context', pretty_print=pretty_print)
        if self.Keywords is not None:
            self.Keywords.export(outfile, level, 'capec:', name_='Keywords', pretty_print=pretty_print)
        if self.References is not None:
            self.References.export(outfile, level, 'capec:', name_='References', pretty_print=pretty_print)
        if self.Other_Notes is not None:
            self.Other_Notes.export(outfile, level, 'capec:', name_='Other_Notes', pretty_print=pretty_print)
        if self.Maintenance_Notes is not None:
            self.Maintenance_Notes.export(outfile, level, 'capec:', name_='Maintenance_Notes', pretty_print=pretty_print)
        if self.Content_History is not None:
            self.Content_History.export(outfile, level, 'capec:', name_='Content_History', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='Attack_PatternType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Status is not None and 'Status' not in already_processed:
            already_processed.add('Status')
            showIndent(outfile, level)
            outfile.write('Status = %s,\n' % (self.Status,))
        if self.Pattern_Completeness is not None and 'Pattern_Completeness' not in already_processed:
            already_processed.add('Pattern_Completeness')
            showIndent(outfile, level)
            outfile.write('Pattern_Completeness = "%s",\n' % (self.Pattern_Completeness,))
        if self.Pattern_Abstraction is not None and 'Pattern_Abstraction' not in already_processed:
            already_processed.add('Pattern_Abstraction')
            showIndent(outfile, level)
            outfile.write('Pattern_Abstraction = "%s",\n' % (self.Pattern_Abstraction,))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            showIndent(outfile, level)
            outfile.write('ID = %d,\n' % (self.ID,))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.add('Name')
            showIndent(outfile, level)
            outfile.write('Name = "%s",\n' % (self.Name,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Description is not None:
            outfile.write('Description=model_.DescriptionType102(\n')
            self.Description.exportLiteral(outfile, level, name_='Description')
            outfile.write('),\n')
        if self.Alternate_Terms is not None:
            showIndent(outfile, level)
            outfile.write('Alternate_Terms=model_.Alternate_Terms(\n')
            self.Alternate_Terms.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Target_Attack_Surface is not None:
            outfile.write('Target_Attack_Surface=model_.Target_Attack_SurfaceType(\n')
            self.Target_Attack_Surface.exportLiteral(outfile, level, name_='Target_Attack_Surface')
            outfile.write('),\n')
        if self.Attack_Prerequisites is not None:
            showIndent(outfile, level)
            outfile.write('Attack_Prerequisites=model_.Attack_PrerequisitesType104(\n')
            self.Attack_Prerequisites.exportLiteral(outfile, level, name_='Attack_Prerequisites')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Typical_Severity is not None:
            showIndent(outfile, level)
            outfile.write('Typical_Severity=%s,\n' % quote_python(self.Typical_Severity).encode(ExternalEncoding))
        if self.Typical_Likelihood_of_Exploit is not None:
            showIndent(outfile, level)
            outfile.write('Typical_Likelihood_of_Exploit=model_.Typical_Likelihood_of_ExploitType(\n')
            self.Typical_Likelihood_of_Exploit.exportLiteral(outfile, level, name_='Typical_Likelihood_of_Exploit')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Methods_of_Attack is not None:
            showIndent(outfile, level)
            outfile.write('Methods_of_Attack=model_.Methods_of_AttackType107(\n')
            self.Methods_of_Attack.exportLiteral(outfile, level, name_='Methods_of_Attack')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Examples_Instances is not None:
            showIndent(outfile, level)
            outfile.write('Examples_Instances=model_.Examples_InstancesType(\n')
            self.Examples_Instances.exportLiteral(outfile, level, name_='Examples_Instances')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Attacker_Skills_or_Knowledge_Required is not None:
            showIndent(outfile, level)
            outfile.write('Attacker_Skills_or_Knowledge_Required=model_.Attacker_Skills_or_Knowledge_RequiredType113(\n')
            self.Attacker_Skills_or_Knowledge_Required.exportLiteral(outfile, level, name_='Attacker_Skills_or_Knowledge_Required')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Resources_Required is not None:
            outfile.write('Resources_Required=model_.Structured_Text_Type(\n')
            self.Resources_Required.exportLiteral(outfile, level, name_='Resources_Required')
            outfile.write('),\n')
        if self.Probing_Techniques is not None:
            showIndent(outfile, level)
            outfile.write('Probing_Techniques=model_.Probing_TechniquesType(\n')
            self.Probing_Techniques.exportLiteral(outfile, level, name_='Probing_Techniques')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Indicators_Warnings_of_Attack is not None:
            showIndent(outfile, level)
            outfile.write('Indicators_Warnings_of_Attack=model_.Indicators_Warnings_of_AttackType(\n')
            self.Indicators_Warnings_of_Attack.exportLiteral(outfile, level, name_='Indicators_Warnings_of_Attack')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Obfuscation_Techniques is not None:
            showIndent(outfile, level)
            outfile.write('Obfuscation_Techniques=model_.Obfuscation_TechniquesType121(\n')
            self.Obfuscation_Techniques.exportLiteral(outfile, level, name_='Obfuscation_Techniques')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Solutions_and_Mitigations is not None:
            showIndent(outfile, level)
            outfile.write('Solutions_and_Mitigations=model_.Solutions_and_MitigationsType(\n')
            self.Solutions_and_Mitigations.exportLiteral(outfile, level, name_='Solutions_and_Mitigations')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Attack_Motivation_Consequences is not None:
            showIndent(outfile, level)
            outfile.write('Attack_Motivation_Consequences=model_.Attack_Motivation_ConsequencesType126(\n')
            self.Attack_Motivation_Consequences.exportLiteral(outfile, level, name_='Attack_Motivation_Consequences')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Injection_Vector is not None:
            outfile.write('Injection_Vector=model_.Structured_Text_Type(\n')
            self.Injection_Vector.exportLiteral(outfile, level, name_='Injection_Vector')
            outfile.write('),\n')
        if self.Payload is not None:
            outfile.write('Payload=model_.Structured_Text_Type(\n')
            self.Payload.exportLiteral(outfile, level, name_='Payload')
            outfile.write('),\n')
        if self.Activation_Zone is not None:
            outfile.write('Activation_Zone=model_.Structured_Text_Type(\n')
            self.Activation_Zone.exportLiteral(outfile, level, name_='Activation_Zone')
            outfile.write('),\n')
        if self.Payload_Activation_Impact is not None:
            showIndent(outfile, level)
            outfile.write('Payload_Activation_Impact=model_.Payload_Activation_ImpactType(\n')
            self.Payload_Activation_Impact.exportLiteral(outfile, level, name_='Payload_Activation_Impact')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Related_Weaknesses is not None:
            showIndent(outfile, level)
            outfile.write('Related_Weaknesses=model_.Related_WeaknessesType129(\n')
            self.Related_Weaknesses.exportLiteral(outfile, level, name_='Related_Weaknesses')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Related_Vulnerabilities is not None:
            showIndent(outfile, level)
            outfile.write('Related_Vulnerabilities=model_.Related_VulnerabilitiesType(\n')
            self.Related_Vulnerabilities.exportLiteral(outfile, level, name_='Related_Vulnerabilities')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Related_Attack_Patterns is not None:
            showIndent(outfile, level)
            outfile.write('Related_Attack_Patterns=model_.Related_Attack_PatternsType(\n')
            self.Related_Attack_Patterns.exportLiteral(outfile, level, name_='Related_Attack_Patterns')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Relevant_Security_Requirements is not None:
            showIndent(outfile, level)
            outfile.write('Relevant_Security_Requirements=model_.Relevant_Security_RequirementsType(\n')
            self.Relevant_Security_Requirements.exportLiteral(outfile, level, name_='Relevant_Security_Requirements')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Relevant_Design_Patterns is not None:
            showIndent(outfile, level)
            outfile.write('Relevant_Design_Patterns=model_.Relevant_Design_PatternsType(\n')
            self.Relevant_Design_Patterns.exportLiteral(outfile, level, name_='Relevant_Design_Patterns')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Relevant_Security_Patterns is not None:
            showIndent(outfile, level)
            outfile.write('Relevant_Security_Patterns=model_.Relevant_Security_PatternsType(\n')
            self.Relevant_Security_Patterns.exportLiteral(outfile, level, name_='Relevant_Security_Patterns')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Related_Security_Principles is not None:
            showIndent(outfile, level)
            outfile.write('Related_Security_Principles=model_.Related_Security_PrinciplesType(\n')
            self.Related_Security_Principles.exportLiteral(outfile, level, name_='Related_Security_Principles')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Related_Guidelines is not None:
            showIndent(outfile, level)
            outfile.write('Related_Guidelines=model_.Related_GuidelinesType(\n')
            self.Related_Guidelines.exportLiteral(outfile, level, name_='Related_Guidelines')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Purposes is not None:
            showIndent(outfile, level)
            outfile.write('Purposes=model_.PurposesType(\n')
            self.Purposes.exportLiteral(outfile, level, name_='Purposes')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CIA_Impact is not None:
            showIndent(outfile, level)
            outfile.write('CIA_Impact=model_.CIA_ImpactType(\n')
            self.CIA_Impact.exportLiteral(outfile, level, name_='CIA_Impact')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Technical_Context is not None:
            showIndent(outfile, level)
            outfile.write('Technical_Context=model_.Technical_ContextType(\n')
            self.Technical_Context.exportLiteral(outfile, level, name_='Technical_Context')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Keywords is not None:
            showIndent(outfile, level)
            outfile.write('Keywords=model_.KeywordsType150(\n')
            self.Keywords.exportLiteral(outfile, level, name_='Keywords')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.References is not None:
            outfile.write('References=model_.ReferencesType152(\n')
            self.References.exportLiteral(outfile, level, name_='References')
            outfile.write('),\n')
        if self.Other_Notes is not None:
            showIndent(outfile, level)
            outfile.write('Other_Notes=model_.Other_Notes(\n')
            self.Other_Notes.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Maintenance_Notes is not None:
            showIndent(outfile, level)
            outfile.write('Maintenance_Notes=model_.Maintenance_Notes(\n')
            self.Maintenance_Notes.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Content_History is not None:
            showIndent(outfile, level)
            outfile.write('Content_History=model_.Content_History(\n')
            self.Content_History.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Status', node)
        if value is not None and 'Status' not in already_processed:
            already_processed.add('Status')
            self.Status = value
        value = find_attr_value_('Pattern_Completeness', node)
        if value is not None and 'Pattern_Completeness' not in already_processed:
            already_processed.add('Pattern_Completeness')
            self.Pattern_Completeness = value
        value = find_attr_value_('Pattern_Abstraction', node)
        if value is not None and 'Pattern_Abstraction' not in already_processed:
            already_processed.add('Pattern_Abstraction')
            self.Pattern_Abstraction = value
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            try:
                self.ID = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('Name', node)
        if value is not None and 'Name' not in already_processed:
            already_processed.add('Name')
            self.Name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Description':
            obj_ = Structured_Text_Type.factory()
            obj_.build(child_)
            self.set_Description(obj_)
        elif nodeName_ == 'Alternate_Terms':
            obj_ = Alternate_Terms.factory()
            obj_.build(child_)
            self.set_Alternate_Terms(obj_)
        elif nodeName_ == 'Target_Attack_Surface':
            obj_ = Target_Attack_SurfaceType.factory()
            obj_.build(child_)
            self.set_Target_Attack_Surface(obj_)
        elif nodeName_ == 'Attack_Prerequisites':
            obj_ = Attack_PrerequisitesType104.factory()
            obj_.build(child_)
            self.set_Attack_Prerequisites(obj_)
        elif nodeName_ == 'Typical_Severity':
            Typical_Severity_ = child_.text
            Typical_Severity_ = self.gds_validate_string(Typical_Severity_, node, 'Typical_Severity')
            self.Typical_Severity = Typical_Severity_
        elif nodeName_ == 'Typical_Likelihood_of_Exploit':
            obj_ = Typical_Likelihood_of_ExploitType.factory()
            obj_.build(child_)
            self.set_Typical_Likelihood_of_Exploit(obj_)
        elif nodeName_ == 'Methods_of_Attack':
            obj_ = Methods_of_AttackType107.factory()
            obj_.build(child_)
            self.set_Methods_of_Attack(obj_)
        elif nodeName_ == 'Examples-Instances':
            obj_ = Examples_InstancesType.factory()
            obj_.build(child_)
            self.set_Examples_Instances(obj_)
        elif nodeName_ == 'Attacker_Skills_or_Knowledge_Required':
            obj_ = Attacker_Skills_or_Knowledge_RequiredType113.factory()
            obj_.build(child_)
            self.set_Attacker_Skills_or_Knowledge_Required(obj_)
        elif nodeName_ == 'Resources_Required':
            obj_ = Structured_Text_Type.factory()
            obj_.build(child_)
            self.set_Resources_Required(obj_)
        elif nodeName_ == 'Probing_Techniques':
            obj_ = Probing_TechniquesType.factory()
            obj_.build(child_)
            self.set_Probing_Techniques(obj_)
        elif nodeName_ == 'Indicators-Warnings_of_Attack':
            obj_ = Indicators_Warnings_of_AttackType.factory()
            obj_.build(child_)
            self.set_Indicators_Warnings_of_Attack(obj_)
        elif nodeName_ == 'Obfuscation_Techniques':
            obj_ = Obfuscation_TechniquesType121.factory()
            obj_.build(child_)
            self.set_Obfuscation_Techniques(obj_)
        elif nodeName_ == 'Solutions_and_Mitigations':
            obj_ = Solutions_and_MitigationsType.factory()
            obj_.build(child_)
            self.set_Solutions_and_Mitigations(obj_)
        elif nodeName_ == 'Attack_Motivation-Consequences':
            obj_ = Attack_Motivation_ConsequencesType126.factory()
            obj_.build(child_)
            self.set_Attack_Motivation_Consequences(obj_)
        elif nodeName_ == 'Injection_Vector':
            obj_ = Structured_Text_Type.factory()
            obj_.build(child_)
            self.set_Injection_Vector(obj_)
        elif nodeName_ == 'Payload':
            obj_ = Structured_Text_Type.factory()
            obj_.build(child_)
            self.set_Payload(obj_)
        elif nodeName_ == 'Activation_Zone':
            obj_ = Structured_Text_Type.factory()
            obj_.build(child_)
            self.set_Activation_Zone(obj_)
        elif nodeName_ == 'Payload_Activation_Impact':
            obj_ = Payload_Activation_ImpactType.factory()
            obj_.build(child_)
            self.set_Payload_Activation_Impact(obj_)
        elif nodeName_ == 'Related_Weaknesses':
            obj_ = Related_WeaknessesType129.factory()
            obj_.build(child_)
            self.set_Related_Weaknesses(obj_)
        elif nodeName_ == 'Related_Vulnerabilities':
            obj_ = Related_VulnerabilitiesType.factory()
            obj_.build(child_)
            self.set_Related_Vulnerabilities(obj_)
        elif nodeName_ == 'Related_Attack_Patterns':
            obj_ = Related_Attack_PatternsType.factory()
            obj_.build(child_)
            self.set_Related_Attack_Patterns(obj_)
        elif nodeName_ == 'Relevant_Security_Requirements':
            obj_ = Relevant_Security_RequirementsType.factory()
            obj_.build(child_)
            self.set_Relevant_Security_Requirements(obj_)
        elif nodeName_ == 'Relevant_Design_Patterns':
            obj_ = Relevant_Design_PatternsType.factory()
            obj_.build(child_)
            self.set_Relevant_Design_Patterns(obj_)
        elif nodeName_ == 'Relevant_Security_Patterns':
            obj_ = Relevant_Security_PatternsType.factory()
            obj_.build(child_)
            self.set_Relevant_Security_Patterns(obj_)
        elif nodeName_ == 'Related_Security_Principles':
            obj_ = Related_Security_PrinciplesType.factory()
            obj_.build(child_)
            self.set_Related_Security_Principles(obj_)
        elif nodeName_ == 'Related_Guidelines':
            obj_ = Related_GuidelinesType.factory()
            obj_.build(child_)
            self.set_Related_Guidelines(obj_)
        elif nodeName_ == 'Purposes':
            obj_ = PurposesType.factory()
            obj_.build(child_)
            self.set_Purposes(obj_)
        elif nodeName_ == 'CIA_Impact':
            obj_ = CIA_ImpactType.factory()
            obj_.build(child_)
            self.set_CIA_Impact(obj_)
        elif nodeName_ == 'Technical_Context':
            obj_ = Technical_ContextType.factory()
            obj_.build(child_)
            self.set_Technical_Context(obj_)
        elif nodeName_ == 'Keywords':
            obj_ = KeywordsType150.factory()
            obj_.build(child_)
            self.set_Keywords(obj_)
        elif nodeName_ == 'References':
            obj_ = Reference_List_Type.factory()
            obj_.build(child_)
            self.set_References(obj_)
        elif nodeName_ == 'Other_Notes':
            obj_ = Other_Notes.factory()
            obj_.build(child_)
            self.set_Other_Notes(obj_)
        elif nodeName_ == 'Maintenance_Notes':
            obj_ = Maintenance_Notes.factory()
            obj_.build(child_)
            self.set_Maintenance_Notes(obj_)
        elif nodeName_ == 'Content_History':
            obj_ = Content_History.factory()
            obj_.build(child_)
            self.set_Content_History(obj_)
# end class Attack_PatternType

GDSClassesMapping = {
    'Relationships': cybox_core.RelationshipsType,
    'Action_Arguments': cybox_core.ActionArgumentsType,
    'Defined_Effect': cybox_core.DefinedEffectType,
    'Action_Argument': cybox_core.ActionArgumentType,
    'IfPresent_Observables': cybox_core.ObservablesType,
    'Observable': cybox_core.ObservableType,
    'Pools': cybox_core.PoolsType,
    'Evasion_Techniques': cybox_core.ObfuscationTechniquesType,
    'Associated_Objects': cybox_core.AssociatedObjectsType,
    'IfNotPresent_Observables': cybox_core.ObservablesType,
    'Domain_Specific_Object_Properties': cybox_core.DomainSpecificObjectPropertiesType,
    'Related_Objects': cybox_core.RelatedObjectsType,
    'Property_Pool': cybox_core.PropertyPoolType,
    'Observable_Composition': cybox_core.ObservableCompositionType,
    'Action_Pool': cybox_core.ActionPoolType,
    'Associated_Object': cybox_core.AssociatedObjectType,
    'Properties': cybox_core.PropertiesType,
    'Action_Reference': cybox_core.ActionReferenceType,
    'Event_Pool': cybox_core.EventPoolType,
    'Old_Object': cybox_core.ObjectType,
    'Object_Pool': cybox_core.ObjectPoolType,
    'Keywords': cybox_core.KeywordsType,
    'Pattern_Fidelity': cybox_core.PatternFidelityType,
    'Action_Pertinent_Object_Properties': cybox_core.ActionPertinentObjectPropertiesType,
    'Related_Object': cybox_core.RelatedObjectType,
    'Values': cybox_core.ValuesType,
    'Observables': cybox_core.ObservablesType,
    'New_Object': cybox_core.ObjectType,
    'Actions': cybox_core.ActionsType,
    'Action_Aliases': cybox_core.ActionAliasesType,
}

USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""

def usage():
    print USAGE_TEXT
    sys.exit(1)

def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass

def parse(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Attack_Pattern_Catalog'
        rootClass = Attack_Pattern_Catalog
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('<?xml version="1.0" ?>\n')
    rootObj.export(sys.stdout, 0, name_=rootTag,
        namespacedef_='',
        pretty_print=True)
    return rootObj

def parseEtree(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Attack_Pattern_Catalog'
        rootClass = Attack_Pattern_Catalog
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    rootElement = rootObj.to_etree(None, name_=rootTag)
    content = etree_.tostring(rootElement, pretty_print=True,
        xml_declaration=True, encoding="utf-8")
    sys.stdout.write(content)
    sys.stdout.write('\n')
    return rootObj, rootElement

def parseString(inString):
    from StringIO import StringIO
    doc = parsexml_(StringIO(inString))
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Attack_Pattern_Catalog'
        rootClass = Attack_Pattern_Catalog
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('<?xml version="1.0" ?>\n')
    rootObj.export(sys.stdout, 0, name_="Attack_Pattern_Catalog",
        namespacedef_='')
    return rootObj

def parseLiteral(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Attack_Pattern_Catalog'
        rootClass = Attack_Pattern_Catalog
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('#from ap_schema_v2.5 import *\n\n')
    sys.stdout.write('from datetime import datetime as datetime_\n\n')
    sys.stdout.write('import ap_schema_v2.5 as model_\n\n')
    sys.stdout.write('rootObj = model_.rootTag(\n')
    rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
    sys.stdout.write(')\n')
    return rootObj

def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()

if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()

__all__ = [
    "RelationshipType",
    "ObservablesType",
    "Structured_Text_Type",
    "Reference_List_Type",
    "Reference_Type",
    "Custom_Attack_StepType",
    "Target_Attack_SurfaceType",
    "Target_Attack_Surface_DescriptionType",
    "Relevant_Attack_Surface_ElementsType",
    "Common_ConsequenceType",
    "Attack_PatternType"
    ]