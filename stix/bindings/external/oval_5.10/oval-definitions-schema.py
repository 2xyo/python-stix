#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Thu Apr 11 15:08:17 2013 by generateDS.py version 2.9a.
#

import sys
import getopt
import re as re_

import oval-common-schema
import xmldsig-core-schema
import base64
from datetime import datetime, tzinfo, timedelta

etree_ = None
Verbose_import_ = False
(   XMLParser_import_none, XMLParser_import_lxml,
    XMLParser_import_elementtree
    ) = range(3)
XMLParser_import_library = None
try:
    # lxml
    from lxml import etree as etree_
    XMLParser_import_library = XMLParser_import_lxml
    if Verbose_import_:
        print("running with lxml.etree")
except ImportError:
    try:
        # cElementTree from Python 2.5+
        import xml.etree.cElementTree as etree_
        XMLParser_import_library = XMLParser_import_elementtree
        if Verbose_import_:
            print("running with cElementTree on Python 2.5+")
    except ImportError:
        try:
            # ElementTree from Python 2.5+
            import xml.etree.ElementTree as etree_
            XMLParser_import_library = XMLParser_import_elementtree
            if Verbose_import_:
                print("running with ElementTree on Python 2.5+")
        except ImportError:
            try:
                # normal cElementTree install
                import cElementTree as etree_
                XMLParser_import_library = XMLParser_import_elementtree
                if Verbose_import_:
                    print("running with cElementTree")
            except ImportError:
                try:
                    # normal ElementTree install
                    import elementtree.ElementTree as etree_
                    XMLParser_import_library = XMLParser_import_elementtree
                    if Verbose_import_:
                        print("running with ElementTree")
                except ImportError:
                    raise ImportError(
                        "Failed to import ElementTree from any known place")

def parsexml_(*args, **kwargs):
    if (XMLParser_import_library == XMLParser_import_lxml and
        'parser' not in kwargs):
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        kwargs['parser'] = etree_.ETCompatXMLParser()
    doc = etree_.parse(*args, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError, exp:

    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(tzinfo):
            def __init__(self, offset, name):
                self.__offset = timedelta(minutes = offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node, input_name=''):
            return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_integer_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of integers')
            return input_data
        def gds_format_float(self, input_data, input_name=''):
            return '%f' % input_data
        def gds_validate_float(self, input_data, node, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_float_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of floats')
            return input_data
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_double_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of doubles')
            return input_data
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return input_data
        def gds_validate_datetime(self, input_data, node, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = input_data.strftime('%Y-%m-%dT%H:%M:%S')
            else:
                _svalue = input_data.strftime('%Y-%m-%dT%H:%M:%S.%f')
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_parse_datetime(self, input_data, node, input_name=''):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'GMT')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime.strptime(
                        input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime.strptime(
                        input_data, '%Y-%m-%dT%H:%M:%S')
            return dt.replace(tzinfo = tz)

        def gds_validate_date(self, input_data, node, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = input_data.strftime('%Y-%m-%d')
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_parse_date(self, input_data, node, input_name=''):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'GMT')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            return datetime.strptime(input_data,
                '%Y-%m-%d').replace(tzinfo = tz)
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')

#
# Support/utility functions.
#

def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')

def quote_xml(inStr):
    if not inStr:
        return ''
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1

def quote_attrib(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1

def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1

def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text

def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass

def raise_parse_error(node, msg):
    if XMLParser_import_library == XMLParser_import_lxml:
        msg = '%s (element %s/line %d)' % (
            msg, node.tag, node.sourceline, )
    else:
        msg = '%s (element %s)' % (msg, node.tag, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace, pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace, name, pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' %
                (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' %
                (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' %
                (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' %
                (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' %
                (self.name, base64.b64encode(self.value), self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n'
                % (self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n'
                % (self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s",\n' % \
                (self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container

def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#

class DefinitionsType(GeneratedsSuper):
    """The DefinitionsType complex type is a container for one or more
    definition elements. Each definition element describes a single
    OVAL Definition. Please refer to the description of the
    DefinitionType for more information about an individual
    definition."""
    subclass = None
    superclass = None
    def __init__(self, definition=None):
        if definition is None:
            self.definition = []
        else:
            self.definition = definition
    def factory(*args_, **kwargs_):
        if DefinitionsType.subclass:
            return DefinitionsType.subclass(*args_, **kwargs_)
        else:
            return DefinitionsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_definition(self): return self.definition
    def set_definition(self, definition): self.definition = definition
    def add_definition(self, value): self.definition.append(value)
    def insert_definition(self, index, value): self.definition[index] = value
    def hasContent_(self):
        if (
            self.definition
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='oval-def:', name_='DefinitionsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DefinitionsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='oval-def:', name_='DefinitionsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='oval-def:', name_='DefinitionsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for definition_ in self.definition:
            definition_.export(outfile, level, '', name_='definition', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='DefinitionsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('definition=[\n')
        level += 1
        for definition_ in self.definition:
            outfile.write('model_.definition(\n')
            definition_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'definition':
            obj_ = DefinitionType.factory()
            obj_.build(child_)
            self.definition.append(obj_)
# end class DefinitionsType

class DefinitionType(GeneratedsSuper):
    """The DefinitionType defines a single OVAL Definition. A definition is
    the key structure in OVAL. It is analogous to the logical
    sentence or proposition: if a computer's state matches the
    configuration parameters laid out in the criteria, then that
    computer exhibits the state described. The DefinitionType
    contains a section for various metadata related elements that
    describe the definition. This includes a description, version,
    affected system types, and reference information. The notes
    section of a definition should be used to hold information that
    might be helpful to someone examining the technical aspects of
    the definition. For example, why certain tests have been
    included in the criteria, or maybe a link to where further
    information can be found. The DefinitionType also (unless the
    definition is deprecated) contains a criteria child element that
    joins individual tests together with a logical operator to
    specify the specific computer state being described.The required
    id attribute is the OVAL-ID of the Definition. The form of an
    OVAL-ID must follow the specific format described by the
    oval:DefinitionIDPattern. The required version attribute holds
    the current version of the definition. Versions are integers,
    starting at 1 and incrementing every time a definition is
    modified. The required class attribute indicates the specific
    class to which the definition belongs. The class gives a hint to
    a user so they can know what the definition writer is trying to
    say. See the definition of oval-def:ClassEnumeration for more
    information about the different valid classes. The optional
    deprecated attribute signifies that an id is no longer to be
    used or referenced but the information has been kept around for
    historic purposes.When the deprecated attribute is set to true,
    the definition is considered to be deprecated. The criteria
    child element of a deprecated definition is optional. If a
    deprecated definition does not contain a criteria child element,
    the definition must evaluate to "not evaluated". If a deprecated
    definition contains a criteria child element, an interpreter
    should evaluate the definition as if it were not deprecated, but
    an interpreter may evaluate the definition to "not evaluated"."""
    subclass = None
    superclass = None
    def __init__(self, deprecated=False, version=None, id=None, classxx=None, Signature=None, metadata=None, notes=None, criteria=None):
        self.deprecated = _cast(bool, deprecated)
        self.version = _cast(int, version)
        self.id = _cast(None, id)
        self.classxx = _cast(None, classxx)
        self.Signature = Signature
        self.metadata = metadata
        self.notes = notes
        self.criteria = criteria
    def factory(*args_, **kwargs_):
        if DefinitionType.subclass:
            return DefinitionType.subclass(*args_, **kwargs_)
        else:
            return DefinitionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Signature(self): return self.Signature
    def set_Signature(self, Signature): self.Signature = Signature
    def get_metadata(self): return self.metadata
    def set_metadata(self, metadata): self.metadata = metadata
    def get_notes(self): return self.notes
    def set_notes(self, notes): self.notes = notes
    def get_criteria(self): return self.criteria
    def set_criteria(self, criteria): self.criteria = criteria
    def get_deprecated(self): return self.deprecated
    def set_deprecated(self, deprecated): self.deprecated = deprecated
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_class(self): return self.classxx
    def set_class(self, classxx): self.classxx = classxx
    def hasContent_(self):
        if (
            self.Signature is not None or
            self.metadata is not None or
            self.notes is not None or
            self.criteria is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='oval-def:', name_='DefinitionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DefinitionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='oval-def:', name_='DefinitionType'):
        if self.deprecated is not None and 'deprecated' not in already_processed:
            already_processed.add('deprecated')
            outfile.write(' deprecated="%s"' % self.gds_format_boolean(self.deprecated, input_name='deprecated'))
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version="%s"' % self.gds_format_integer(self.version, input_name='version'))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.classxx is not None and 'classxx' not in already_processed:
            already_processed.add('classxx')
            outfile.write(' class=%s' % (quote_attrib(self.classxx), ))
    def exportChildren(self, outfile, level, namespace_='oval-def:', name_='DefinitionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Signature is not None:
            self.Signature.export(outfile, level, '', name_='Signature', pretty_print=pretty_print)
        if self.metadata is not None:
            self.metadata.export(outfile, level, '', name_='metadata', pretty_print=pretty_print)
        if self.notes is not None:
            self.notes.export(outfile, level, '', name_='notes', pretty_print=pretty_print)
        if self.criteria is not None:
            self.criteria.export(outfile, level, '', name_='criteria', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='DefinitionType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.deprecated is not None and 'deprecated' not in already_processed:
            already_processed.add('deprecated')
            showIndent(outfile, level)
            outfile.write('deprecated = %s,\n' % (self.deprecated,))
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            showIndent(outfile, level)
            outfile.write('version = %d,\n' % (self.version,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id = %s,\n' % (self.id,))
        if self.classxx is not None and 'classxx' not in already_processed:
            already_processed.add('classxx')
            showIndent(outfile, level)
            outfile.write('classxx = %s,\n' % (self.classxx,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Signature is not None:
            showIndent(outfile, level)
            outfile.write('Signature=model_.Signature(\n')
            self.Signature.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.metadata is not None:
            outfile.write('metadata=model_.MetadataType(\n')
            self.metadata.exportLiteral(outfile, level, name_='metadata')
            outfile.write('),\n')
        if self.notes is not None:
            outfile.write('notes=model_.NotesType(\n')
            self.notes.exportLiteral(outfile, level, name_='notes')
            outfile.write('),\n')
        if self.criteria is not None:
            outfile.write('criteria=model_.CriteriaType(\n')
            self.criteria.exportLiteral(outfile, level, name_='criteria')
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('deprecated', node)
        if value is not None and 'deprecated' not in already_processed:
            already_processed.add('deprecated')
            if value in ('true', '1'):
                self.deprecated = True
            elif value in ('false', '0'):
                self.deprecated = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            try:
                self.version = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.version < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('class', node)
        if value is not None and 'class' not in already_processed:
            already_processed.add('class')
            self.classxx = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Signature':
            obj_ = xmldsig-core-schema.SignatureType.factory()
            obj_.build(child_)
            self.set_Signature(obj_)
        elif nodeName_ == 'metadata':
            obj_ = MetadataType.factory()
            obj_.build(child_)
            self.set_metadata(obj_)
        elif nodeName_ == 'notes':
            obj_ = NotesType.factory()
            obj_.build(child_)
            self.set_notes(obj_)
        elif nodeName_ == 'criteria':
            obj_ = CriteriaType.factory()
            obj_.build(child_)
            self.set_criteria(obj_)
# end class DefinitionType

class MetadataType(GeneratedsSuper):
    """The MetadataType complex type contains all the metadata available to
    an OVAL Definition. This metadata is for informational purposes
    only and is not part of the criteria used to evaluate machine
    state. The required title child element holds a short string
    that is used to quickly identify the definition to a human user.
    The affected metadata item contains information about the
    system(s) for which the definition has been written. Remember
    that this is just metadata and not part of the criteria. Please
    refer to the AffectedType description for more information. The
    required description element contains a textual description of
    the configuration state being addressed by the OVAL Definition.
    In the case of a definition from the vulnerability class, the
    reference is usually the Common Vulnerability and Exposures
    (CVE) Identifier, and this description field corresponds with
    the CVE description.Additional metadata is also allowed although
    it is not part of the official OVAL Schema. Individual
    organizations can place metadata items that they feel are
    important and these will be skipped during the validation. All
    OVAL really cares about is that the stated metadata items are
    there."""
    subclass = None
    superclass = None
    def __init__(self, title=None, affected=None, reference=None, description=None, anytypeobjs_=None):
        self.title = title
        if affected is None:
            self.affected = []
        else:
            self.affected = affected
        if reference is None:
            self.reference = []
        else:
            self.reference = reference
        self.description = description
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if MetadataType.subclass:
            return MetadataType.subclass(*args_, **kwargs_)
        else:
            return MetadataType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    def get_affected(self): return self.affected
    def set_affected(self, affected): self.affected = affected
    def add_affected(self, value): self.affected.append(value)
    def insert_affected(self, index, value): self.affected[index] = value
    def get_reference(self): return self.reference
    def set_reference(self, reference): self.reference = reference
    def add_reference(self, value): self.reference.append(value)
    def insert_reference(self, index, value): self.reference[index] = value
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def hasContent_(self):
        if (
            self.title is not None or
            self.affected or
            self.reference or
            self.description is not None or
            self.anytypeobjs_
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='oval-def:', name_='MetadataType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MetadataType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='oval-def:', name_='MetadataType'):
        pass
    def exportChildren(self, outfile, level, namespace_='oval-def:', name_='MetadataType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.title is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stitle>%s</%stitle>%s' % ('', self.gds_format_string(quote_xml(self.title).encode(ExternalEncoding), input_name='title'), '', eol_))
        for affected_ in self.affected:
            affected_.export(outfile, level, '', name_='affected', pretty_print=pretty_print)
        for reference_ in self.reference:
            reference_.export(outfile, level, '', name_='reference', pretty_print=pretty_print)
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % ('', self.gds_format_string(quote_xml(self.description).encode(ExternalEncoding), input_name='description'), '', eol_))
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, '', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='MetadataType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.title is not None:
            showIndent(outfile, level)
            outfile.write('title=%s,\n' % quote_python(self.title).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('affected=[\n')
        level += 1
        for affected_ in self.affected:
            outfile.write('model_.AffectedType(\n')
            affected_.exportLiteral(outfile, level, name_='AffectedType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('reference=[\n')
        level += 1
        for reference_ in self.reference:
            outfile.write('model_.xmldsig-core-schema.ReferenceType(\n')
            reference_.exportLiteral(outfile, level, name_='xmldsig-core-schema.ReferenceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=%s,\n' % quote_python(self.description).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'title':
            title_ = child_.text
            title_ = self.gds_validate_string(title_, node, 'title')
            self.title = title_
        elif nodeName_ == 'affected':
            obj_ = AffectedType.factory()
            obj_.build(child_)
            self.affected.append(obj_)
        elif nodeName_ == 'reference':
            obj_ = xmldsig-core-schema.ReferenceType.factory()
            obj_.build(child_)
            self.reference.append(obj_)
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
        else:
            obj_ = self.gds_build_any(child_, 'MetadataType')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
# end class MetadataType

class AffectedType(GeneratedsSuper):
    """Each OVAL Definition is written to evaluate a certain type of
    system(s). The family, platform(s), and product(s) of this
    target are described by the AffectedType whose main purpose is
    to provide hints for tools using OVAL Definitions. For instance,
    to help a reporting tool only use Windows definitions, or to
    preselect only Red Hat definitions to be evaluated. Note, the
    inclusion of a particular platform or product does not mean the
    definition is physically checking for the existence of the
    platform or product. For the actual test to be performed, the
    correct test must still be included in the definition's criteria
    section.The AffectedType complex type details the specific
    system, application, subsystem, library, etc. for which a
    definition has been written. If a definition is not tied to a
    specific product, then this element should not be included. The
    absence of the platform or product element can be thought of as
    definition applying to all platforms or products. The inclusion
    of a particular platform or product does not mean the definition
    is physically checking for the existence of the platform or
    product. For the actual test to be performed, the correct test
    must still be included in the definition's criteria section. To
    increase the utility of this element, care should be taken when
    assigning and using strings for product names. The schema places
    no restrictions on the values that can be assigned, potentially
    leading to many different representations of the same value. For
    example, 'Internet Explorer' and 'IE' might be used to refer to
    the same product. The current convention is to fully spell out
    all terms, and avoid the use of abbreviations at all
    costs.Please note that the AffectedType will change in future
    versions of OVAL in order to support the Common Platform
    Enumeration (CPE)."""
    subclass = None
    superclass = None
    def __init__(self, family=None, platform=None, product=None):
        self.family = _cast(None, family)
        if platform is None:
            self.platform = []
        else:
            self.platform = platform
        if product is None:
            self.product = []
        else:
            self.product = product
    def factory(*args_, **kwargs_):
        if AffectedType.subclass:
            return AffectedType.subclass(*args_, **kwargs_)
        else:
            return AffectedType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_platform(self): return self.platform
    def set_platform(self, platform): self.platform = platform
    def add_platform(self, value): self.platform.append(value)
    def insert_platform(self, index, value): self.platform[index] = value
    def get_product(self): return self.product
    def set_product(self, product): self.product = product
    def add_product(self, value): self.product.append(value)
    def insert_product(self, index, value): self.product[index] = value
    def get_family(self): return self.family
    def set_family(self, family): self.family = family
    def hasContent_(self):
        if (
            self.platform or
            self.product
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='oval-def:', name_='AffectedType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AffectedType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='oval-def:', name_='AffectedType'):
        if self.family is not None and 'family' not in already_processed:
            already_processed.add('family')
            outfile.write(' family=%s' % (quote_attrib(self.family), ))
    def exportChildren(self, outfile, level, namespace_='oval-def:', name_='AffectedType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for platform_ in self.platform:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%splatform>%s</%splatform>%s' % ('', self.gds_format_string(quote_xml(platform_).encode(ExternalEncoding), input_name='platform'), '', eol_))
        for product_ in self.product:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sproduct>%s</%sproduct>%s' % ('', self.gds_format_string(quote_xml(product_).encode(ExternalEncoding), input_name='product'), '', eol_))
    def exportLiteral(self, outfile, level, name_='AffectedType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.family is not None and 'family' not in already_processed:
            already_processed.add('family')
            showIndent(outfile, level)
            outfile.write('family = %s,\n' % (self.family,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('platform=[\n')
        level += 1
        for platform_ in self.platform:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(platform_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('product=[\n')
        level += 1
        for product_ in self.product:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(product_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('family', node)
        if value is not None and 'family' not in already_processed:
            already_processed.add('family')
            self.family = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'platform':
            platform_ = child_.text
            platform_ = self.gds_validate_string(platform_, node, 'platform')
            self.platform.append(platform_)
        elif nodeName_ == 'product':
            product_ = child_.text
            product_ = self.gds_validate_string(product_, node, 'product')
            self.product.append(product_)
# end class AffectedType

class xmldsig-core-schema.ReferenceType(GeneratedsSuper):
    """The xmldsig-core-schema.ReferenceType complex type links the OVAL Definition to a
    definitive external reference. For example, CVE Identifiers are
    used for referencing vulnerabilities. The intended purpose for
    this reference is to link the definition to a variety of other
    sources that address the same issue being specified by the OVAL
    Definition.The required source attribute specifies where the
    reference is coming from. In other words, it identifies the
    reference repository being used. The required ref_id attribute
    is the external id of the reference. The optional ref_url
    attribute is the URL to the reference."""
    subclass = None
    superclass = None
    def __init__(self, source=None, ref_url=None, ref_id=None):
        self.source = _cast(None, source)
        self.ref_url = _cast(None, ref_url)
        self.ref_id = _cast(None, ref_id)
        pass
    def factory(*args_, **kwargs_):
        if xmldsig-core-schema.ReferenceType.subclass:
            return xmldsig-core-schema.ReferenceType.subclass(*args_, **kwargs_)
        else:
            return xmldsig-core-schema.ReferenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_source(self): return self.source
    def set_source(self, source): self.source = source
    def get_ref_url(self): return self.ref_url
    def set_ref_url(self, ref_url): self.ref_url = ref_url
    def get_ref_id(self): return self.ref_id
    def set_ref_id(self, ref_id): self.ref_id = ref_id
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='oval-def:', name_='xmldsig-core-schema.ReferenceType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='xmldsig-core-schema.ReferenceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='oval-def:', name_='xmldsig-core-schema.ReferenceType'):
        if self.source is not None and 'source' not in already_processed:
            already_processed.add('source')
            outfile.write(' source=%s' % (self.gds_format_string(quote_attrib(self.source).encode(ExternalEncoding), input_name='source'), ))
        if self.ref_url is not None and 'ref_url' not in already_processed:
            already_processed.add('ref_url')
            outfile.write(' ref_url=%s' % (self.gds_format_string(quote_attrib(self.ref_url).encode(ExternalEncoding), input_name='ref_url'), ))
        if self.ref_id is not None and 'ref_id' not in already_processed:
            already_processed.add('ref_id')
            outfile.write(' ref_id=%s' % (self.gds_format_string(quote_attrib(self.ref_id).encode(ExternalEncoding), input_name='ref_id'), ))
    def exportChildren(self, outfile, level, namespace_='oval-def:', name_='xmldsig-core-schema.ReferenceType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='xmldsig-core-schema.ReferenceType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.source is not None and 'source' not in already_processed:
            already_processed.add('source')
            showIndent(outfile, level)
            outfile.write('source = "%s",\n' % (self.source,))
        if self.ref_url is not None and 'ref_url' not in already_processed:
            already_processed.add('ref_url')
            showIndent(outfile, level)
            outfile.write('ref_url = "%s",\n' % (self.ref_url,))
        if self.ref_id is not None and 'ref_id' not in already_processed:
            already_processed.add('ref_id')
            showIndent(outfile, level)
            outfile.write('ref_id = "%s",\n' % (self.ref_id,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('source', node)
        if value is not None and 'source' not in already_processed:
            already_processed.add('source')
            self.source = value
        value = find_attr_value_('ref_url', node)
        if value is not None and 'ref_url' not in already_processed:
            already_processed.add('ref_url')
            self.ref_url = value
        value = find_attr_value_('ref_id', node)
        if value is not None and 'ref_id' not in already_processed:
            already_processed.add('ref_id')
            self.ref_id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class xmldsig-core-schema.ReferenceType

class NotesType(GeneratedsSuper):
    """The NotesType complex type is a container for one or more note child
    elements. Each note contains some information about the
    definition or tests that it references. A note may record an
    unresolved question about the definition or test or present the
    reason as to why a particular approach was taken."""
    subclass = None
    superclass = None
    def __init__(self, note=None):
        if note is None:
            self.note = []
        else:
            self.note = note
    def factory(*args_, **kwargs_):
        if NotesType.subclass:
            return NotesType.subclass(*args_, **kwargs_)
        else:
            return NotesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_note(self): return self.note
    def set_note(self, note): self.note = note
    def add_note(self, value): self.note.append(value)
    def insert_note(self, index, value): self.note[index] = value
    def hasContent_(self):
        if (
            self.note
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='oval-def:', name_='NotesType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NotesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='oval-def:', name_='NotesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='oval-def:', name_='NotesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for note_ in self.note:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snote>%s</%snote>%s' % ('', self.gds_format_string(quote_xml(note_).encode(ExternalEncoding), input_name='note'), '', eol_))
    def exportLiteral(self, outfile, level, name_='NotesType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('note=[\n')
        level += 1
        for note_ in self.note:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(note_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'note':
            note_ = child_.text
            note_ = self.gds_validate_string(note_, node, 'note')
            self.note.append(note_)
# end class NotesType

class CriteriaType(GeneratedsSuper):
    """The CriteriaType complex type describes a container for a set of sub
    criteria, criteria, criterion, or extend_definition elements
    allowing complex logical trees to be constructed. Each
    referenced test is represented by a criterion element. Please
    refer to the description of the CriterionType for more
    information about and individual criterion element. The optional
    extend_definition element allows existing definitions to be
    included in the criteria. Refer to the description of the
    ExtendDefinitionType for more information.The required operator
    attribute provides the logical operator that binds the different
    statements inside a criteria together. The optional negate
    attribute signifies that the result of the criteria as a whole
    should be negated during analysis. For example, consider a
    criteria that evaluates to TRUE if certain software is
    installed. By negating this test, it now evaluates to TRUE if
    the software is NOT installed. The optional comment attribute
    provides a short description of the criteria.The optional
    applicability_check attribute provides a Boolean flag that when
    true indicates that the criteria is being used to determine
    whether the OVAL Definition applies to a given system."""
    subclass = None
    superclass = None
    def __init__(self, operator='AND', negate=False, applicability_check=None, comment=None, criteria=None, criterion=None, extend_definition=None):
        self.operator = _cast(None, operator)
        self.negate = _cast(bool, negate)
        self.applicability_check = _cast(bool, applicability_check)
        self.comment = _cast(None, comment)
        if criteria is None:
            self.criteria = []
        else:
            self.criteria = criteria
        if criterion is None:
            self.criterion = []
        else:
            self.criterion = criterion
        if extend_definition is None:
            self.extend_definition = []
        else:
            self.extend_definition = extend_definition
    def factory(*args_, **kwargs_):
        if CriteriaType.subclass:
            return CriteriaType.subclass(*args_, **kwargs_)
        else:
            return CriteriaType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_criteria(self): return self.criteria
    def set_criteria(self, criteria): self.criteria = criteria
    def add_criteria(self, value): self.criteria.append(value)
    def insert_criteria(self, index, value): self.criteria[index] = value
    def get_criterion(self): return self.criterion
    def set_criterion(self, criterion): self.criterion = criterion
    def add_criterion(self, value): self.criterion.append(value)
    def insert_criterion(self, index, value): self.criterion[index] = value
    def get_extend_definition(self): return self.extend_definition
    def set_extend_definition(self, extend_definition): self.extend_definition = extend_definition
    def add_extend_definition(self, value): self.extend_definition.append(value)
    def insert_extend_definition(self, index, value): self.extend_definition[index] = value
    def get_operator(self): return self.operator
    def set_operator(self, operator): self.operator = operator
    def get_negate(self): return self.negate
    def set_negate(self, negate): self.negate = negate
    def get_applicability_check(self): return self.applicability_check
    def set_applicability_check(self, applicability_check): self.applicability_check = applicability_check
    def get_comment(self): return self.comment
    def set_comment(self, comment): self.comment = comment
    def hasContent_(self):
        if (
            self.criteria or
            self.criterion or
            self.extend_definition
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='oval-def:', name_='CriteriaType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CriteriaType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='oval-def:', name_='CriteriaType'):
        if self.operator is not None and 'operator' not in already_processed:
            already_processed.add('operator')
            outfile.write(' operator=%s' % (quote_attrib(self.operator), ))
        if self.negate is not None and 'negate' not in already_processed:
            already_processed.add('negate')
            outfile.write(' negate="%s"' % self.gds_format_boolean(self.negate, input_name='negate'))
        if self.applicability_check is not None and 'applicability_check' not in already_processed:
            already_processed.add('applicability_check')
            outfile.write(' applicability_check="%s"' % self.gds_format_boolean(self.applicability_check, input_name='applicability_check'))
        if self.comment is not None and 'comment' not in already_processed:
            already_processed.add('comment')
            outfile.write(' comment=%s' % (quote_attrib(self.comment), ))
    def exportChildren(self, outfile, level, namespace_='oval-def:', name_='CriteriaType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for criteria_ in self.criteria:
            criteria_.export(outfile, level, '', name_='criteria', pretty_print=pretty_print)
        for criterion_ in self.criterion:
            criterion_.export(outfile, level, '', name_='criterion', pretty_print=pretty_print)
        for extend_definition_ in self.extend_definition:
            extend_definition_.export(outfile, level, '', name_='extend_definition', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='CriteriaType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.operator is not None and 'operator' not in already_processed:
            already_processed.add('operator')
            showIndent(outfile, level)
            outfile.write('operator = %s,\n' % (self.operator,))
        if self.negate is not None and 'negate' not in already_processed:
            already_processed.add('negate')
            showIndent(outfile, level)
            outfile.write('negate = %s,\n' % (self.negate,))
        if self.applicability_check is not None and 'applicability_check' not in already_processed:
            already_processed.add('applicability_check')
            showIndent(outfile, level)
            outfile.write('applicability_check = %s,\n' % (self.applicability_check,))
        if self.comment is not None and 'comment' not in already_processed:
            already_processed.add('comment')
            showIndent(outfile, level)
            outfile.write('comment = %s,\n' % (self.comment,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('criteria=[\n')
        level += 1
        for criteria_ in self.criteria:
            outfile.write('model_.CriteriaType(\n')
            criteria_.exportLiteral(outfile, level, name_='CriteriaType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('criterion=[\n')
        level += 1
        for criterion_ in self.criterion:
            outfile.write('model_.CriterionType(\n')
            criterion_.exportLiteral(outfile, level, name_='CriterionType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('extend_definition=[\n')
        level += 1
        for extend_definition_ in self.extend_definition:
            outfile.write('model_.ExtendDefinitionType(\n')
            extend_definition_.exportLiteral(outfile, level, name_='ExtendDefinitionType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('operator', node)
        if value is not None and 'operator' not in already_processed:
            already_processed.add('operator')
            self.operator = value
        value = find_attr_value_('negate', node)
        if value is not None and 'negate' not in already_processed:
            already_processed.add('negate')
            if value in ('true', '1'):
                self.negate = True
            elif value in ('false', '0'):
                self.negate = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('applicability_check', node)
        if value is not None and 'applicability_check' not in already_processed:
            already_processed.add('applicability_check')
            if value in ('true', '1'):
                self.applicability_check = True
            elif value in ('false', '0'):
                self.applicability_check = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('comment', node)
        if value is not None and 'comment' not in already_processed:
            already_processed.add('comment')
            self.comment = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'criteria':
            obj_ = CriteriaType.factory()
            obj_.build(child_)
            self.criteria.append(obj_)
        elif nodeName_ == 'criterion':
            obj_ = CriterionType.factory()
            obj_.build(child_)
            self.criterion.append(obj_)
        elif nodeName_ == 'extend_definition':
            obj_ = ExtendDefinitionType.factory()
            obj_.build(child_)
            self.extend_definition.append(obj_)
# end class CriteriaType

class CriterionType(GeneratedsSuper):
    """The CriterionType complex type identifies a specific test to be
    included in the definition's criteria.The required test_ref
    attribute is the actual id of the test being referenced. The
    optional negate attribute signifies that the result of an
    individual test should be negated during analysis. For example,
    consider a test that evaluates to TRUE if a specific patch is
    installed. By negating this test, it now evaluates to TRUE if
    the patch is NOT installed. The optional comment attribute
    provides a short description of the specified test and should
    mirror the comment attribute of the actual test.The optional
    applicability_check attribute provides a Boolean flag that when
    true indicates that the criterion is being used to determine
    whether the OVAL Definition applies to a given system."""
    subclass = None
    superclass = None
    def __init__(self, negate=False, comment=None, test_ref=None, applicability_check=None):
        self.negate = _cast(bool, negate)
        self.comment = _cast(None, comment)
        self.test_ref = _cast(None, test_ref)
        self.applicability_check = _cast(bool, applicability_check)
        pass
    def factory(*args_, **kwargs_):
        if CriterionType.subclass:
            return CriterionType.subclass(*args_, **kwargs_)
        else:
            return CriterionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_negate(self): return self.negate
    def set_negate(self, negate): self.negate = negate
    def get_comment(self): return self.comment
    def set_comment(self, comment): self.comment = comment
    def get_test_ref(self): return self.test_ref
    def set_test_ref(self, test_ref): self.test_ref = test_ref
    def get_applicability_check(self): return self.applicability_check
    def set_applicability_check(self, applicability_check): self.applicability_check = applicability_check
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='oval-def:', name_='CriterionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CriterionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='oval-def:', name_='CriterionType'):
        if self.negate is not None and 'negate' not in already_processed:
            already_processed.add('negate')
            outfile.write(' negate="%s"' % self.gds_format_boolean(self.negate, input_name='negate'))
        if self.comment is not None and 'comment' not in already_processed:
            already_processed.add('comment')
            outfile.write(' comment=%s' % (quote_attrib(self.comment), ))
        if self.test_ref is not None and 'test_ref' not in already_processed:
            already_processed.add('test_ref')
            outfile.write(' test_ref=%s' % (quote_attrib(self.test_ref), ))
        if self.applicability_check is not None and 'applicability_check' not in already_processed:
            already_processed.add('applicability_check')
            outfile.write(' applicability_check="%s"' % self.gds_format_boolean(self.applicability_check, input_name='applicability_check'))
    def exportChildren(self, outfile, level, namespace_='oval-def:', name_='CriterionType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='CriterionType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.negate is not None and 'negate' not in already_processed:
            already_processed.add('negate')
            showIndent(outfile, level)
            outfile.write('negate = %s,\n' % (self.negate,))
        if self.comment is not None and 'comment' not in already_processed:
            already_processed.add('comment')
            showIndent(outfile, level)
            outfile.write('comment = %s,\n' % (self.comment,))
        if self.test_ref is not None and 'test_ref' not in already_processed:
            already_processed.add('test_ref')
            showIndent(outfile, level)
            outfile.write('test_ref = %s,\n' % (self.test_ref,))
        if self.applicability_check is not None and 'applicability_check' not in already_processed:
            already_processed.add('applicability_check')
            showIndent(outfile, level)
            outfile.write('applicability_check = %s,\n' % (self.applicability_check,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('negate', node)
        if value is not None and 'negate' not in already_processed:
            already_processed.add('negate')
            if value in ('true', '1'):
                self.negate = True
            elif value in ('false', '0'):
                self.negate = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('comment', node)
        if value is not None and 'comment' not in already_processed:
            already_processed.add('comment')
            self.comment = value
        value = find_attr_value_('test_ref', node)
        if value is not None and 'test_ref' not in already_processed:
            already_processed.add('test_ref')
            self.test_ref = value
        value = find_attr_value_('applicability_check', node)
        if value is not None and 'applicability_check' not in already_processed:
            already_processed.add('applicability_check')
            if value in ('true', '1'):
                self.applicability_check = True
            elif value in ('false', '0'):
                self.applicability_check = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CriterionType

class ExtendDefinitionType(GeneratedsSuper):
    """The ExtendDefinitionType complex type allows existing definitions to
    be extended by another definition. This works by evaluating the
    extended definition and then using the result within the logical
    context of the extending definition.The required definition_ref
    attribute is the actual id of the definition being extended. The
    optional negate attribute signifies that the result of an
    extended definition should be negated during analysis. For
    example, consider a definition that evaluates TRUE if
    certainsoftware is installed. By negating the definition, it now
    evaluates to TRUE if the software is NOT installed. The optional
    comment attribute provides a short description of the specified
    definition and should mirror the title metadata of the extended
    definition.The optional applicability_check attribute provides a
    Boolean flag that when true indicates that the extend_definition
    is being used to determine whether the OVAL Definition applies
    to a given system."""
    subclass = None
    superclass = None
    def __init__(self, negate=False, comment=None, applicability_check=None, definition_ref=None):
        self.negate = _cast(bool, negate)
        self.comment = _cast(None, comment)
        self.applicability_check = _cast(bool, applicability_check)
        self.definition_ref = _cast(None, definition_ref)
        pass
    def factory(*args_, **kwargs_):
        if ExtendDefinitionType.subclass:
            return ExtendDefinitionType.subclass(*args_, **kwargs_)
        else:
            return ExtendDefinitionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_negate(self): return self.negate
    def set_negate(self, negate): self.negate = negate
    def get_comment(self): return self.comment
    def set_comment(self, comment): self.comment = comment
    def get_applicability_check(self): return self.applicability_check
    def set_applicability_check(self, applicability_check): self.applicability_check = applicability_check
    def get_definition_ref(self): return self.definition_ref
    def set_definition_ref(self, definition_ref): self.definition_ref = definition_ref
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='oval-def:', name_='ExtendDefinitionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ExtendDefinitionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='oval-def:', name_='ExtendDefinitionType'):
        if self.negate is not None and 'negate' not in already_processed:
            already_processed.add('negate')
            outfile.write(' negate="%s"' % self.gds_format_boolean(self.negate, input_name='negate'))
        if self.comment is not None and 'comment' not in already_processed:
            already_processed.add('comment')
            outfile.write(' comment=%s' % (quote_attrib(self.comment), ))
        if self.applicability_check is not None and 'applicability_check' not in already_processed:
            already_processed.add('applicability_check')
            outfile.write(' applicability_check="%s"' % self.gds_format_boolean(self.applicability_check, input_name='applicability_check'))
        if self.definition_ref is not None and 'definition_ref' not in already_processed:
            already_processed.add('definition_ref')
            outfile.write(' definition_ref=%s' % (quote_attrib(self.definition_ref), ))
    def exportChildren(self, outfile, level, namespace_='oval-def:', name_='ExtendDefinitionType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='ExtendDefinitionType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.negate is not None and 'negate' not in already_processed:
            already_processed.add('negate')
            showIndent(outfile, level)
            outfile.write('negate = %s,\n' % (self.negate,))
        if self.comment is not None and 'comment' not in already_processed:
            already_processed.add('comment')
            showIndent(outfile, level)
            outfile.write('comment = %s,\n' % (self.comment,))
        if self.applicability_check is not None and 'applicability_check' not in already_processed:
            already_processed.add('applicability_check')
            showIndent(outfile, level)
            outfile.write('applicability_check = %s,\n' % (self.applicability_check,))
        if self.definition_ref is not None and 'definition_ref' not in already_processed:
            already_processed.add('definition_ref')
            showIndent(outfile, level)
            outfile.write('definition_ref = %s,\n' % (self.definition_ref,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('negate', node)
        if value is not None and 'negate' not in already_processed:
            already_processed.add('negate')
            if value in ('true', '1'):
                self.negate = True
            elif value in ('false', '0'):
                self.negate = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('comment', node)
        if value is not None and 'comment' not in already_processed:
            already_processed.add('comment')
            self.comment = value
        value = find_attr_value_('applicability_check', node)
        if value is not None and 'applicability_check' not in already_processed:
            already_processed.add('applicability_check')
            if value in ('true', '1'):
                self.applicability_check = True
            elif value in ('false', '0'):
                self.applicability_check = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('definition_ref', node)
        if value is not None and 'definition_ref' not in already_processed:
            already_processed.add('definition_ref')
            self.definition_ref = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ExtendDefinitionType

class TestsType(GeneratedsSuper):
    """The TestsType complex type is a container for one or more test child
    elements. Each test element describes a single OVAL Test. Please
    refer to the description of the TestType for more information
    about an individual test."""
    subclass = None
    superclass = None
    def __init__(self, test=None):
        if test is None:
            self.test = []
        else:
            self.test = test
    def factory(*args_, **kwargs_):
        if TestsType.subclass:
            return TestsType.subclass(*args_, **kwargs_)
        else:
            return TestsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_test(self): return self.test
    def set_test(self, test): self.test = test
    def add_test(self, value): self.test.append(value)
    def insert_test(self, index, value): self.test[index] = value
    def hasContent_(self):
        if (
            self.test
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='oval-def:', name_='TestsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TestsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='oval-def:', name_='TestsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='oval-def:', name_='TestsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for test_ in self.get_test():
            test_.export(outfile, level, '', name_='test', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='TestsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('test=[\n')
        level += 1
        for test_ in self.test:
            outfile.write('model_.test(\n')
            test_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'test':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <test> element')
            self.test.append(obj_)
# end class TestsType

class TestType(GeneratedsSuper):
    """The base type of every test includes an optional notes element and
    several attributes. The notes section of a test should be used
    to hold information that might be helpful to someone examining
    the technical aspects of the test. For example, why certain
    values have been used by the test, or maybe a link to where
    further information can be found. Please refer to the
    description of the NotesType complex type for more information
    about the notes element. The required comment attribute provides
    a short description of the test. The optional deprecated
    attribute signifies that an id is no longer to be used or
    referenced but the information has been kept around for historic
    purposes.The required id attribute uniquely identifies each
    test, and must conform to the format specified by the
    TestIdPattern simple type. The required version attribute holds
    the current version of the test. Versions are integers, starting
    at 1 and incrementing every time a test is modified.The optional
    check_existence attribute specifies how many items in the set
    defined by the OVAL Object must exist for the test to evaluate
    to true. The default value for this attribute is
    'at_least_one_exists' indicating that by default the test may
    evaluate to true if at least one item defined by the OVAL Object
    exists on the system. For example, if a value of 'all_exist' is
    given, every item defined by the OVAL Object must exist on the
    system for the test to evaluate to true. If the OVAL Object uses
    a variable reference, then every value of that variable must
    exist. Note that a pattern match defines a unique set of
    matching items found on a system. So when check_existence =
    'all_exist' and a regex matches anything on a system the test
    will evaluate to true (since all matching objects on the system
    were found on the system). When check_existence = 'all_exist'
    and a regex does not match anything on a system the test will
    evaluate to false.The required check attribute specifies how
    many items in the set defined by the OVAL Object (ignoring items
    with a status of Does Not Exist) must satisfy the state
    requirements. For example, should the test check that all
    matching files have a specified version or that at least one
    file has the specified version? The valid check values are
    explained in the description of the CheckEnumeration simple
    type. Note that if the test does not contain any references to
    OVAL States, then the check attribute has no meaning and can be
    ignored during evaluation.An OVAL Test evaluates to true if both
    the check_existence and check attributes are satisfied during
    evaluation. The evaluation result for a test is determined by
    first evaluating the check_existence attribute. If the result of
    evaluating the check_existence attribute is true then the check
    attribute is evaluated. An interpreter may choose to always
    evaluate both the check_existence and the check attributes, but
    once the check_existence attribute evaluation has resulted in
    false the overall test result after evaluating the check
    attribute will not be affected.The optional state_operator
    attribute provides the logical operator that combines the
    evaluation results from each referenced state on a per item
    basis. Each matching item is compared to each referenced state.
    The result of comparing each state to a single item is combined
    based on the specified state_operator value to determine one
    result for each item. Finally, the results for each item are
    combined based on the specified check value. Note that if the
    test does not contain any references to OVAL States, then the
    state_operator attribute has no meaning and can be ignored
    during evaluation. Referencing multiple states in one test
    allows ranges of possible values to be expressed. For example,
    one state can check that a value greater than 8 is found and
    another state can check that a value of less than 16 is found.
    In this example the referenced states are combined with a
    state_operator = 'AND' indicating that the conditions of all
    referenced states must be satisfied and that the value must be
    between 8 AND 16. The valid state_operation values are explained
    in the description of the OperatorEnumeration simple type."""
    subclass = None
    superclass = None
    def __init__(self, comment=None, state_operator='AND', deprecated=False, check=None, version=None, id=None, check_existence='at_least_one_exists', Signature=None, notes=None):
        self.comment = _cast(None, comment)
        self.state_operator = _cast(None, state_operator)
        self.deprecated = _cast(bool, deprecated)
        self.check = _cast(None, check)
        self.version = _cast(int, version)
        self.id = _cast(None, id)
        self.check_existence = _cast(None, check_existence)
        self.Signature = Signature
        self.notes = notes
    def factory(*args_, **kwargs_):
        if TestType.subclass:
            return TestType.subclass(*args_, **kwargs_)
        else:
            return TestType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Signature(self): return self.Signature
    def set_Signature(self, Signature): self.Signature = Signature
    def get_notes(self): return self.notes
    def set_notes(self, notes): self.notes = notes
    def get_comment(self): return self.comment
    def set_comment(self, comment): self.comment = comment
    def get_state_operator(self): return self.state_operator
    def set_state_operator(self, state_operator): self.state_operator = state_operator
    def get_deprecated(self): return self.deprecated
    def set_deprecated(self, deprecated): self.deprecated = deprecated
    def get_check(self): return self.check
    def set_check(self, check): self.check = check
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_check_existence(self): return self.check_existence
    def set_check_existence(self, check_existence): self.check_existence = check_existence
    def hasContent_(self):
        if (
            self.Signature is not None or
            self.notes is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='oval-def:', name_='TestType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TestType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='oval-def:', name_='TestType'):
        if self.comment is not None and 'comment' not in already_processed:
            already_processed.add('comment')
            outfile.write(' comment=%s' % (quote_attrib(self.comment), ))
        if self.state_operator is not None and 'state_operator' not in already_processed:
            already_processed.add('state_operator')
            outfile.write(' state_operator=%s' % (quote_attrib(self.state_operator), ))
        if self.deprecated is not None and 'deprecated' not in already_processed:
            already_processed.add('deprecated')
            outfile.write(' deprecated="%s"' % self.gds_format_boolean(self.deprecated, input_name='deprecated'))
        if self.check is not None and 'check' not in already_processed:
            already_processed.add('check')
            outfile.write(' check=%s' % (quote_attrib(self.check), ))
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version="%s"' % self.gds_format_integer(self.version, input_name='version'))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.check_existence is not None and 'check_existence' not in already_processed:
            already_processed.add('check_existence')
            outfile.write(' check_existence=%s' % (quote_attrib(self.check_existence), ))
    def exportChildren(self, outfile, level, namespace_='oval-def:', name_='TestType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Signature is not None:
            self.Signature.export(outfile, level, '', name_='Signature', pretty_print=pretty_print)
        if self.notes is not None:
            self.notes.export(outfile, level, '', name_='notes', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='TestType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.comment is not None and 'comment' not in already_processed:
            already_processed.add('comment')
            showIndent(outfile, level)
            outfile.write('comment = %s,\n' % (self.comment,))
        if self.state_operator is not None and 'state_operator' not in already_processed:
            already_processed.add('state_operator')
            showIndent(outfile, level)
            outfile.write('state_operator = %s,\n' % (self.state_operator,))
        if self.deprecated is not None and 'deprecated' not in already_processed:
            already_processed.add('deprecated')
            showIndent(outfile, level)
            outfile.write('deprecated = %s,\n' % (self.deprecated,))
        if self.check is not None and 'check' not in already_processed:
            already_processed.add('check')
            showIndent(outfile, level)
            outfile.write('check = %s,\n' % (self.check,))
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            showIndent(outfile, level)
            outfile.write('version = %d,\n' % (self.version,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id = %s,\n' % (self.id,))
        if self.check_existence is not None and 'check_existence' not in already_processed:
            already_processed.add('check_existence')
            showIndent(outfile, level)
            outfile.write('check_existence = %s,\n' % (self.check_existence,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Signature is not None:
            showIndent(outfile, level)
            outfile.write('Signature=model_.Signature(\n')
            self.Signature.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.notes is not None:
            outfile.write('notes=model_.NotesType(\n')
            self.notes.exportLiteral(outfile, level, name_='notes')
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('comment', node)
        if value is not None and 'comment' not in already_processed:
            already_processed.add('comment')
            self.comment = value
        value = find_attr_value_('state_operator', node)
        if value is not None and 'state_operator' not in already_processed:
            already_processed.add('state_operator')
            self.state_operator = value
        value = find_attr_value_('deprecated', node)
        if value is not None and 'deprecated' not in already_processed:
            already_processed.add('deprecated')
            if value in ('true', '1'):
                self.deprecated = True
            elif value in ('false', '0'):
                self.deprecated = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('check', node)
        if value is not None and 'check' not in already_processed:
            already_processed.add('check')
            self.check = value
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            try:
                self.version = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.version < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('check_existence', node)
        if value is not None and 'check_existence' not in already_processed:
            already_processed.add('check_existence')
            self.check_existence = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Signature':
            obj_ = xmldsig-core-schema.SignatureType.factory()
            obj_.build(child_)
            self.set_Signature(obj_)
        elif nodeName_ == 'notes':
            obj_ = NotesType.factory()
            obj_.build(child_)
            self.set_notes(obj_)
# end class TestType

class ObjectRefType(GeneratedsSuper):
    """The ObjectRefType complex type defines an object reference to be
    used by OVAL Tests that are defined in the component schemas.
    The required object_ref attribute specifies the id of the OVAL
    Object being referenced."""
    subclass = None
    superclass = None
    def __init__(self, object_ref=None):
        self.object_ref = _cast(None, object_ref)
        pass
    def factory(*args_, **kwargs_):
        if ObjectRefType.subclass:
            return ObjectRefType.subclass(*args_, **kwargs_)
        else:
            return ObjectRefType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_object_ref(self): return self.object_ref
    def set_object_ref(self, object_ref): self.object_ref = object_ref
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='oval-def:', name_='ObjectRefType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ObjectRefType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='oval-def:', name_='ObjectRefType'):
        if self.object_ref is not None and 'object_ref' not in already_processed:
            already_processed.add('object_ref')
            outfile.write(' object_ref=%s' % (quote_attrib(self.object_ref), ))
    def exportChildren(self, outfile, level, namespace_='oval-def:', name_='ObjectRefType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='ObjectRefType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.object_ref is not None and 'object_ref' not in already_processed:
            already_processed.add('object_ref')
            showIndent(outfile, level)
            outfile.write('object_ref = %s,\n' % (self.object_ref,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('object_ref', node)
        if value is not None and 'object_ref' not in already_processed:
            already_processed.add('object_ref')
            self.object_ref = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ObjectRefType

class StateRefType(GeneratedsSuper):
    """The StateRefType complex type defines a state reference to be used
    by OVAL Tests that are defined in the component schemas. The
    required state_ref attribute specifies the id of the OVAL State
    being referenced."""
    subclass = None
    superclass = None
    def __init__(self, state_ref=None):
        self.state_ref = _cast(None, state_ref)
        pass
    def factory(*args_, **kwargs_):
        if StateRefType.subclass:
            return StateRefType.subclass(*args_, **kwargs_)
        else:
            return StateRefType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_state_ref(self): return self.state_ref
    def set_state_ref(self, state_ref): self.state_ref = state_ref
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='oval-def:', name_='StateRefType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StateRefType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='oval-def:', name_='StateRefType'):
        if self.state_ref is not None and 'state_ref' not in already_processed:
            already_processed.add('state_ref')
            outfile.write(' state_ref=%s' % (quote_attrib(self.state_ref), ))
    def exportChildren(self, outfile, level, namespace_='oval-def:', name_='StateRefType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='StateRefType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.state_ref is not None and 'state_ref' not in already_processed:
            already_processed.add('state_ref')
            showIndent(outfile, level)
            outfile.write('state_ref = %s,\n' % (self.state_ref,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('state_ref', node)
        if value is not None and 'state_ref' not in already_processed:
            already_processed.add('state_ref')
            self.state_ref = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class StateRefType

class ObjectsType(GeneratedsSuper):
    """The ObjectsType complex type is a container for one or more object
    child elements. Each object element provides details that define
    a unique set of matching items to be used by an OVAL Test.
    Please refer to the description of the object element for more
    information about an individual object."""
    subclass = None
    superclass = None
    def __init__(self, object=None):
        if object is None:
            self.object = []
        else:
            self.object = object
    def factory(*args_, **kwargs_):
        if ObjectsType.subclass:
            return ObjectsType.subclass(*args_, **kwargs_)
        else:
            return ObjectsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_object(self): return self.object
    def set_object(self, object): self.object = object
    def add_object(self, value): self.object.append(value)
    def insert_object(self, index, value): self.object[index] = value
    def hasContent_(self):
        if (
            self.object
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='oval-def:', name_='ObjectsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ObjectsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='oval-def:', name_='ObjectsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='oval-def:', name_='ObjectsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for object_ in self.get_object():
            object_.export(outfile, level, '', name_='object', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ObjectsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('object=[\n')
        level += 1
        for object_ in self.object:
            outfile.write('model_.object(\n')
            object_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'object':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <object> element')
            self.object.append(obj_)
# end class ObjectsType

class xmldsig-core-schema.ObjectType(GeneratedsSuper):
    """The base type of every object includes an optional notes element.
    The notes element of an object should be used to hold
    information that might be helpful to someone examining the
    technical aspects of the object. For example, why certain values
    have been used, or maybe a link to where further information can
    be found. Please refer to the description of the NotesType
    complex type for more information about the notes element.The
    required id attribute uniquely identifies each object, and must
    conform to the format specified by the ObjectIdPattern simple
    type. The required version attribute holds the current version
    of the object element. Versions are integers, starting at 1 and
    incrementing every time an object is modified. The optional
    comment attribute provides a short description of the object.
    The optional deprecated attribute signifies that an id is no
    longer to be used or referenced but the information has been
    kept around for historic purposes."""
    subclass = None
    superclass = None
    def __init__(self, comment=None, deprecated=False, version=None, id=None, Signature=None, notes=None):
        self.comment = _cast(None, comment)
        self.deprecated = _cast(bool, deprecated)
        self.version = _cast(int, version)
        self.id = _cast(None, id)
        self.Signature = Signature
        self.notes = notes
    def factory(*args_, **kwargs_):
        if xmldsig-core-schema.ObjectType.subclass:
            return xmldsig-core-schema.ObjectType.subclass(*args_, **kwargs_)
        else:
            return xmldsig-core-schema.ObjectType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Signature(self): return self.Signature
    def set_Signature(self, Signature): self.Signature = Signature
    def get_notes(self): return self.notes
    def set_notes(self, notes): self.notes = notes
    def get_comment(self): return self.comment
    def set_comment(self, comment): self.comment = comment
    def get_deprecated(self): return self.deprecated
    def set_deprecated(self, deprecated): self.deprecated = deprecated
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.Signature is not None or
            self.notes is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='oval-def:', name_='xmldsig-core-schema.ObjectType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='xmldsig-core-schema.ObjectType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='oval-def:', name_='xmldsig-core-schema.ObjectType'):
        if self.comment is not None and 'comment' not in already_processed:
            already_processed.add('comment')
            outfile.write(' comment=%s' % (quote_attrib(self.comment), ))
        if self.deprecated is not None and 'deprecated' not in already_processed:
            already_processed.add('deprecated')
            outfile.write(' deprecated="%s"' % self.gds_format_boolean(self.deprecated, input_name='deprecated'))
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version="%s"' % self.gds_format_integer(self.version, input_name='version'))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
    def exportChildren(self, outfile, level, namespace_='oval-def:', name_='xmldsig-core-schema.ObjectType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Signature is not None:
            self.Signature.export(outfile, level, '', name_='Signature', pretty_print=pretty_print)
        if self.notes is not None:
            self.notes.export(outfile, level, '', name_='notes', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='xmldsig-core-schema.ObjectType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.comment is not None and 'comment' not in already_processed:
            already_processed.add('comment')
            showIndent(outfile, level)
            outfile.write('comment = %s,\n' % (self.comment,))
        if self.deprecated is not None and 'deprecated' not in already_processed:
            already_processed.add('deprecated')
            showIndent(outfile, level)
            outfile.write('deprecated = %s,\n' % (self.deprecated,))
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            showIndent(outfile, level)
            outfile.write('version = %d,\n' % (self.version,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id = %s,\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Signature is not None:
            showIndent(outfile, level)
            outfile.write('Signature=model_.Signature(\n')
            self.Signature.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.notes is not None:
            outfile.write('notes=model_.NotesType(\n')
            self.notes.exportLiteral(outfile, level, name_='notes')
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('comment', node)
        if value is not None and 'comment' not in already_processed:
            already_processed.add('comment')
            self.comment = value
        value = find_attr_value_('deprecated', node)
        if value is not None and 'deprecated' not in already_processed:
            already_processed.add('deprecated')
            if value in ('true', '1'):
                self.deprecated = True
            elif value in ('false', '0'):
                self.deprecated = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            try:
                self.version = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.version < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Signature':
            obj_ = xmldsig-core-schema.SignatureType.factory()
            obj_.build(child_)
            self.set_Signature(obj_)
        elif nodeName_ == 'notes':
            obj_ = NotesType.factory()
            obj_.build(child_)
            self.set_notes(obj_)
# end class xmldsig-core-schema.ObjectType

class StatesType(GeneratedsSuper):
    """The StatesType complex type is a container for one or more state
    child elements. Each state provides details about specific
    characteristics that can be used during an evaluation of an
    object. Please refer to the description of the state element for
    more information about an individual state."""
    subclass = None
    superclass = None
    def __init__(self, state=None):
        if state is None:
            self.state = []
        else:
            self.state = state
    def factory(*args_, **kwargs_):
        if StatesType.subclass:
            return StatesType.subclass(*args_, **kwargs_)
        else:
            return StatesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_state(self): return self.state
    def set_state(self, state): self.state = state
    def add_state(self, value): self.state.append(value)
    def insert_state(self, index, value): self.state[index] = value
    def hasContent_(self):
        if (
            self.state
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='oval-def:', name_='StatesType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StatesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='oval-def:', name_='StatesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='oval-def:', name_='StatesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for state_ in self.get_state():
            state_.export(outfile, level, '', name_='state', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='StatesType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('state=[\n')
        level += 1
        for state_ in self.state:
            outfile.write('model_.state(\n')
            state_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'state':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <state> element')
            self.state.append(obj_)
# end class StatesType

class StateType(GeneratedsSuper):
    """The base type of every state includes an optional notes element and
    two attributes. The notes section of a state should be used to
    hold information that might be helpful to someone examining the
    technical aspects of the state. For example, why certain values
    have been used by the state, or maybe a link to where further
    information can be found. Please refer to the description of the
    NotesType complex type for more information about the notes
    element.The required id attribute uniquely identifies each
    state, and must conform to the format specified by the
    StateIdPattern simple type. The required version attribute holds
    the current version of the state. Versions are integers,
    starting at 1 and incrementing every time a state is modified.
    The required operator attribute provides the logical operator
    that binds the different characteristics inside a state
    together. The optional comment attribute provides a short
    description of the state. The optional deprecated attribute
    signifies that an id is no longer to be used or referenced but
    the information has been kept around for historic purposes.When
    evaluating a particular state against an object, one should
    evaluate each individual entity separately. The individual
    results are then combined by the operator to produce an overall
    result. This process holds true even when there are multiple
    instances of the same entity. Evaluate each instance separately,
    taking the entity check attribute into account, and then combine
    everything using the operator."""
    subclass = None
    superclass = None
    def __init__(self, operator='AND', comment=None, version=None, id=None, deprecated=False, Signature=None, notes=None):
        self.operator = _cast(None, operator)
        self.comment = _cast(None, comment)
        self.version = _cast(int, version)
        self.id = _cast(None, id)
        self.deprecated = _cast(bool, deprecated)
        self.Signature = Signature
        self.notes = notes
    def factory(*args_, **kwargs_):
        if StateType.subclass:
            return StateType.subclass(*args_, **kwargs_)
        else:
            return StateType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Signature(self): return self.Signature
    def set_Signature(self, Signature): self.Signature = Signature
    def get_notes(self): return self.notes
    def set_notes(self, notes): self.notes = notes
    def get_operator(self): return self.operator
    def set_operator(self, operator): self.operator = operator
    def get_comment(self): return self.comment
    def set_comment(self, comment): self.comment = comment
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_deprecated(self): return self.deprecated
    def set_deprecated(self, deprecated): self.deprecated = deprecated
    def hasContent_(self):
        if (
            self.Signature is not None or
            self.notes is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='oval-def:', name_='StateType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StateType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='oval-def:', name_='StateType'):
        if self.operator is not None and 'operator' not in already_processed:
            already_processed.add('operator')
            outfile.write(' operator=%s' % (quote_attrib(self.operator), ))
        if self.comment is not None and 'comment' not in already_processed:
            already_processed.add('comment')
            outfile.write(' comment=%s' % (quote_attrib(self.comment), ))
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version="%s"' % self.gds_format_integer(self.version, input_name='version'))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.deprecated is not None and 'deprecated' not in already_processed:
            already_processed.add('deprecated')
            outfile.write(' deprecated="%s"' % self.gds_format_boolean(self.deprecated, input_name='deprecated'))
    def exportChildren(self, outfile, level, namespace_='oval-def:', name_='StateType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Signature is not None:
            self.Signature.export(outfile, level, '', name_='Signature', pretty_print=pretty_print)
        if self.notes is not None:
            self.notes.export(outfile, level, '', name_='notes', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='StateType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.operator is not None and 'operator' not in already_processed:
            already_processed.add('operator')
            showIndent(outfile, level)
            outfile.write('operator = %s,\n' % (self.operator,))
        if self.comment is not None and 'comment' not in already_processed:
            already_processed.add('comment')
            showIndent(outfile, level)
            outfile.write('comment = %s,\n' % (self.comment,))
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            showIndent(outfile, level)
            outfile.write('version = %d,\n' % (self.version,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id = %s,\n' % (self.id,))
        if self.deprecated is not None and 'deprecated' not in already_processed:
            already_processed.add('deprecated')
            showIndent(outfile, level)
            outfile.write('deprecated = %s,\n' % (self.deprecated,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Signature is not None:
            showIndent(outfile, level)
            outfile.write('Signature=model_.Signature(\n')
            self.Signature.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.notes is not None:
            outfile.write('notes=model_.NotesType(\n')
            self.notes.exportLiteral(outfile, level, name_='notes')
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('operator', node)
        if value is not None and 'operator' not in already_processed:
            already_processed.add('operator')
            self.operator = value
        value = find_attr_value_('comment', node)
        if value is not None and 'comment' not in already_processed:
            already_processed.add('comment')
            self.comment = value
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            try:
                self.version = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.version < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('deprecated', node)
        if value is not None and 'deprecated' not in already_processed:
            already_processed.add('deprecated')
            if value in ('true', '1'):
                self.deprecated = True
            elif value in ('false', '0'):
                self.deprecated = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Signature':
            obj_ = xmldsig-core-schema.SignatureType.factory()
            obj_.build(child_)
            self.set_Signature(obj_)
        elif nodeName_ == 'notes':
            obj_ = NotesType.factory()
            obj_.build(child_)
            self.set_notes(obj_)
# end class StateType

class VariablesType(GeneratedsSuper):
    """The VariablesType complex type is a container for one or more
    variable child elements. Each variable element is a way to
    define one or more values to be obtained at the time a
    definition is evaluated."""
    subclass = None
    superclass = None
    def __init__(self, variable=None):
        if variable is None:
            self.variable = []
        else:
            self.variable = variable
    def factory(*args_, **kwargs_):
        if VariablesType.subclass:
            return VariablesType.subclass(*args_, **kwargs_)
        else:
            return VariablesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_variable(self): return self.variable
    def set_variable(self, variable): self.variable = variable
    def add_variable(self, value): self.variable.append(value)
    def insert_variable(self, index, value): self.variable[index] = value
    def hasContent_(self):
        if (
            self.variable
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='oval-def:', name_='VariablesType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VariablesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='oval-def:', name_='VariablesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='oval-def:', name_='VariablesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for variable_ in self.get_variable():
            variable_.export(outfile, level, '', name_='variable', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='VariablesType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('variable=[\n')
        level += 1
        for variable_ in self.variable:
            outfile.write('model_.variable(\n')
            variable_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'variable':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <variable> element')
            self.variable.append(obj_)
# end class VariablesType

class VariableType(GeneratedsSuper):
    """The VariableType complex type defines attributes associated with
    each OVAL Variable. The required id attribute uniquely
    identifies each variable, and must conform to the format
    specified by the VariableIDPattern simple type. The required
    version attribute holds the current version of the variable.
    Versions are integers, starting at 1 and incrementing every time
    a variable is modified. The required comment attribute provides
    a short description of the variable. The optional deprecated
    attribute signifies that an id is no longer to be used or
    referenced but the information has been kept around for historic
    purposes.The required datatype attribute specifies the type of
    value being defined. The set of values identified by a variable
    must comply with the specified datatype, otherwise an error
    should be reported. Please see the DatatypeEnumeration for
    details about each valid datatype. For example, if the datatype
    of the variable is specified as boolean then the value(s)
    returned by the component / function should be "true", "false",
    "1", or "0".Note that the 'record' datatype is not permitted on
    variables.Note that the 'record' datatype is not permitted on
    variables."""
    subclass = None
    superclass = None
    def __init__(self, datatype=None, comment=None, version=None, id=None, deprecated=False, Signature=None, extensiontype_=None):
        self.datatype = _cast(None, datatype)
        self.comment = _cast(None, comment)
        self.version = _cast(int, version)
        self.id = _cast(None, id)
        self.deprecated = _cast(bool, deprecated)
        self.Signature = Signature
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if VariableType.subclass:
            return VariableType.subclass(*args_, **kwargs_)
        else:
            return VariableType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Signature(self): return self.Signature
    def set_Signature(self, Signature): self.Signature = Signature
    def get_datatype(self): return self.datatype
    def set_datatype(self, datatype): self.datatype = datatype
    def get_comment(self): return self.comment
    def set_comment(self, comment): self.comment = comment
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_deprecated(self): return self.deprecated
    def set_deprecated(self, deprecated): self.deprecated = deprecated
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.Signature is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='oval-def:', name_='VariableType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VariableType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='oval-def:', name_='VariableType'):
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            outfile.write(' datatype=%s' % (quote_attrib(self.datatype), ))
        if self.comment is not None and 'comment' not in already_processed:
            already_processed.add('comment')
            outfile.write(' comment=%s' % (quote_attrib(self.comment), ))
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version="%s"' % self.gds_format_integer(self.version, input_name='version'))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.deprecated is not None and 'deprecated' not in already_processed:
            already_processed.add('deprecated')
            outfile.write(' deprecated="%s"' % self.gds_format_boolean(self.deprecated, input_name='deprecated'))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='oval-def:', name_='VariableType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Signature is not None:
            self.Signature.export(outfile, level, '', name_='Signature', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='VariableType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            showIndent(outfile, level)
            outfile.write('datatype = %s,\n' % (self.datatype,))
        if self.comment is not None and 'comment' not in already_processed:
            already_processed.add('comment')
            showIndent(outfile, level)
            outfile.write('comment = %s,\n' % (self.comment,))
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            showIndent(outfile, level)
            outfile.write('version = %d,\n' % (self.version,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id = %s,\n' % (self.id,))
        if self.deprecated is not None and 'deprecated' not in already_processed:
            already_processed.add('deprecated')
            showIndent(outfile, level)
            outfile.write('deprecated = %s,\n' % (self.deprecated,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Signature is not None:
            showIndent(outfile, level)
            outfile.write('Signature=model_.Signature(\n')
            self.Signature.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('datatype', node)
        if value is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            self.datatype = value
        value = find_attr_value_('comment', node)
        if value is not None and 'comment' not in already_processed:
            already_processed.add('comment')
            self.comment = value
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            try:
                self.version = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.version < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('deprecated', node)
        if value is not None and 'deprecated' not in already_processed:
            already_processed.add('deprecated')
            if value in ('true', '1'):
                self.deprecated = True
            elif value in ('false', '0'):
                self.deprecated = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Signature':
            obj_ = xmldsig-core-schema.SignatureType.factory()
            obj_.build(child_)
            self.set_Signature(obj_)
# end class VariableType

class PossibleValueType(GeneratedsSuper):
    """The PossibleValueType complex type is used to outline a single
    expected value of an external variable. The required hint
    attribute gives a short description of what the value means or
    represents."""
    subclass = None
    superclass = None
    def __init__(self, hint=None, valueOf_=None):
        self.hint = _cast(None, hint)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if PossibleValueType.subclass:
            return PossibleValueType.subclass(*args_, **kwargs_)
        else:
            return PossibleValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_hint(self): return self.hint
    def set_hint(self, hint): self.hint = hint
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='oval-def:', name_='PossibleValueType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PossibleValueType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='oval-def:', name_='PossibleValueType'):
        if self.hint is not None and 'hint' not in already_processed:
            already_processed.add('hint')
            outfile.write(' hint=%s' % (self.gds_format_string(quote_attrib(self.hint).encode(ExternalEncoding), input_name='hint'), ))
    def exportChildren(self, outfile, level, namespace_='oval-def:', name_='PossibleValueType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='PossibleValueType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.hint is not None and 'hint' not in already_processed:
            already_processed.add('hint')
            showIndent(outfile, level)
            outfile.write('hint = "%s",\n' % (self.hint,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('hint', node)
        if value is not None and 'hint' not in already_processed:
            already_processed.add('hint')
            self.hint = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PossibleValueType

class PossibleRestrictionType(GeneratedsSuper):
    """The PossibleRestrictionType complex type outlines a range of
    possible expected value of an external variable. Each
    possible_restriction element contains an unbounded list of child
    restriction elements that each specify a range that an actual
    value may fall in. For example, a restriction element may
    specify that a value must be less than 10. When multiple
    restriction elements are present, a valid possible value would
    have to meet every restriction. One can think of the
    possible_value and possible_restriction elements as an OR'd list
    of possible values, and the restriction elements as an AND'd
    list of value descriptions. Please refer to the description of
    the RestrictionType complex type for more information. The
    required hint attribute gives a short description of what the
    value means or represents."""
    subclass = None
    superclass = None
    def __init__(self, hint=None, restriction=None):
        self.hint = _cast(None, hint)
        if restriction is None:
            self.restriction = []
        else:
            self.restriction = restriction
    def factory(*args_, **kwargs_):
        if PossibleRestrictionType.subclass:
            return PossibleRestrictionType.subclass(*args_, **kwargs_)
        else:
            return PossibleRestrictionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_restriction(self): return self.restriction
    def set_restriction(self, restriction): self.restriction = restriction
    def add_restriction(self, value): self.restriction.append(value)
    def insert_restriction(self, index, value): self.restriction[index] = value
    def get_hint(self): return self.hint
    def set_hint(self, hint): self.hint = hint
    def hasContent_(self):
        if (
            self.restriction
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='oval-def:', name_='PossibleRestrictionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PossibleRestrictionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='oval-def:', name_='PossibleRestrictionType'):
        if self.hint is not None and 'hint' not in already_processed:
            already_processed.add('hint')
            outfile.write(' hint=%s' % (self.gds_format_string(quote_attrib(self.hint).encode(ExternalEncoding), input_name='hint'), ))
    def exportChildren(self, outfile, level, namespace_='oval-def:', name_='PossibleRestrictionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for restriction_ in self.restriction:
            restriction_.export(outfile, level, '', name_='restriction', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='PossibleRestrictionType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.hint is not None and 'hint' not in already_processed:
            already_processed.add('hint')
            showIndent(outfile, level)
            outfile.write('hint = "%s",\n' % (self.hint,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('restriction=[\n')
        level += 1
        for restriction_ in self.restriction:
            outfile.write('model_.RestrictionType(\n')
            restriction_.exportLiteral(outfile, level, name_='RestrictionType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('hint', node)
        if value is not None and 'hint' not in already_processed:
            already_processed.add('hint')
            self.hint = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'restriction':
            obj_ = RestrictionType.factory()
            obj_.build(child_)
            self.restriction.append(obj_)
# end class PossibleRestrictionType

class RestrictionType(GeneratedsSuper):
    """The RestrictionType complex type outlines a restriction that is
    placed on expected values for an external variable. For example,
    a possible value may be restricted to a integer less than 10.
    Please refer to the operationEnumeration simple type for a
    description of the valid operations. The required hint attribute
    gives a short description of what the value means or represents."""
    subclass = None
    superclass = None
    def __init__(self, operation=None, valueOf_=None):
        self.operation = _cast(None, operation)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if RestrictionType.subclass:
            return RestrictionType.subclass(*args_, **kwargs_)
        else:
            return RestrictionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_operation(self): return self.operation
    def set_operation(self, operation): self.operation = operation
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='oval-def:', name_='RestrictionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RestrictionType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='oval-def:', name_='RestrictionType'):
        if self.operation is not None and 'operation' not in already_processed:
            already_processed.add('operation')
            outfile.write(' operation=%s' % (quote_attrib(self.operation), ))
    def exportChildren(self, outfile, level, namespace_='oval-def:', name_='RestrictionType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='RestrictionType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.operation is not None and 'operation' not in already_processed:
            already_processed.add('operation')
            showIndent(outfile, level)
            outfile.write('operation = %s,\n' % (self.operation,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('operation', node)
        if value is not None and 'operation' not in already_processed:
            already_processed.add('operation')
            self.operation = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class RestrictionType

class ValueType(GeneratedsSuper):
    """The ValueType complex type holds the actual value of the variable
    when dealing with a constant variable. This value should be used
    by all tests that reference this variable. The value cannot be
    over-ridden by an external source."""
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if ValueType.subclass:
            return ValueType.subclass(*args_, **kwargs_)
        else:
            return ValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='oval-def:', name_='ValueType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ValueType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='oval-def:', name_='ValueType'):
        pass
    def exportChildren(self, outfile, level, namespace_='oval-def:', name_='ValueType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='ValueType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ValueType

class LiteralComponentType(GeneratedsSuper):
    """The LiteralComponentType complex type defines a literal value to be
    used as a component. The optional datatype attribute defines the
    type of data expected. The default datatype is 'string'."""
    subclass = None
    superclass = None
    def __init__(self, datatype='string', valueOf_=None):
        self.datatype = _cast(None, datatype)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if LiteralComponentType.subclass:
            return LiteralComponentType.subclass(*args_, **kwargs_)
        else:
            return LiteralComponentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_datatype(self): return self.datatype
    def set_datatype(self, datatype): self.datatype = datatype
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='oval-def:', name_='LiteralComponentType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LiteralComponentType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='oval-def:', name_='LiteralComponentType'):
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            outfile.write(' datatype=%s' % (quote_attrib(self.datatype), ))
    def exportChildren(self, outfile, level, namespace_='oval-def:', name_='LiteralComponentType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='LiteralComponentType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            showIndent(outfile, level)
            outfile.write('datatype = %s,\n' % (self.datatype,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('datatype', node)
        if value is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            self.datatype = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LiteralComponentType

class ObjectComponentType(GeneratedsSuper):
    """The ObjectComponentType complex type defines a specific value or set
    of values on the local system to obtain.The required object_ref
    attribute provides a reference to an existing OVAL Object
    declaration. The referenced OVAL Object specifies a set of OVAL
    Items to collect. Note that an OVAL Object might identify 0, 1,
    or many OVAL Items on a system. If no items are found on the
    system then an error should be reported when determining the
    value of an ObjectComponentType. If 1 or more OVAL Items are
    found then each OVAL Item will be considered and the
    ObjectComponentType may have one or more values.The required
    item_field attribute specifies the name of the entity whose
    value will be retrieved from each OVAL Item collected by the
    referenced OVAL Object. For example, if the object_ref
    references a win-def:file_object, the item_field may specify the
    'version' entity as the field to use as the value of the
    ObjectComponentType. Note that an OVAL Item may have 0, 1, or
    many entities whose name matches the specified item_field value.
    If an entity is not found with a name that matches the value of
    the item_field an error should be reported when determining the
    value of an ObjectComponentType. If 1 or more matching entities
    are found in a single OVAL Item the value of the
    ObjectComponentType is the list of the values from each of the
    matching entities.The optional record_field attribute specifies
    the name of a field in a record entity in an OVAL Item. The
    record_field attribute allows the value of a specific field to
    be retrieved from an entity with a datatype of 'record'. If a
    field with a matching name attribute value is not found in the
    referenced OVAL Item entity an error should be reported when
    determining the value of the ObjectComponentType."""
    subclass = None
    superclass = None
    def __init__(self, record_field=None, object_ref=None, item_field=None):
        self.record_field = _cast(None, record_field)
        self.object_ref = _cast(None, object_ref)
        self.item_field = _cast(None, item_field)
        pass
    def factory(*args_, **kwargs_):
        if ObjectComponentType.subclass:
            return ObjectComponentType.subclass(*args_, **kwargs_)
        else:
            return ObjectComponentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_record_field(self): return self.record_field
    def set_record_field(self, record_field): self.record_field = record_field
    def get_object_ref(self): return self.object_ref
    def set_object_ref(self, object_ref): self.object_ref = object_ref
    def get_item_field(self): return self.item_field
    def set_item_field(self, item_field): self.item_field = item_field
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='oval-def:', name_='ObjectComponentType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ObjectComponentType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='oval-def:', name_='ObjectComponentType'):
        if self.record_field is not None and 'record_field' not in already_processed:
            already_processed.add('record_field')
            outfile.write(' record_field=%s' % (quote_attrib(self.record_field), ))
        if self.object_ref is not None and 'object_ref' not in already_processed:
            already_processed.add('object_ref')
            outfile.write(' object_ref=%s' % (quote_attrib(self.object_ref), ))
        if self.item_field is not None and 'item_field' not in already_processed:
            already_processed.add('item_field')
            outfile.write(' item_field=%s' % (quote_attrib(self.item_field), ))
    def exportChildren(self, outfile, level, namespace_='oval-def:', name_='ObjectComponentType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='ObjectComponentType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.record_field is not None and 'record_field' not in already_processed:
            already_processed.add('record_field')
            showIndent(outfile, level)
            outfile.write('record_field = %s,\n' % (self.record_field,))
        if self.object_ref is not None and 'object_ref' not in already_processed:
            already_processed.add('object_ref')
            showIndent(outfile, level)
            outfile.write('object_ref = %s,\n' % (self.object_ref,))
        if self.item_field is not None and 'item_field' not in already_processed:
            already_processed.add('item_field')
            showIndent(outfile, level)
            outfile.write('item_field = %s,\n' % (self.item_field,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('record_field', node)
        if value is not None and 'record_field' not in already_processed:
            already_processed.add('record_field')
            self.record_field = value
        value = find_attr_value_('object_ref', node)
        if value is not None and 'object_ref' not in already_processed:
            already_processed.add('object_ref')
            self.object_ref = value
        value = find_attr_value_('item_field', node)
        if value is not None and 'item_field' not in already_processed:
            already_processed.add('item_field')
            self.item_field = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ObjectComponentType

class VariableComponentType(GeneratedsSuper):
    """The VariableComponentType complex type defines a specific value
    obtained by looking at the value of another OVAL Variable. The
    required var_ref attribute provides a reference to the variable.
    One must make sure that the variable reference does not point to
    the parent variable that uses this component to avoid a race
    condition."""
    subclass = None
    superclass = None
    def __init__(self, var_ref=None):
        self.var_ref = _cast(None, var_ref)
        pass
    def factory(*args_, **kwargs_):
        if VariableComponentType.subclass:
            return VariableComponentType.subclass(*args_, **kwargs_)
        else:
            return VariableComponentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_var_ref(self): return self.var_ref
    def set_var_ref(self, var_ref): self.var_ref = var_ref
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='oval-def:', name_='VariableComponentType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VariableComponentType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='oval-def:', name_='VariableComponentType'):
        if self.var_ref is not None and 'var_ref' not in already_processed:
            already_processed.add('var_ref')
            outfile.write(' var_ref=%s' % (quote_attrib(self.var_ref), ))
    def exportChildren(self, outfile, level, namespace_='oval-def:', name_='VariableComponentType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='VariableComponentType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.var_ref is not None and 'var_ref' not in already_processed:
            already_processed.add('var_ref')
            showIndent(outfile, level)
            outfile.write('var_ref = %s,\n' % (self.var_ref,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('var_ref', node)
        if value is not None and 'var_ref' not in already_processed:
            already_processed.add('var_ref')
            self.var_ref = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class VariableComponentType

class ArithmeticFunctionType(GeneratedsSuper):
    """The arithmetic function takes two or more integer or float
    components and performs a basic mathematical function on them.
    The result of this function is a single integer or float unless
    one of the components returns multiple values. In this case the
    specified arithmetic function would be performed multiple times
    and the end result would be an array of values for the local
    variable. For example assume a local_variable specifies the
    arithmetic function with an arithmetic_operation of "add" and
    has two sub-components under this function: the first component
    returns multiple values "1" and "2", and the second component
    returns multiple values "3" and "4" and "5". The local_variable
    element would be evaluated to have six values: 1+3, 1+4, 1+5,
    2+3, 2+4, and 2+5.Note that if both an integer and float
    components are used then the result is a float."""
    subclass = None
    superclass = None
    def __init__(self, arithmetic_operation=None, object_component=None, variable_component=None, literal_component=None, arithmetic=None, begin=None, concat=None, end=None, escape_regex=None, split=None, substring=None, time_difference=None, regex_capture=None, unique=None, count=None):
        self.arithmetic_operation = _cast(None, arithmetic_operation)
        self.object_component = object_component
        self.variable_component = variable_component
        self.literal_component = literal_component
        self.arithmetic = arithmetic
        self.begin = begin
        self.concat = concat
        self.end = end
        self.escape_regex = escape_regex
        self.split = split
        self.substring = substring
        self.time_difference = time_difference
        self.regex_capture = regex_capture
        self.unique = unique
        self.count = count
    def factory(*args_, **kwargs_):
        if ArithmeticFunctionType.subclass:
            return ArithmeticFunctionType.subclass(*args_, **kwargs_)
        else:
            return ArithmeticFunctionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_object_component(self): return self.object_component
    def set_object_component(self, object_component): self.object_component = object_component
    def get_variable_component(self): return self.variable_component
    def set_variable_component(self, variable_component): self.variable_component = variable_component
    def get_literal_component(self): return self.literal_component
    def set_literal_component(self, literal_component): self.literal_component = literal_component
    def get_arithmetic(self): return self.arithmetic
    def set_arithmetic(self, arithmetic): self.arithmetic = arithmetic
    def get_begin(self): return self.begin
    def set_begin(self, begin): self.begin = begin
    def get_concat(self): return self.concat
    def set_concat(self, concat): self.concat = concat
    def get_end(self): return self.end
    def set_end(self, end): self.end = end
    def get_escape_regex(self): return self.escape_regex
    def set_escape_regex(self, escape_regex): self.escape_regex = escape_regex
    def get_split(self): return self.split
    def set_split(self, split): self.split = split
    def get_substring(self): return self.substring
    def set_substring(self, substring): self.substring = substring
    def get_time_difference(self): return self.time_difference
    def set_time_difference(self, time_difference): self.time_difference = time_difference
    def get_regex_capture(self): return self.regex_capture
    def set_regex_capture(self, regex_capture): self.regex_capture = regex_capture
    def get_unique(self): return self.unique
    def set_unique(self, unique): self.unique = unique
    def get_count(self): return self.count
    def set_count(self, count): self.count = count
    def get_arithmetic_operation(self): return self.arithmetic_operation
    def set_arithmetic_operation(self, arithmetic_operation): self.arithmetic_operation = arithmetic_operation
    def hasContent_(self):
        if (
            self.object_component is not None or
            self.variable_component is not None or
            self.literal_component is not None or
            self.arithmetic is not None or
            self.begin is not None or
            self.concat is not None or
            self.end is not None or
            self.escape_regex is not None or
            self.split is not None or
            self.substring is not None or
            self.time_difference is not None or
            self.regex_capture is not None or
            self.unique is not None or
            self.count is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='oval-def:', name_='ArithmeticFunctionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ArithmeticFunctionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='oval-def:', name_='ArithmeticFunctionType'):
        if self.arithmetic_operation is not None and 'arithmetic_operation' not in already_processed:
            already_processed.add('arithmetic_operation')
            outfile.write(' arithmetic_operation=%s' % (quote_attrib(self.arithmetic_operation), ))
    def exportChildren(self, outfile, level, namespace_='oval-def:', name_='ArithmeticFunctionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.object_component is not None:
            self.object_component.export(outfile, level, '', name_='object_component', pretty_print=pretty_print)
        if self.variable_component is not None:
            self.variable_component.export(outfile, level, '', name_='variable_component', pretty_print=pretty_print)
        if self.literal_component is not None:
            self.literal_component.export(outfile, level, '', name_='literal_component', pretty_print=pretty_print)
        if self.arithmetic is not None:
            self.arithmetic.export(outfile, level, '', name_='arithmetic', pretty_print=pretty_print)
        if self.begin is not None:
            self.begin.export(outfile, level, '', name_='begin', pretty_print=pretty_print)
        if self.concat is not None:
            self.concat.export(outfile, level, '', name_='concat', pretty_print=pretty_print)
        if self.end is not None:
            self.end.export(outfile, level, '', name_='end', pretty_print=pretty_print)
        if self.escape_regex is not None:
            self.escape_regex.export(outfile, level, '', name_='escape_regex', pretty_print=pretty_print)
        if self.split is not None:
            self.split.export(outfile, level, '', name_='split', pretty_print=pretty_print)
        if self.substring is not None:
            self.substring.export(outfile, level, '', name_='substring', pretty_print=pretty_print)
        if self.time_difference is not None:
            self.time_difference.export(outfile, level, '', name_='time_difference', pretty_print=pretty_print)
        if self.regex_capture is not None:
            self.regex_capture.export(outfile, level, '', name_='regex_capture', pretty_print=pretty_print)
        if self.unique is not None:
            self.unique.export(outfile, level, '', name_='unique', pretty_print=pretty_print)
        if self.count is not None:
            self.count.export(outfile, level, '', name_='count', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ArithmeticFunctionType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.arithmetic_operation is not None and 'arithmetic_operation' not in already_processed:
            already_processed.add('arithmetic_operation')
            showIndent(outfile, level)
            outfile.write('arithmetic_operation = %s,\n' % (self.arithmetic_operation,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.object_component is not None:
            outfile.write('object_component=model_.ObjectComponentType(\n')
            self.object_component.exportLiteral(outfile, level, name_='object_component')
            outfile.write('),\n')
        if self.variable_component is not None:
            outfile.write('variable_component=model_.VariableComponentType(\n')
            self.variable_component.exportLiteral(outfile, level, name_='variable_component')
            outfile.write('),\n')
        if self.literal_component is not None:
            outfile.write('literal_component=model_.LiteralComponentType(\n')
            self.literal_component.exportLiteral(outfile, level, name_='literal_component')
            outfile.write('),\n')
        if self.arithmetic is not None:
            outfile.write('arithmetic=model_.ArithmeticFunctionType(\n')
            self.arithmetic.exportLiteral(outfile, level, name_='arithmetic')
            outfile.write('),\n')
        if self.begin is not None:
            outfile.write('begin=model_.BeginFunctionType(\n')
            self.begin.exportLiteral(outfile, level, name_='begin')
            outfile.write('),\n')
        if self.concat is not None:
            outfile.write('concat=model_.ConcatFunctionType(\n')
            self.concat.exportLiteral(outfile, level, name_='concat')
            outfile.write('),\n')
        if self.end is not None:
            outfile.write('end=model_.EndFunctionType(\n')
            self.end.exportLiteral(outfile, level, name_='end')
            outfile.write('),\n')
        if self.escape_regex is not None:
            outfile.write('escape_regex=model_.EscapeRegexFunctionType(\n')
            self.escape_regex.exportLiteral(outfile, level, name_='escape_regex')
            outfile.write('),\n')
        if self.split is not None:
            outfile.write('split=model_.SplitFunctionType(\n')
            self.split.exportLiteral(outfile, level, name_='split')
            outfile.write('),\n')
        if self.substring is not None:
            outfile.write('substring=model_.SubstringFunctionType(\n')
            self.substring.exportLiteral(outfile, level, name_='substring')
            outfile.write('),\n')
        if self.time_difference is not None:
            outfile.write('time_difference=model_.TimeDifferenceFunctionType(\n')
            self.time_difference.exportLiteral(outfile, level, name_='time_difference')
            outfile.write('),\n')
        if self.regex_capture is not None:
            outfile.write('regex_capture=model_.RegexCaptureFunctionType(\n')
            self.regex_capture.exportLiteral(outfile, level, name_='regex_capture')
            outfile.write('),\n')
        if self.unique is not None:
            outfile.write('unique=model_.UniqueFunctionType(\n')
            self.unique.exportLiteral(outfile, level, name_='unique')
            outfile.write('),\n')
        if self.count is not None:
            outfile.write('count=model_.CountFunctionType(\n')
            self.count.exportLiteral(outfile, level, name_='count')
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('arithmetic_operation', node)
        if value is not None and 'arithmetic_operation' not in already_processed:
            already_processed.add('arithmetic_operation')
            self.arithmetic_operation = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'object_component':
            obj_ = ObjectComponentType.factory()
            obj_.build(child_)
            self.set_object_component(obj_)
        elif nodeName_ == 'variable_component':
            obj_ = VariableComponentType.factory()
            obj_.build(child_)
            self.set_variable_component(obj_)
        elif nodeName_ == 'literal_component':
            obj_ = LiteralComponentType.factory()
            obj_.build(child_)
            self.set_literal_component(obj_)
        elif nodeName_ == 'arithmetic':
            obj_ = ArithmeticFunctionType.factory()
            obj_.build(child_)
            self.set_arithmetic(obj_)
        elif nodeName_ == 'begin':
            obj_ = BeginFunctionType.factory()
            obj_.build(child_)
            self.set_begin(obj_)
        elif nodeName_ == 'concat':
            obj_ = ConcatFunctionType.factory()
            obj_.build(child_)
            self.set_concat(obj_)
        elif nodeName_ == 'end':
            obj_ = EndFunctionType.factory()
            obj_.build(child_)
            self.set_end(obj_)
        elif nodeName_ == 'escape_regex':
            obj_ = EscapeRegexFunctionType.factory()
            obj_.build(child_)
            self.set_escape_regex(obj_)
        elif nodeName_ == 'split':
            obj_ = SplitFunctionType.factory()
            obj_.build(child_)
            self.set_split(obj_)
        elif nodeName_ == 'substring':
            obj_ = SubstringFunctionType.factory()
            obj_.build(child_)
            self.set_substring(obj_)
        elif nodeName_ == 'time_difference':
            obj_ = TimeDifferenceFunctionType.factory()
            obj_.build(child_)
            self.set_time_difference(obj_)
        elif nodeName_ == 'regex_capture':
            obj_ = RegexCaptureFunctionType.factory()
            obj_.build(child_)
            self.set_regex_capture(obj_)
        elif nodeName_ == 'unique':
            obj_ = UniqueFunctionType.factory()
            obj_.build(child_)
            self.set_unique(obj_)
        elif nodeName_ == 'count':
            obj_ = CountFunctionType.factory()
            obj_.build(child_)
            self.set_count(obj_)
# end class ArithmeticFunctionType

class BeginFunctionType(GeneratedsSuper):
    """The begin function takes a single string component and defines a
    character (or string) that the component string should start
    with. The character attribute defines the specific character (or
    string). The character (or string) is only added to the
    component string if the component string does not already start
    with the specified character (or string). If the component
    string does not start with the specified character (or string)
    the entire character (or string) will be prepended to the
    component string.."""
    subclass = None
    superclass = None
    def __init__(self, character=None, object_component=None, variable_component=None, literal_component=None, arithmetic=None, begin=None, concat=None, end=None, escape_regex=None, split=None, substring=None, time_difference=None, regex_capture=None, unique=None, count=None):
        self.character = _cast(None, character)
        self.object_component = object_component
        self.variable_component = variable_component
        self.literal_component = literal_component
        self.arithmetic = arithmetic
        self.begin = begin
        self.concat = concat
        self.end = end
        self.escape_regex = escape_regex
        self.split = split
        self.substring = substring
        self.time_difference = time_difference
        self.regex_capture = regex_capture
        self.unique = unique
        self.count = count
    def factory(*args_, **kwargs_):
        if BeginFunctionType.subclass:
            return BeginFunctionType.subclass(*args_, **kwargs_)
        else:
            return BeginFunctionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_object_component(self): return self.object_component
    def set_object_component(self, object_component): self.object_component = object_component
    def get_variable_component(self): return self.variable_component
    def set_variable_component(self, variable_component): self.variable_component = variable_component
    def get_literal_component(self): return self.literal_component
    def set_literal_component(self, literal_component): self.literal_component = literal_component
    def get_arithmetic(self): return self.arithmetic
    def set_arithmetic(self, arithmetic): self.arithmetic = arithmetic
    def get_begin(self): return self.begin
    def set_begin(self, begin): self.begin = begin
    def get_concat(self): return self.concat
    def set_concat(self, concat): self.concat = concat
    def get_end(self): return self.end
    def set_end(self, end): self.end = end
    def get_escape_regex(self): return self.escape_regex
    def set_escape_regex(self, escape_regex): self.escape_regex = escape_regex
    def get_split(self): return self.split
    def set_split(self, split): self.split = split
    def get_substring(self): return self.substring
    def set_substring(self, substring): self.substring = substring
    def get_time_difference(self): return self.time_difference
    def set_time_difference(self, time_difference): self.time_difference = time_difference
    def get_regex_capture(self): return self.regex_capture
    def set_regex_capture(self, regex_capture): self.regex_capture = regex_capture
    def get_unique(self): return self.unique
    def set_unique(self, unique): self.unique = unique
    def get_count(self): return self.count
    def set_count(self, count): self.count = count
    def get_character(self): return self.character
    def set_character(self, character): self.character = character
    def hasContent_(self):
        if (
            self.object_component is not None or
            self.variable_component is not None or
            self.literal_component is not None or
            self.arithmetic is not None or
            self.begin is not None or
            self.concat is not None or
            self.end is not None or
            self.escape_regex is not None or
            self.split is not None or
            self.substring is not None or
            self.time_difference is not None or
            self.regex_capture is not None or
            self.unique is not None or
            self.count is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='oval-def:', name_='BeginFunctionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BeginFunctionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='oval-def:', name_='BeginFunctionType'):
        if self.character is not None and 'character' not in already_processed:
            already_processed.add('character')
            outfile.write(' character=%s' % (self.gds_format_string(quote_attrib(self.character).encode(ExternalEncoding), input_name='character'), ))
    def exportChildren(self, outfile, level, namespace_='oval-def:', name_='BeginFunctionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.object_component is not None:
            self.object_component.export(outfile, level, '', name_='object_component', pretty_print=pretty_print)
        if self.variable_component is not None:
            self.variable_component.export(outfile, level, '', name_='variable_component', pretty_print=pretty_print)
        if self.literal_component is not None:
            self.literal_component.export(outfile, level, '', name_='literal_component', pretty_print=pretty_print)
        if self.arithmetic is not None:
            self.arithmetic.export(outfile, level, '', name_='arithmetic', pretty_print=pretty_print)
        if self.begin is not None:
            self.begin.export(outfile, level, '', name_='begin', pretty_print=pretty_print)
        if self.concat is not None:
            self.concat.export(outfile, level, '', name_='concat', pretty_print=pretty_print)
        if self.end is not None:
            self.end.export(outfile, level, '', name_='end', pretty_print=pretty_print)
        if self.escape_regex is not None:
            self.escape_regex.export(outfile, level, '', name_='escape_regex', pretty_print=pretty_print)
        if self.split is not None:
            self.split.export(outfile, level, '', name_='split', pretty_print=pretty_print)
        if self.substring is not None:
            self.substring.export(outfile, level, '', name_='substring', pretty_print=pretty_print)
        if self.time_difference is not None:
            self.time_difference.export(outfile, level, '', name_='time_difference', pretty_print=pretty_print)
        if self.regex_capture is not None:
            self.regex_capture.export(outfile, level, '', name_='regex_capture', pretty_print=pretty_print)
        if self.unique is not None:
            self.unique.export(outfile, level, '', name_='unique', pretty_print=pretty_print)
        if self.count is not None:
            self.count.export(outfile, level, '', name_='count', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='BeginFunctionType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.character is not None and 'character' not in already_processed:
            already_processed.add('character')
            showIndent(outfile, level)
            outfile.write('character = "%s",\n' % (self.character,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.object_component is not None:
            outfile.write('object_component=model_.ObjectComponentType(\n')
            self.object_component.exportLiteral(outfile, level, name_='object_component')
            outfile.write('),\n')
        if self.variable_component is not None:
            outfile.write('variable_component=model_.VariableComponentType(\n')
            self.variable_component.exportLiteral(outfile, level, name_='variable_component')
            outfile.write('),\n')
        if self.literal_component is not None:
            outfile.write('literal_component=model_.LiteralComponentType(\n')
            self.literal_component.exportLiteral(outfile, level, name_='literal_component')
            outfile.write('),\n')
        if self.arithmetic is not None:
            outfile.write('arithmetic=model_.ArithmeticFunctionType(\n')
            self.arithmetic.exportLiteral(outfile, level, name_='arithmetic')
            outfile.write('),\n')
        if self.begin is not None:
            outfile.write('begin=model_.BeginFunctionType(\n')
            self.begin.exportLiteral(outfile, level, name_='begin')
            outfile.write('),\n')
        if self.concat is not None:
            outfile.write('concat=model_.ConcatFunctionType(\n')
            self.concat.exportLiteral(outfile, level, name_='concat')
            outfile.write('),\n')
        if self.end is not None:
            outfile.write('end=model_.EndFunctionType(\n')
            self.end.exportLiteral(outfile, level, name_='end')
            outfile.write('),\n')
        if self.escape_regex is not None:
            outfile.write('escape_regex=model_.EscapeRegexFunctionType(\n')
            self.escape_regex.exportLiteral(outfile, level, name_='escape_regex')
            outfile.write('),\n')
        if self.split is not None:
            outfile.write('split=model_.SplitFunctionType(\n')
            self.split.exportLiteral(outfile, level, name_='split')
            outfile.write('),\n')
        if self.substring is not None:
            outfile.write('substring=model_.SubstringFunctionType(\n')
            self.substring.exportLiteral(outfile, level, name_='substring')
            outfile.write('),\n')
        if self.time_difference is not None:
            outfile.write('time_difference=model_.TimeDifferenceFunctionType(\n')
            self.time_difference.exportLiteral(outfile, level, name_='time_difference')
            outfile.write('),\n')
        if self.regex_capture is not None:
            outfile.write('regex_capture=model_.RegexCaptureFunctionType(\n')
            self.regex_capture.exportLiteral(outfile, level, name_='regex_capture')
            outfile.write('),\n')
        if self.unique is not None:
            outfile.write('unique=model_.UniqueFunctionType(\n')
            self.unique.exportLiteral(outfile, level, name_='unique')
            outfile.write('),\n')
        if self.count is not None:
            outfile.write('count=model_.CountFunctionType(\n')
            self.count.exportLiteral(outfile, level, name_='count')
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('character', node)
        if value is not None and 'character' not in already_processed:
            already_processed.add('character')
            self.character = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'object_component':
            obj_ = ObjectComponentType.factory()
            obj_.build(child_)
            self.set_object_component(obj_)
        elif nodeName_ == 'variable_component':
            obj_ = VariableComponentType.factory()
            obj_.build(child_)
            self.set_variable_component(obj_)
        elif nodeName_ == 'literal_component':
            obj_ = LiteralComponentType.factory()
            obj_.build(child_)
            self.set_literal_component(obj_)
        elif nodeName_ == 'arithmetic':
            obj_ = ArithmeticFunctionType.factory()
            obj_.build(child_)
            self.set_arithmetic(obj_)
        elif nodeName_ == 'begin':
            obj_ = BeginFunctionType.factory()
            obj_.build(child_)
            self.set_begin(obj_)
        elif nodeName_ == 'concat':
            obj_ = ConcatFunctionType.factory()
            obj_.build(child_)
            self.set_concat(obj_)
        elif nodeName_ == 'end':
            obj_ = EndFunctionType.factory()
            obj_.build(child_)
            self.set_end(obj_)
        elif nodeName_ == 'escape_regex':
            obj_ = EscapeRegexFunctionType.factory()
            obj_.build(child_)
            self.set_escape_regex(obj_)
        elif nodeName_ == 'split':
            obj_ = SplitFunctionType.factory()
            obj_.build(child_)
            self.set_split(obj_)
        elif nodeName_ == 'substring':
            obj_ = SubstringFunctionType.factory()
            obj_.build(child_)
            self.set_substring(obj_)
        elif nodeName_ == 'time_difference':
            obj_ = TimeDifferenceFunctionType.factory()
            obj_.build(child_)
            self.set_time_difference(obj_)
        elif nodeName_ == 'regex_capture':
            obj_ = RegexCaptureFunctionType.factory()
            obj_.build(child_)
            self.set_regex_capture(obj_)
        elif nodeName_ == 'unique':
            obj_ = UniqueFunctionType.factory()
            obj_.build(child_)
            self.set_unique(obj_)
        elif nodeName_ == 'count':
            obj_ = CountFunctionType.factory()
            obj_.build(child_)
            self.set_count(obj_)
# end class BeginFunctionType

class ConcatFunctionType(GeneratedsSuper):
    """The concat function takes two or more components and concatenates
    them together to form a single string. The first component makes
    up the beginning of the resulting string and any following
    components are added to the end it. If one of the components
    returns multiple values then the concat function would be
    performed multiple times and the end result would be an array of
    values for the local variable. For example assume a local
    variable has two sub-components: a basic component element
    returns the values "abc" and "def", and a literal component
    element that has a value of "xyz". The local_variable element
    would be evaluated to have two values, "abcxyz" and "defxyz". If
    one of the components does not exist, then the result of the
    concat operation should be does not exist."""
    subclass = None
    superclass = None
    def __init__(self, object_component=None, variable_component=None, literal_component=None, arithmetic=None, begin=None, concat=None, end=None, escape_regex=None, split=None, substring=None, time_difference=None, regex_capture=None, unique=None, count=None):
        self.object_component = object_component
        self.variable_component = variable_component
        self.literal_component = literal_component
        self.arithmetic = arithmetic
        self.begin = begin
        self.concat = concat
        self.end = end
        self.escape_regex = escape_regex
        self.split = split
        self.substring = substring
        self.time_difference = time_difference
        self.regex_capture = regex_capture
        self.unique = unique
        self.count = count
    def factory(*args_, **kwargs_):
        if ConcatFunctionType.subclass:
            return ConcatFunctionType.subclass(*args_, **kwargs_)
        else:
            return ConcatFunctionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_object_component(self): return self.object_component
    def set_object_component(self, object_component): self.object_component = object_component
    def get_variable_component(self): return self.variable_component
    def set_variable_component(self, variable_component): self.variable_component = variable_component
    def get_literal_component(self): return self.literal_component
    def set_literal_component(self, literal_component): self.literal_component = literal_component
    def get_arithmetic(self): return self.arithmetic
    def set_arithmetic(self, arithmetic): self.arithmetic = arithmetic
    def get_begin(self): return self.begin
    def set_begin(self, begin): self.begin = begin
    def get_concat(self): return self.concat
    def set_concat(self, concat): self.concat = concat
    def get_end(self): return self.end
    def set_end(self, end): self.end = end
    def get_escape_regex(self): return self.escape_regex
    def set_escape_regex(self, escape_regex): self.escape_regex = escape_regex
    def get_split(self): return self.split
    def set_split(self, split): self.split = split
    def get_substring(self): return self.substring
    def set_substring(self, substring): self.substring = substring
    def get_time_difference(self): return self.time_difference
    def set_time_difference(self, time_difference): self.time_difference = time_difference
    def get_regex_capture(self): return self.regex_capture
    def set_regex_capture(self, regex_capture): self.regex_capture = regex_capture
    def get_unique(self): return self.unique
    def set_unique(self, unique): self.unique = unique
    def get_count(self): return self.count
    def set_count(self, count): self.count = count
    def hasContent_(self):
        if (
            self.object_component is not None or
            self.variable_component is not None or
            self.literal_component is not None or
            self.arithmetic is not None or
            self.begin is not None or
            self.concat is not None or
            self.end is not None or
            self.escape_regex is not None or
            self.split is not None or
            self.substring is not None or
            self.time_difference is not None or
            self.regex_capture is not None or
            self.unique is not None or
            self.count is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='oval-def:', name_='ConcatFunctionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ConcatFunctionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='oval-def:', name_='ConcatFunctionType'):
        pass
    def exportChildren(self, outfile, level, namespace_='oval-def:', name_='ConcatFunctionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.object_component is not None:
            self.object_component.export(outfile, level, '', name_='object_component', pretty_print=pretty_print)
        if self.variable_component is not None:
            self.variable_component.export(outfile, level, '', name_='variable_component', pretty_print=pretty_print)
        if self.literal_component is not None:
            self.literal_component.export(outfile, level, '', name_='literal_component', pretty_print=pretty_print)
        if self.arithmetic is not None:
            self.arithmetic.export(outfile, level, '', name_='arithmetic', pretty_print=pretty_print)
        if self.begin is not None:
            self.begin.export(outfile, level, '', name_='begin', pretty_print=pretty_print)
        if self.concat is not None:
            self.concat.export(outfile, level, '', name_='concat', pretty_print=pretty_print)
        if self.end is not None:
            self.end.export(outfile, level, '', name_='end', pretty_print=pretty_print)
        if self.escape_regex is not None:
            self.escape_regex.export(outfile, level, '', name_='escape_regex', pretty_print=pretty_print)
        if self.split is not None:
            self.split.export(outfile, level, '', name_='split', pretty_print=pretty_print)
        if self.substring is not None:
            self.substring.export(outfile, level, '', name_='substring', pretty_print=pretty_print)
        if self.time_difference is not None:
            self.time_difference.export(outfile, level, '', name_='time_difference', pretty_print=pretty_print)
        if self.regex_capture is not None:
            self.regex_capture.export(outfile, level, '', name_='regex_capture', pretty_print=pretty_print)
        if self.unique is not None:
            self.unique.export(outfile, level, '', name_='unique', pretty_print=pretty_print)
        if self.count is not None:
            self.count.export(outfile, level, '', name_='count', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ConcatFunctionType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.object_component is not None:
            outfile.write('object_component=model_.ObjectComponentType(\n')
            self.object_component.exportLiteral(outfile, level, name_='object_component')
            outfile.write('),\n')
        if self.variable_component is not None:
            outfile.write('variable_component=model_.VariableComponentType(\n')
            self.variable_component.exportLiteral(outfile, level, name_='variable_component')
            outfile.write('),\n')
        if self.literal_component is not None:
            outfile.write('literal_component=model_.LiteralComponentType(\n')
            self.literal_component.exportLiteral(outfile, level, name_='literal_component')
            outfile.write('),\n')
        if self.arithmetic is not None:
            outfile.write('arithmetic=model_.ArithmeticFunctionType(\n')
            self.arithmetic.exportLiteral(outfile, level, name_='arithmetic')
            outfile.write('),\n')
        if self.begin is not None:
            outfile.write('begin=model_.BeginFunctionType(\n')
            self.begin.exportLiteral(outfile, level, name_='begin')
            outfile.write('),\n')
        if self.concat is not None:
            outfile.write('concat=model_.ConcatFunctionType(\n')
            self.concat.exportLiteral(outfile, level, name_='concat')
            outfile.write('),\n')
        if self.end is not None:
            outfile.write('end=model_.EndFunctionType(\n')
            self.end.exportLiteral(outfile, level, name_='end')
            outfile.write('),\n')
        if self.escape_regex is not None:
            outfile.write('escape_regex=model_.EscapeRegexFunctionType(\n')
            self.escape_regex.exportLiteral(outfile, level, name_='escape_regex')
            outfile.write('),\n')
        if self.split is not None:
            outfile.write('split=model_.SplitFunctionType(\n')
            self.split.exportLiteral(outfile, level, name_='split')
            outfile.write('),\n')
        if self.substring is not None:
            outfile.write('substring=model_.SubstringFunctionType(\n')
            self.substring.exportLiteral(outfile, level, name_='substring')
            outfile.write('),\n')
        if self.time_difference is not None:
            outfile.write('time_difference=model_.TimeDifferenceFunctionType(\n')
            self.time_difference.exportLiteral(outfile, level, name_='time_difference')
            outfile.write('),\n')
        if self.regex_capture is not None:
            outfile.write('regex_capture=model_.RegexCaptureFunctionType(\n')
            self.regex_capture.exportLiteral(outfile, level, name_='regex_capture')
            outfile.write('),\n')
        if self.unique is not None:
            outfile.write('unique=model_.UniqueFunctionType(\n')
            self.unique.exportLiteral(outfile, level, name_='unique')
            outfile.write('),\n')
        if self.count is not None:
            outfile.write('count=model_.CountFunctionType(\n')
            self.count.exportLiteral(outfile, level, name_='count')
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'object_component':
            obj_ = ObjectComponentType.factory()
            obj_.build(child_)
            self.set_object_component(obj_)
        elif nodeName_ == 'variable_component':
            obj_ = VariableComponentType.factory()
            obj_.build(child_)
            self.set_variable_component(obj_)
        elif nodeName_ == 'literal_component':
            obj_ = LiteralComponentType.factory()
            obj_.build(child_)
            self.set_literal_component(obj_)
        elif nodeName_ == 'arithmetic':
            obj_ = ArithmeticFunctionType.factory()
            obj_.build(child_)
            self.set_arithmetic(obj_)
        elif nodeName_ == 'begin':
            obj_ = BeginFunctionType.factory()
            obj_.build(child_)
            self.set_begin(obj_)
        elif nodeName_ == 'concat':
            obj_ = ConcatFunctionType.factory()
            obj_.build(child_)
            self.set_concat(obj_)
        elif nodeName_ == 'end':
            obj_ = EndFunctionType.factory()
            obj_.build(child_)
            self.set_end(obj_)
        elif nodeName_ == 'escape_regex':
            obj_ = EscapeRegexFunctionType.factory()
            obj_.build(child_)
            self.set_escape_regex(obj_)
        elif nodeName_ == 'split':
            obj_ = SplitFunctionType.factory()
            obj_.build(child_)
            self.set_split(obj_)
        elif nodeName_ == 'substring':
            obj_ = SubstringFunctionType.factory()
            obj_.build(child_)
            self.set_substring(obj_)
        elif nodeName_ == 'time_difference':
            obj_ = TimeDifferenceFunctionType.factory()
            obj_.build(child_)
            self.set_time_difference(obj_)
        elif nodeName_ == 'regex_capture':
            obj_ = RegexCaptureFunctionType.factory()
            obj_.build(child_)
            self.set_regex_capture(obj_)
        elif nodeName_ == 'unique':
            obj_ = UniqueFunctionType.factory()
            obj_.build(child_)
            self.set_unique(obj_)
        elif nodeName_ == 'count':
            obj_ = CountFunctionType.factory()
            obj_.build(child_)
            self.set_count(obj_)
# end class ConcatFunctionType

class EndFunctionType(GeneratedsSuper):
    """The end function takes a single string component and defines a
    character (or string) that the component string should end with.
    The character attribute defines the specific character (or
    string). The character (or string) is only added to the
    component string if the component string does not already end
    with the specified character (or string). If the desired end
    character is a string, then the entire end string must exist at
    the end if the component string. If the entire end string is not
    present then the entire end string is appended to the component
    string."""
    subclass = None
    superclass = None
    def __init__(self, character=None, object_component=None, variable_component=None, literal_component=None, arithmetic=None, begin=None, concat=None, end=None, escape_regex=None, split=None, substring=None, time_difference=None, regex_capture=None, unique=None, count=None):
        self.character = _cast(None, character)
        self.object_component = object_component
        self.variable_component = variable_component
        self.literal_component = literal_component
        self.arithmetic = arithmetic
        self.begin = begin
        self.concat = concat
        self.end = end
        self.escape_regex = escape_regex
        self.split = split
        self.substring = substring
        self.time_difference = time_difference
        self.regex_capture = regex_capture
        self.unique = unique
        self.count = count
    def factory(*args_, **kwargs_):
        if EndFunctionType.subclass:
            return EndFunctionType.subclass(*args_, **kwargs_)
        else:
            return EndFunctionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_object_component(self): return self.object_component
    def set_object_component(self, object_component): self.object_component = object_component
    def get_variable_component(self): return self.variable_component
    def set_variable_component(self, variable_component): self.variable_component = variable_component
    def get_literal_component(self): return self.literal_component
    def set_literal_component(self, literal_component): self.literal_component = literal_component
    def get_arithmetic(self): return self.arithmetic
    def set_arithmetic(self, arithmetic): self.arithmetic = arithmetic
    def get_begin(self): return self.begin
    def set_begin(self, begin): self.begin = begin
    def get_concat(self): return self.concat
    def set_concat(self, concat): self.concat = concat
    def get_end(self): return self.end
    def set_end(self, end): self.end = end
    def get_escape_regex(self): return self.escape_regex
    def set_escape_regex(self, escape_regex): self.escape_regex = escape_regex
    def get_split(self): return self.split
    def set_split(self, split): self.split = split
    def get_substring(self): return self.substring
    def set_substring(self, substring): self.substring = substring
    def get_time_difference(self): return self.time_difference
    def set_time_difference(self, time_difference): self.time_difference = time_difference
    def get_regex_capture(self): return self.regex_capture
    def set_regex_capture(self, regex_capture): self.regex_capture = regex_capture
    def get_unique(self): return self.unique
    def set_unique(self, unique): self.unique = unique
    def get_count(self): return self.count
    def set_count(self, count): self.count = count
    def get_character(self): return self.character
    def set_character(self, character): self.character = character
    def hasContent_(self):
        if (
            self.object_component is not None or
            self.variable_component is not None or
            self.literal_component is not None or
            self.arithmetic is not None or
            self.begin is not None or
            self.concat is not None or
            self.end is not None or
            self.escape_regex is not None or
            self.split is not None or
            self.substring is not None or
            self.time_difference is not None or
            self.regex_capture is not None or
            self.unique is not None or
            self.count is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='oval-def:', name_='EndFunctionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EndFunctionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='oval-def:', name_='EndFunctionType'):
        if self.character is not None and 'character' not in already_processed:
            already_processed.add('character')
            outfile.write(' character=%s' % (self.gds_format_string(quote_attrib(self.character).encode(ExternalEncoding), input_name='character'), ))
    def exportChildren(self, outfile, level, namespace_='oval-def:', name_='EndFunctionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.object_component is not None:
            self.object_component.export(outfile, level, '', name_='object_component', pretty_print=pretty_print)
        if self.variable_component is not None:
            self.variable_component.export(outfile, level, '', name_='variable_component', pretty_print=pretty_print)
        if self.literal_component is not None:
            self.literal_component.export(outfile, level, '', name_='literal_component', pretty_print=pretty_print)
        if self.arithmetic is not None:
            self.arithmetic.export(outfile, level, '', name_='arithmetic', pretty_print=pretty_print)
        if self.begin is not None:
            self.begin.export(outfile, level, '', name_='begin', pretty_print=pretty_print)
        if self.concat is not None:
            self.concat.export(outfile, level, '', name_='concat', pretty_print=pretty_print)
        if self.end is not None:
            self.end.export(outfile, level, '', name_='end', pretty_print=pretty_print)
        if self.escape_regex is not None:
            self.escape_regex.export(outfile, level, '', name_='escape_regex', pretty_print=pretty_print)
        if self.split is not None:
            self.split.export(outfile, level, '', name_='split', pretty_print=pretty_print)
        if self.substring is not None:
            self.substring.export(outfile, level, '', name_='substring', pretty_print=pretty_print)
        if self.time_difference is not None:
            self.time_difference.export(outfile, level, '', name_='time_difference', pretty_print=pretty_print)
        if self.regex_capture is not None:
            self.regex_capture.export(outfile, level, '', name_='regex_capture', pretty_print=pretty_print)
        if self.unique is not None:
            self.unique.export(outfile, level, '', name_='unique', pretty_print=pretty_print)
        if self.count is not None:
            self.count.export(outfile, level, '', name_='count', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='EndFunctionType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.character is not None and 'character' not in already_processed:
            already_processed.add('character')
            showIndent(outfile, level)
            outfile.write('character = "%s",\n' % (self.character,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.object_component is not None:
            outfile.write('object_component=model_.ObjectComponentType(\n')
            self.object_component.exportLiteral(outfile, level, name_='object_component')
            outfile.write('),\n')
        if self.variable_component is not None:
            outfile.write('variable_component=model_.VariableComponentType(\n')
            self.variable_component.exportLiteral(outfile, level, name_='variable_component')
            outfile.write('),\n')
        if self.literal_component is not None:
            outfile.write('literal_component=model_.LiteralComponentType(\n')
            self.literal_component.exportLiteral(outfile, level, name_='literal_component')
            outfile.write('),\n')
        if self.arithmetic is not None:
            outfile.write('arithmetic=model_.ArithmeticFunctionType(\n')
            self.arithmetic.exportLiteral(outfile, level, name_='arithmetic')
            outfile.write('),\n')
        if self.begin is not None:
            outfile.write('begin=model_.BeginFunctionType(\n')
            self.begin.exportLiteral(outfile, level, name_='begin')
            outfile.write('),\n')
        if self.concat is not None:
            outfile.write('concat=model_.ConcatFunctionType(\n')
            self.concat.exportLiteral(outfile, level, name_='concat')
            outfile.write('),\n')
        if self.end is not None:
            outfile.write('end=model_.EndFunctionType(\n')
            self.end.exportLiteral(outfile, level, name_='end')
            outfile.write('),\n')
        if self.escape_regex is not None:
            outfile.write('escape_regex=model_.EscapeRegexFunctionType(\n')
            self.escape_regex.exportLiteral(outfile, level, name_='escape_regex')
            outfile.write('),\n')
        if self.split is not None:
            outfile.write('split=model_.SplitFunctionType(\n')
            self.split.exportLiteral(outfile, level, name_='split')
            outfile.write('),\n')
        if self.substring is not None:
            outfile.write('substring=model_.SubstringFunctionType(\n')
            self.substring.exportLiteral(outfile, level, name_='substring')
            outfile.write('),\n')
        if self.time_difference is not None:
            outfile.write('time_difference=model_.TimeDifferenceFunctionType(\n')
            self.time_difference.exportLiteral(outfile, level, name_='time_difference')
            outfile.write('),\n')
        if self.regex_capture is not None:
            outfile.write('regex_capture=model_.RegexCaptureFunctionType(\n')
            self.regex_capture.exportLiteral(outfile, level, name_='regex_capture')
            outfile.write('),\n')
        if self.unique is not None:
            outfile.write('unique=model_.UniqueFunctionType(\n')
            self.unique.exportLiteral(outfile, level, name_='unique')
            outfile.write('),\n')
        if self.count is not None:
            outfile.write('count=model_.CountFunctionType(\n')
            self.count.exportLiteral(outfile, level, name_='count')
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('character', node)
        if value is not None and 'character' not in already_processed:
            already_processed.add('character')
            self.character = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'object_component':
            obj_ = ObjectComponentType.factory()
            obj_.build(child_)
            self.set_object_component(obj_)
        elif nodeName_ == 'variable_component':
            obj_ = VariableComponentType.factory()
            obj_.build(child_)
            self.set_variable_component(obj_)
        elif nodeName_ == 'literal_component':
            obj_ = LiteralComponentType.factory()
            obj_.build(child_)
            self.set_literal_component(obj_)
        elif nodeName_ == 'arithmetic':
            obj_ = ArithmeticFunctionType.factory()
            obj_.build(child_)
            self.set_arithmetic(obj_)
        elif nodeName_ == 'begin':
            obj_ = BeginFunctionType.factory()
            obj_.build(child_)
            self.set_begin(obj_)
        elif nodeName_ == 'concat':
            obj_ = ConcatFunctionType.factory()
            obj_.build(child_)
            self.set_concat(obj_)
        elif nodeName_ == 'end':
            obj_ = EndFunctionType.factory()
            obj_.build(child_)
            self.set_end(obj_)
        elif nodeName_ == 'escape_regex':
            obj_ = EscapeRegexFunctionType.factory()
            obj_.build(child_)
            self.set_escape_regex(obj_)
        elif nodeName_ == 'split':
            obj_ = SplitFunctionType.factory()
            obj_.build(child_)
            self.set_split(obj_)
        elif nodeName_ == 'substring':
            obj_ = SubstringFunctionType.factory()
            obj_.build(child_)
            self.set_substring(obj_)
        elif nodeName_ == 'time_difference':
            obj_ = TimeDifferenceFunctionType.factory()
            obj_.build(child_)
            self.set_time_difference(obj_)
        elif nodeName_ == 'regex_capture':
            obj_ = RegexCaptureFunctionType.factory()
            obj_.build(child_)
            self.set_regex_capture(obj_)
        elif nodeName_ == 'unique':
            obj_ = UniqueFunctionType.factory()
            obj_.build(child_)
            self.set_unique(obj_)
        elif nodeName_ == 'count':
            obj_ = CountFunctionType.factory()
            obj_.build(child_)
            self.set_count(obj_)
# end class EndFunctionType

class EscapeRegexFunctionType(GeneratedsSuper):
    """The escape_regex function takes a single string component and
    escapes all of the regular expression characters. For example,
    the string '(\.test_string*)?' will evaluate to
    '\(\\\.test_string\*\)\?'. The purpose for this is that many
    times, a component used in pattern match needs to be treated as
    a literal string and not a regular expression. For example,
    assume a basic component element that identifies a file path
    that is held in the Windows registry. This path is a string that
    might contain regular expression characters. These characters
    are likely not intended to be treated as regular expression
    characters and need to be escaped. This function allows a
    definition writer to mark convert the values of components to
    regular expression format.Note that when using regular
    expressions, OVAL supports a common subset of the regular
    expression character classes, operations, expressions and other
    lexical tokens defined within Perl 5's regular expression
    specification. For more information on the supported regular
    expression syntax in OVAL see:
    http://oval.mitre.org/language/about/re_support_5.6.html."""
    subclass = None
    superclass = None
    def __init__(self, object_component=None, variable_component=None, literal_component=None, arithmetic=None, begin=None, concat=None, end=None, escape_regex=None, split=None, substring=None, time_difference=None, regex_capture=None, unique=None, count=None):
        self.object_component = object_component
        self.variable_component = variable_component
        self.literal_component = literal_component
        self.arithmetic = arithmetic
        self.begin = begin
        self.concat = concat
        self.end = end
        self.escape_regex = escape_regex
        self.split = split
        self.substring = substring
        self.time_difference = time_difference
        self.regex_capture = regex_capture
        self.unique = unique
        self.count = count
    def factory(*args_, **kwargs_):
        if EscapeRegexFunctionType.subclass:
            return EscapeRegexFunctionType.subclass(*args_, **kwargs_)
        else:
            return EscapeRegexFunctionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_object_component(self): return self.object_component
    def set_object_component(self, object_component): self.object_component = object_component
    def get_variable_component(self): return self.variable_component
    def set_variable_component(self, variable_component): self.variable_component = variable_component
    def get_literal_component(self): return self.literal_component
    def set_literal_component(self, literal_component): self.literal_component = literal_component
    def get_arithmetic(self): return self.arithmetic
    def set_arithmetic(self, arithmetic): self.arithmetic = arithmetic
    def get_begin(self): return self.begin
    def set_begin(self, begin): self.begin = begin
    def get_concat(self): return self.concat
    def set_concat(self, concat): self.concat = concat
    def get_end(self): return self.end
    def set_end(self, end): self.end = end
    def get_escape_regex(self): return self.escape_regex
    def set_escape_regex(self, escape_regex): self.escape_regex = escape_regex
    def get_split(self): return self.split
    def set_split(self, split): self.split = split
    def get_substring(self): return self.substring
    def set_substring(self, substring): self.substring = substring
    def get_time_difference(self): return self.time_difference
    def set_time_difference(self, time_difference): self.time_difference = time_difference
    def get_regex_capture(self): return self.regex_capture
    def set_regex_capture(self, regex_capture): self.regex_capture = regex_capture
    def get_unique(self): return self.unique
    def set_unique(self, unique): self.unique = unique
    def get_count(self): return self.count
    def set_count(self, count): self.count = count
    def hasContent_(self):
        if (
            self.object_component is not None or
            self.variable_component is not None or
            self.literal_component is not None or
            self.arithmetic is not None or
            self.begin is not None or
            self.concat is not None or
            self.end is not None or
            self.escape_regex is not None or
            self.split is not None or
            self.substring is not None or
            self.time_difference is not None or
            self.regex_capture is not None or
            self.unique is not None or
            self.count is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='oval-def:', name_='EscapeRegexFunctionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EscapeRegexFunctionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='oval-def:', name_='EscapeRegexFunctionType'):
        pass
    def exportChildren(self, outfile, level, namespace_='oval-def:', name_='EscapeRegexFunctionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.object_component is not None:
            self.object_component.export(outfile, level, '', name_='object_component', pretty_print=pretty_print)
        if self.variable_component is not None:
            self.variable_component.export(outfile, level, '', name_='variable_component', pretty_print=pretty_print)
        if self.literal_component is not None:
            self.literal_component.export(outfile, level, '', name_='literal_component', pretty_print=pretty_print)
        if self.arithmetic is not None:
            self.arithmetic.export(outfile, level, '', name_='arithmetic', pretty_print=pretty_print)
        if self.begin is not None:
            self.begin.export(outfile, level, '', name_='begin', pretty_print=pretty_print)
        if self.concat is not None:
            self.concat.export(outfile, level, '', name_='concat', pretty_print=pretty_print)
        if self.end is not None:
            self.end.export(outfile, level, '', name_='end', pretty_print=pretty_print)
        if self.escape_regex is not None:
            self.escape_regex.export(outfile, level, '', name_='escape_regex', pretty_print=pretty_print)
        if self.split is not None:
            self.split.export(outfile, level, '', name_='split', pretty_print=pretty_print)
        if self.substring is not None:
            self.substring.export(outfile, level, '', name_='substring', pretty_print=pretty_print)
        if self.time_difference is not None:
            self.time_difference.export(outfile, level, '', name_='time_difference', pretty_print=pretty_print)
        if self.regex_capture is not None:
            self.regex_capture.export(outfile, level, '', name_='regex_capture', pretty_print=pretty_print)
        if self.unique is not None:
            self.unique.export(outfile, level, '', name_='unique', pretty_print=pretty_print)
        if self.count is not None:
            self.count.export(outfile, level, '', name_='count', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='EscapeRegexFunctionType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.object_component is not None:
            outfile.write('object_component=model_.ObjectComponentType(\n')
            self.object_component.exportLiteral(outfile, level, name_='object_component')
            outfile.write('),\n')
        if self.variable_component is not None:
            outfile.write('variable_component=model_.VariableComponentType(\n')
            self.variable_component.exportLiteral(outfile, level, name_='variable_component')
            outfile.write('),\n')
        if self.literal_component is not None:
            outfile.write('literal_component=model_.LiteralComponentType(\n')
            self.literal_component.exportLiteral(outfile, level, name_='literal_component')
            outfile.write('),\n')
        if self.arithmetic is not None:
            outfile.write('arithmetic=model_.ArithmeticFunctionType(\n')
            self.arithmetic.exportLiteral(outfile, level, name_='arithmetic')
            outfile.write('),\n')
        if self.begin is not None:
            outfile.write('begin=model_.BeginFunctionType(\n')
            self.begin.exportLiteral(outfile, level, name_='begin')
            outfile.write('),\n')
        if self.concat is not None:
            outfile.write('concat=model_.ConcatFunctionType(\n')
            self.concat.exportLiteral(outfile, level, name_='concat')
            outfile.write('),\n')
        if self.end is not None:
            outfile.write('end=model_.EndFunctionType(\n')
            self.end.exportLiteral(outfile, level, name_='end')
            outfile.write('),\n')
        if self.escape_regex is not None:
            outfile.write('escape_regex=model_.EscapeRegexFunctionType(\n')
            self.escape_regex.exportLiteral(outfile, level, name_='escape_regex')
            outfile.write('),\n')
        if self.split is not None:
            outfile.write('split=model_.SplitFunctionType(\n')
            self.split.exportLiteral(outfile, level, name_='split')
            outfile.write('),\n')
        if self.substring is not None:
            outfile.write('substring=model_.SubstringFunctionType(\n')
            self.substring.exportLiteral(outfile, level, name_='substring')
            outfile.write('),\n')
        if self.time_difference is not None:
            outfile.write('time_difference=model_.TimeDifferenceFunctionType(\n')
            self.time_difference.exportLiteral(outfile, level, name_='time_difference')
            outfile.write('),\n')
        if self.regex_capture is not None:
            outfile.write('regex_capture=model_.RegexCaptureFunctionType(\n')
            self.regex_capture.exportLiteral(outfile, level, name_='regex_capture')
            outfile.write('),\n')
        if self.unique is not None:
            outfile.write('unique=model_.UniqueFunctionType(\n')
            self.unique.exportLiteral(outfile, level, name_='unique')
            outfile.write('),\n')
        if self.count is not None:
            outfile.write('count=model_.CountFunctionType(\n')
            self.count.exportLiteral(outfile, level, name_='count')
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'object_component':
            obj_ = ObjectComponentType.factory()
            obj_.build(child_)
            self.set_object_component(obj_)
        elif nodeName_ == 'variable_component':
            obj_ = VariableComponentType.factory()
            obj_.build(child_)
            self.set_variable_component(obj_)
        elif nodeName_ == 'literal_component':
            obj_ = LiteralComponentType.factory()
            obj_.build(child_)
            self.set_literal_component(obj_)
        elif nodeName_ == 'arithmetic':
            obj_ = ArithmeticFunctionType.factory()
            obj_.build(child_)
            self.set_arithmetic(obj_)
        elif nodeName_ == 'begin':
            obj_ = BeginFunctionType.factory()
            obj_.build(child_)
            self.set_begin(obj_)
        elif nodeName_ == 'concat':
            obj_ = ConcatFunctionType.factory()
            obj_.build(child_)
            self.set_concat(obj_)
        elif nodeName_ == 'end':
            obj_ = EndFunctionType.factory()
            obj_.build(child_)
            self.set_end(obj_)
        elif nodeName_ == 'escape_regex':
            obj_ = EscapeRegexFunctionType.factory()
            obj_.build(child_)
            self.set_escape_regex(obj_)
        elif nodeName_ == 'split':
            obj_ = SplitFunctionType.factory()
            obj_.build(child_)
            self.set_split(obj_)
        elif nodeName_ == 'substring':
            obj_ = SubstringFunctionType.factory()
            obj_.build(child_)
            self.set_substring(obj_)
        elif nodeName_ == 'time_difference':
            obj_ = TimeDifferenceFunctionType.factory()
            obj_.build(child_)
            self.set_time_difference(obj_)
        elif nodeName_ == 'regex_capture':
            obj_ = RegexCaptureFunctionType.factory()
            obj_.build(child_)
            self.set_regex_capture(obj_)
        elif nodeName_ == 'unique':
            obj_ = UniqueFunctionType.factory()
            obj_.build(child_)
            self.set_unique(obj_)
        elif nodeName_ == 'count':
            obj_ = CountFunctionType.factory()
            obj_.build(child_)
            self.set_count(obj_)
# end class EscapeRegexFunctionType

class SplitFunctionType(GeneratedsSuper):
    """The split function takes a single string component and turns it into
    multiple values based on a delimiter string. For example, assume
    that a basic component element returns the value "a-b-c-d" to
    the split function with the delimiter set to "-". The
    local_variable element would be evaluated to have four values
    "a", "b", "c", and "d". If the basic component returns a value
    that begins, or ends, with a delimiter, the local_variable
    element would contain empty string values at the beginning, or
    end, of the set of values returned for that string component.
    For example, if the delimiter is "-", and the basic component
    element returns the value "-a-a-", the local_variable element
    would be evaluated to have four values "", "a", "a", and "".
    Likewise, if the basic component element returns a value that
    contains adjacent delimiters such as "---", the local_variable
    element would be evaluated to have four values "", "", "", and
    "". Lastly, if the basic component element used by the split
    function returns multiple values, then the split function is
    performed multiple times, and all of the results, from each of
    the split functions, are returned."""
    subclass = None
    superclass = None
    def __init__(self, delimiter=None, object_component=None, variable_component=None, literal_component=None, arithmetic=None, begin=None, concat=None, end=None, escape_regex=None, split=None, substring=None, time_difference=None, regex_capture=None, unique=None, count=None):
        self.delimiter = _cast(None, delimiter)
        self.object_component = object_component
        self.variable_component = variable_component
        self.literal_component = literal_component
        self.arithmetic = arithmetic
        self.begin = begin
        self.concat = concat
        self.end = end
        self.escape_regex = escape_regex
        self.split = split
        self.substring = substring
        self.time_difference = time_difference
        self.regex_capture = regex_capture
        self.unique = unique
        self.count = count
    def factory(*args_, **kwargs_):
        if SplitFunctionType.subclass:
            return SplitFunctionType.subclass(*args_, **kwargs_)
        else:
            return SplitFunctionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_object_component(self): return self.object_component
    def set_object_component(self, object_component): self.object_component = object_component
    def get_variable_component(self): return self.variable_component
    def set_variable_component(self, variable_component): self.variable_component = variable_component
    def get_literal_component(self): return self.literal_component
    def set_literal_component(self, literal_component): self.literal_component = literal_component
    def get_arithmetic(self): return self.arithmetic
    def set_arithmetic(self, arithmetic): self.arithmetic = arithmetic
    def get_begin(self): return self.begin
    def set_begin(self, begin): self.begin = begin
    def get_concat(self): return self.concat
    def set_concat(self, concat): self.concat = concat
    def get_end(self): return self.end
    def set_end(self, end): self.end = end
    def get_escape_regex(self): return self.escape_regex
    def set_escape_regex(self, escape_regex): self.escape_regex = escape_regex
    def get_split(self): return self.split
    def set_split(self, split): self.split = split
    def get_substring(self): return self.substring
    def set_substring(self, substring): self.substring = substring
    def get_time_difference(self): return self.time_difference
    def set_time_difference(self, time_difference): self.time_difference = time_difference
    def get_regex_capture(self): return self.regex_capture
    def set_regex_capture(self, regex_capture): self.regex_capture = regex_capture
    def get_unique(self): return self.unique
    def set_unique(self, unique): self.unique = unique
    def get_count(self): return self.count
    def set_count(self, count): self.count = count
    def get_delimiter(self): return self.delimiter
    def set_delimiter(self, delimiter): self.delimiter = delimiter
    def hasContent_(self):
        if (
            self.object_component is not None or
            self.variable_component is not None or
            self.literal_component is not None or
            self.arithmetic is not None or
            self.begin is not None or
            self.concat is not None or
            self.end is not None or
            self.escape_regex is not None or
            self.split is not None or
            self.substring is not None or
            self.time_difference is not None or
            self.regex_capture is not None or
            self.unique is not None or
            self.count is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='oval-def:', name_='SplitFunctionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SplitFunctionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='oval-def:', name_='SplitFunctionType'):
        if self.delimiter is not None and 'delimiter' not in already_processed:
            already_processed.add('delimiter')
            outfile.write(' delimiter=%s' % (self.gds_format_string(quote_attrib(self.delimiter).encode(ExternalEncoding), input_name='delimiter'), ))
    def exportChildren(self, outfile, level, namespace_='oval-def:', name_='SplitFunctionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.object_component is not None:
            self.object_component.export(outfile, level, '', name_='object_component', pretty_print=pretty_print)
        if self.variable_component is not None:
            self.variable_component.export(outfile, level, '', name_='variable_component', pretty_print=pretty_print)
        if self.literal_component is not None:
            self.literal_component.export(outfile, level, '', name_='literal_component', pretty_print=pretty_print)
        if self.arithmetic is not None:
            self.arithmetic.export(outfile, level, '', name_='arithmetic', pretty_print=pretty_print)
        if self.begin is not None:
            self.begin.export(outfile, level, '', name_='begin', pretty_print=pretty_print)
        if self.concat is not None:
            self.concat.export(outfile, level, '', name_='concat', pretty_print=pretty_print)
        if self.end is not None:
            self.end.export(outfile, level, '', name_='end', pretty_print=pretty_print)
        if self.escape_regex is not None:
            self.escape_regex.export(outfile, level, '', name_='escape_regex', pretty_print=pretty_print)
        if self.split is not None:
            self.split.export(outfile, level, '', name_='split', pretty_print=pretty_print)
        if self.substring is not None:
            self.substring.export(outfile, level, '', name_='substring', pretty_print=pretty_print)
        if self.time_difference is not None:
            self.time_difference.export(outfile, level, '', name_='time_difference', pretty_print=pretty_print)
        if self.regex_capture is not None:
            self.regex_capture.export(outfile, level, '', name_='regex_capture', pretty_print=pretty_print)
        if self.unique is not None:
            self.unique.export(outfile, level, '', name_='unique', pretty_print=pretty_print)
        if self.count is not None:
            self.count.export(outfile, level, '', name_='count', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='SplitFunctionType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.delimiter is not None and 'delimiter' not in already_processed:
            already_processed.add('delimiter')
            showIndent(outfile, level)
            outfile.write('delimiter = "%s",\n' % (self.delimiter,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.object_component is not None:
            outfile.write('object_component=model_.ObjectComponentType(\n')
            self.object_component.exportLiteral(outfile, level, name_='object_component')
            outfile.write('),\n')
        if self.variable_component is not None:
            outfile.write('variable_component=model_.VariableComponentType(\n')
            self.variable_component.exportLiteral(outfile, level, name_='variable_component')
            outfile.write('),\n')
        if self.literal_component is not None:
            outfile.write('literal_component=model_.LiteralComponentType(\n')
            self.literal_component.exportLiteral(outfile, level, name_='literal_component')
            outfile.write('),\n')
        if self.arithmetic is not None:
            outfile.write('arithmetic=model_.ArithmeticFunctionType(\n')
            self.arithmetic.exportLiteral(outfile, level, name_='arithmetic')
            outfile.write('),\n')
        if self.begin is not None:
            outfile.write('begin=model_.BeginFunctionType(\n')
            self.begin.exportLiteral(outfile, level, name_='begin')
            outfile.write('),\n')
        if self.concat is not None:
            outfile.write('concat=model_.ConcatFunctionType(\n')
            self.concat.exportLiteral(outfile, level, name_='concat')
            outfile.write('),\n')
        if self.end is not None:
            outfile.write('end=model_.EndFunctionType(\n')
            self.end.exportLiteral(outfile, level, name_='end')
            outfile.write('),\n')
        if self.escape_regex is not None:
            outfile.write('escape_regex=model_.EscapeRegexFunctionType(\n')
            self.escape_regex.exportLiteral(outfile, level, name_='escape_regex')
            outfile.write('),\n')
        if self.split is not None:
            outfile.write('split=model_.SplitFunctionType(\n')
            self.split.exportLiteral(outfile, level, name_='split')
            outfile.write('),\n')
        if self.substring is not None:
            outfile.write('substring=model_.SubstringFunctionType(\n')
            self.substring.exportLiteral(outfile, level, name_='substring')
            outfile.write('),\n')
        if self.time_difference is not None:
            outfile.write('time_difference=model_.TimeDifferenceFunctionType(\n')
            self.time_difference.exportLiteral(outfile, level, name_='time_difference')
            outfile.write('),\n')
        if self.regex_capture is not None:
            outfile.write('regex_capture=model_.RegexCaptureFunctionType(\n')
            self.regex_capture.exportLiteral(outfile, level, name_='regex_capture')
            outfile.write('),\n')
        if self.unique is not None:
            outfile.write('unique=model_.UniqueFunctionType(\n')
            self.unique.exportLiteral(outfile, level, name_='unique')
            outfile.write('),\n')
        if self.count is not None:
            outfile.write('count=model_.CountFunctionType(\n')
            self.count.exportLiteral(outfile, level, name_='count')
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('delimiter', node)
        if value is not None and 'delimiter' not in already_processed:
            already_processed.add('delimiter')
            self.delimiter = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'object_component':
            obj_ = ObjectComponentType.factory()
            obj_.build(child_)
            self.set_object_component(obj_)
        elif nodeName_ == 'variable_component':
            obj_ = VariableComponentType.factory()
            obj_.build(child_)
            self.set_variable_component(obj_)
        elif nodeName_ == 'literal_component':
            obj_ = LiteralComponentType.factory()
            obj_.build(child_)
            self.set_literal_component(obj_)
        elif nodeName_ == 'arithmetic':
            obj_ = ArithmeticFunctionType.factory()
            obj_.build(child_)
            self.set_arithmetic(obj_)
        elif nodeName_ == 'begin':
            obj_ = BeginFunctionType.factory()
            obj_.build(child_)
            self.set_begin(obj_)
        elif nodeName_ == 'concat':
            obj_ = ConcatFunctionType.factory()
            obj_.build(child_)
            self.set_concat(obj_)
        elif nodeName_ == 'end':
            obj_ = EndFunctionType.factory()
            obj_.build(child_)
            self.set_end(obj_)
        elif nodeName_ == 'escape_regex':
            obj_ = EscapeRegexFunctionType.factory()
            obj_.build(child_)
            self.set_escape_regex(obj_)
        elif nodeName_ == 'split':
            obj_ = SplitFunctionType.factory()
            obj_.build(child_)
            self.set_split(obj_)
        elif nodeName_ == 'substring':
            obj_ = SubstringFunctionType.factory()
            obj_.build(child_)
            self.set_substring(obj_)
        elif nodeName_ == 'time_difference':
            obj_ = TimeDifferenceFunctionType.factory()
            obj_.build(child_)
            self.set_time_difference(obj_)
        elif nodeName_ == 'regex_capture':
            obj_ = RegexCaptureFunctionType.factory()
            obj_.build(child_)
            self.set_regex_capture(obj_)
        elif nodeName_ == 'unique':
            obj_ = UniqueFunctionType.factory()
            obj_.build(child_)
            self.set_unique(obj_)
        elif nodeName_ == 'count':
            obj_ = CountFunctionType.factory()
            obj_.build(child_)
            self.set_count(obj_)
# end class SplitFunctionType

class SubstringFunctionType(GeneratedsSuper):
    """The substring function takes a single string component and produces
    a single value that contains a portion of the original string.
    The substring_start attribute defines the starting position in
    the original string. To include the first character of the
    string, the start position would be 1. A value less than 1 also
    means that the start position would be 1. If the substring_start
    attribute has value greater than the length of the original
    string an error should be reported. The substring_length
    attribute defines how many characters after, and including, the
    starting character to include. A substring_length value greater
    than the actual length of the string, or a negative value, means
    to include all of the characters after the starting character.
    For example, assume a basic component element that returns the
    value "abcdefg" with a substring_start value of 3 and a
    substring_length value of 2. The local_variable element would
    evaluate to have a single value of "cd". If the string component
    used by the substring function returns multiple values, then the
    substring operation is performed multiple times and results in
    multiple values for the component."""
    subclass = None
    superclass = None
    def __init__(self, substring_length=None, substring_start=None, object_component=None, variable_component=None, literal_component=None, arithmetic=None, begin=None, concat=None, end=None, escape_regex=None, split=None, substring=None, time_difference=None, regex_capture=None, unique=None, count=None):
        self.substring_length = _cast(int, substring_length)
        self.substring_start = _cast(int, substring_start)
        self.object_component = object_component
        self.variable_component = variable_component
        self.literal_component = literal_component
        self.arithmetic = arithmetic
        self.begin = begin
        self.concat = concat
        self.end = end
        self.escape_regex = escape_regex
        self.split = split
        self.substring = substring
        self.time_difference = time_difference
        self.regex_capture = regex_capture
        self.unique = unique
        self.count = count
    def factory(*args_, **kwargs_):
        if SubstringFunctionType.subclass:
            return SubstringFunctionType.subclass(*args_, **kwargs_)
        else:
            return SubstringFunctionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_object_component(self): return self.object_component
    def set_object_component(self, object_component): self.object_component = object_component
    def get_variable_component(self): return self.variable_component
    def set_variable_component(self, variable_component): self.variable_component = variable_component
    def get_literal_component(self): return self.literal_component
    def set_literal_component(self, literal_component): self.literal_component = literal_component
    def get_arithmetic(self): return self.arithmetic
    def set_arithmetic(self, arithmetic): self.arithmetic = arithmetic
    def get_begin(self): return self.begin
    def set_begin(self, begin): self.begin = begin
    def get_concat(self): return self.concat
    def set_concat(self, concat): self.concat = concat
    def get_end(self): return self.end
    def set_end(self, end): self.end = end
    def get_escape_regex(self): return self.escape_regex
    def set_escape_regex(self, escape_regex): self.escape_regex = escape_regex
    def get_split(self): return self.split
    def set_split(self, split): self.split = split
    def get_substring(self): return self.substring
    def set_substring(self, substring): self.substring = substring
    def get_time_difference(self): return self.time_difference
    def set_time_difference(self, time_difference): self.time_difference = time_difference
    def get_regex_capture(self): return self.regex_capture
    def set_regex_capture(self, regex_capture): self.regex_capture = regex_capture
    def get_unique(self): return self.unique
    def set_unique(self, unique): self.unique = unique
    def get_count(self): return self.count
    def set_count(self, count): self.count = count
    def get_substring_length(self): return self.substring_length
    def set_substring_length(self, substring_length): self.substring_length = substring_length
    def get_substring_start(self): return self.substring_start
    def set_substring_start(self, substring_start): self.substring_start = substring_start
    def hasContent_(self):
        if (
            self.object_component is not None or
            self.variable_component is not None or
            self.literal_component is not None or
            self.arithmetic is not None or
            self.begin is not None or
            self.concat is not None or
            self.end is not None or
            self.escape_regex is not None or
            self.split is not None or
            self.substring is not None or
            self.time_difference is not None or
            self.regex_capture is not None or
            self.unique is not None or
            self.count is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='oval-def:', name_='SubstringFunctionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SubstringFunctionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='oval-def:', name_='SubstringFunctionType'):
        if self.substring_length is not None and 'substring_length' not in already_processed:
            already_processed.add('substring_length')
            outfile.write(' substring_length="%s"' % self.gds_format_integer(self.substring_length, input_name='substring_length'))
        if self.substring_start is not None and 'substring_start' not in already_processed:
            already_processed.add('substring_start')
            outfile.write(' substring_start="%s"' % self.gds_format_integer(self.substring_start, input_name='substring_start'))
    def exportChildren(self, outfile, level, namespace_='oval-def:', name_='SubstringFunctionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.object_component is not None:
            self.object_component.export(outfile, level, '', name_='object_component', pretty_print=pretty_print)
        if self.variable_component is not None:
            self.variable_component.export(outfile, level, '', name_='variable_component', pretty_print=pretty_print)
        if self.literal_component is not None:
            self.literal_component.export(outfile, level, '', name_='literal_component', pretty_print=pretty_print)
        if self.arithmetic is not None:
            self.arithmetic.export(outfile, level, '', name_='arithmetic', pretty_print=pretty_print)
        if self.begin is not None:
            self.begin.export(outfile, level, '', name_='begin', pretty_print=pretty_print)
        if self.concat is not None:
            self.concat.export(outfile, level, '', name_='concat', pretty_print=pretty_print)
        if self.end is not None:
            self.end.export(outfile, level, '', name_='end', pretty_print=pretty_print)
        if self.escape_regex is not None:
            self.escape_regex.export(outfile, level, '', name_='escape_regex', pretty_print=pretty_print)
        if self.split is not None:
            self.split.export(outfile, level, '', name_='split', pretty_print=pretty_print)
        if self.substring is not None:
            self.substring.export(outfile, level, '', name_='substring', pretty_print=pretty_print)
        if self.time_difference is not None:
            self.time_difference.export(outfile, level, '', name_='time_difference', pretty_print=pretty_print)
        if self.regex_capture is not None:
            self.regex_capture.export(outfile, level, '', name_='regex_capture', pretty_print=pretty_print)
        if self.unique is not None:
            self.unique.export(outfile, level, '', name_='unique', pretty_print=pretty_print)
        if self.count is not None:
            self.count.export(outfile, level, '', name_='count', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='SubstringFunctionType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.substring_length is not None and 'substring_length' not in already_processed:
            already_processed.add('substring_length')
            showIndent(outfile, level)
            outfile.write('substring_length = %d,\n' % (self.substring_length,))
        if self.substring_start is not None and 'substring_start' not in already_processed:
            already_processed.add('substring_start')
            showIndent(outfile, level)
            outfile.write('substring_start = %d,\n' % (self.substring_start,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.object_component is not None:
            outfile.write('object_component=model_.ObjectComponentType(\n')
            self.object_component.exportLiteral(outfile, level, name_='object_component')
            outfile.write('),\n')
        if self.variable_component is not None:
            outfile.write('variable_component=model_.VariableComponentType(\n')
            self.variable_component.exportLiteral(outfile, level, name_='variable_component')
            outfile.write('),\n')
        if self.literal_component is not None:
            outfile.write('literal_component=model_.LiteralComponentType(\n')
            self.literal_component.exportLiteral(outfile, level, name_='literal_component')
            outfile.write('),\n')
        if self.arithmetic is not None:
            outfile.write('arithmetic=model_.ArithmeticFunctionType(\n')
            self.arithmetic.exportLiteral(outfile, level, name_='arithmetic')
            outfile.write('),\n')
        if self.begin is not None:
            outfile.write('begin=model_.BeginFunctionType(\n')
            self.begin.exportLiteral(outfile, level, name_='begin')
            outfile.write('),\n')
        if self.concat is not None:
            outfile.write('concat=model_.ConcatFunctionType(\n')
            self.concat.exportLiteral(outfile, level, name_='concat')
            outfile.write('),\n')
        if self.end is not None:
            outfile.write('end=model_.EndFunctionType(\n')
            self.end.exportLiteral(outfile, level, name_='end')
            outfile.write('),\n')
        if self.escape_regex is not None:
            outfile.write('escape_regex=model_.EscapeRegexFunctionType(\n')
            self.escape_regex.exportLiteral(outfile, level, name_='escape_regex')
            outfile.write('),\n')
        if self.split is not None:
            outfile.write('split=model_.SplitFunctionType(\n')
            self.split.exportLiteral(outfile, level, name_='split')
            outfile.write('),\n')
        if self.substring is not None:
            outfile.write('substring=model_.SubstringFunctionType(\n')
            self.substring.exportLiteral(outfile, level, name_='substring')
            outfile.write('),\n')
        if self.time_difference is not None:
            outfile.write('time_difference=model_.TimeDifferenceFunctionType(\n')
            self.time_difference.exportLiteral(outfile, level, name_='time_difference')
            outfile.write('),\n')
        if self.regex_capture is not None:
            outfile.write('regex_capture=model_.RegexCaptureFunctionType(\n')
            self.regex_capture.exportLiteral(outfile, level, name_='regex_capture')
            outfile.write('),\n')
        if self.unique is not None:
            outfile.write('unique=model_.UniqueFunctionType(\n')
            self.unique.exportLiteral(outfile, level, name_='unique')
            outfile.write('),\n')
        if self.count is not None:
            outfile.write('count=model_.CountFunctionType(\n')
            self.count.exportLiteral(outfile, level, name_='count')
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('substring_length', node)
        if value is not None and 'substring_length' not in already_processed:
            already_processed.add('substring_length')
            try:
                self.substring_length = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('substring_start', node)
        if value is not None and 'substring_start' not in already_processed:
            already_processed.add('substring_start')
            try:
                self.substring_start = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'object_component':
            obj_ = ObjectComponentType.factory()
            obj_.build(child_)
            self.set_object_component(obj_)
        elif nodeName_ == 'variable_component':
            obj_ = VariableComponentType.factory()
            obj_.build(child_)
            self.set_variable_component(obj_)
        elif nodeName_ == 'literal_component':
            obj_ = LiteralComponentType.factory()
            obj_.build(child_)
            self.set_literal_component(obj_)
        elif nodeName_ == 'arithmetic':
            obj_ = ArithmeticFunctionType.factory()
            obj_.build(child_)
            self.set_arithmetic(obj_)
        elif nodeName_ == 'begin':
            obj_ = BeginFunctionType.factory()
            obj_.build(child_)
            self.set_begin(obj_)
        elif nodeName_ == 'concat':
            obj_ = ConcatFunctionType.factory()
            obj_.build(child_)
            self.set_concat(obj_)
        elif nodeName_ == 'end':
            obj_ = EndFunctionType.factory()
            obj_.build(child_)
            self.set_end(obj_)
        elif nodeName_ == 'escape_regex':
            obj_ = EscapeRegexFunctionType.factory()
            obj_.build(child_)
            self.set_escape_regex(obj_)
        elif nodeName_ == 'split':
            obj_ = SplitFunctionType.factory()
            obj_.build(child_)
            self.set_split(obj_)
        elif nodeName_ == 'substring':
            obj_ = SubstringFunctionType.factory()
            obj_.build(child_)
            self.set_substring(obj_)
        elif nodeName_ == 'time_difference':
            obj_ = TimeDifferenceFunctionType.factory()
            obj_.build(child_)
            self.set_time_difference(obj_)
        elif nodeName_ == 'regex_capture':
            obj_ = RegexCaptureFunctionType.factory()
            obj_.build(child_)
            self.set_regex_capture(obj_)
        elif nodeName_ == 'unique':
            obj_ = UniqueFunctionType.factory()
            obj_.build(child_)
            self.set_unique(obj_)
        elif nodeName_ == 'count':
            obj_ = CountFunctionType.factory()
            obj_.build(child_)
            self.set_count(obj_)
# end class SubstringFunctionType

class TimeDifferenceFunctionType(GeneratedsSuper):
    """The time_difference function calculates the difference in seconds
    between date-time values. If one component is specified, the
    values of that component are subtracted from the current time
    (UTC). If two components are specified, the value of the second
    component is subtracted from the value of the first component.
    If the component(s) contain multiple values, the operation is
    performed multiple times on the Cartesian product of the
    component(s) and the result is an array of time difference
    values. For example, assume a local_variable specifies the
    time_difference function and has two sub-components under this
    function: the first component returns multiple values
    "04/02/2009" and "04/03/2009", and the second component returns
    multiple values "02/02/2005" and "02/03/2005" and "02/04/2005".
    The local_variable element would be evaluated to have six
    values: (ToSeconds("04/02/2009") - ToSeconds("02/02/2005")),
    (ToSeconds("04/02/2009") - ToSeconds("02/03/2005")),
    (ToSeconds("04/02/2009") - ToSeconds("02/04/2005")),
    (ToSeconds("04/03/2009") - ToSeconds("02/02/2005")),
    (ToSeconds("04/03/2009") - ToSeconds("02/03/2005")), and
    (ToSeconds("04/03/2009") - ToSeconds("02/04/2005")).The date-
    time format of each component is determined by the two format
    attributes. The format1 attribute applies to the first
    component, and the format2 attribute applies to the second
    component. Valid values for the attributes are 'win_filetime',
    'seconds_since_epoch', 'day_month_year', 'year_month_day', and
    'month_day_year'. Please see the DateTimeFormatEnumeration for
    more information about each of these values. If an input value
    is not understood, the result is an error. If only one input is
    specified, specify the format with the format2 attribute, as the
    first input is considered to be the implied 'current time'
    input.Note that the datatype associated with the components
    should be 'string' or 'int' depending on which date time format
    is specified. The result of this function though is always an
    integer."""
    subclass = None
    superclass = None
    def __init__(self, format_1='year_month_day', format_2='year_month_day', object_component=None, variable_component=None, literal_component=None, arithmetic=None, begin=None, concat=None, end=None, escape_regex=None, split=None, substring=None, time_difference=None, regex_capture=None, unique=None, count=None):
        self.format_1 = _cast(None, format_1)
        self.format_2 = _cast(None, format_2)
        self.object_component = object_component
        self.variable_component = variable_component
        self.literal_component = literal_component
        self.arithmetic = arithmetic
        self.begin = begin
        self.concat = concat
        self.end = end
        self.escape_regex = escape_regex
        self.split = split
        self.substring = substring
        self.time_difference = time_difference
        self.regex_capture = regex_capture
        self.unique = unique
        self.count = count
    def factory(*args_, **kwargs_):
        if TimeDifferenceFunctionType.subclass:
            return TimeDifferenceFunctionType.subclass(*args_, **kwargs_)
        else:
            return TimeDifferenceFunctionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_object_component(self): return self.object_component
    def set_object_component(self, object_component): self.object_component = object_component
    def get_variable_component(self): return self.variable_component
    def set_variable_component(self, variable_component): self.variable_component = variable_component
    def get_literal_component(self): return self.literal_component
    def set_literal_component(self, literal_component): self.literal_component = literal_component
    def get_arithmetic(self): return self.arithmetic
    def set_arithmetic(self, arithmetic): self.arithmetic = arithmetic
    def get_begin(self): return self.begin
    def set_begin(self, begin): self.begin = begin
    def get_concat(self): return self.concat
    def set_concat(self, concat): self.concat = concat
    def get_end(self): return self.end
    def set_end(self, end): self.end = end
    def get_escape_regex(self): return self.escape_regex
    def set_escape_regex(self, escape_regex): self.escape_regex = escape_regex
    def get_split(self): return self.split
    def set_split(self, split): self.split = split
    def get_substring(self): return self.substring
    def set_substring(self, substring): self.substring = substring
    def get_time_difference(self): return self.time_difference
    def set_time_difference(self, time_difference): self.time_difference = time_difference
    def get_regex_capture(self): return self.regex_capture
    def set_regex_capture(self, regex_capture): self.regex_capture = regex_capture
    def get_unique(self): return self.unique
    def set_unique(self, unique): self.unique = unique
    def get_count(self): return self.count
    def set_count(self, count): self.count = count
    def get_format_1(self): return self.format_1
    def set_format_1(self, format_1): self.format_1 = format_1
    def get_format_2(self): return self.format_2
    def set_format_2(self, format_2): self.format_2 = format_2
    def hasContent_(self):
        if (
            self.object_component is not None or
            self.variable_component is not None or
            self.literal_component is not None or
            self.arithmetic is not None or
            self.begin is not None or
            self.concat is not None or
            self.end is not None or
            self.escape_regex is not None or
            self.split is not None or
            self.substring is not None or
            self.time_difference is not None or
            self.regex_capture is not None or
            self.unique is not None or
            self.count is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='oval-def:', name_='TimeDifferenceFunctionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TimeDifferenceFunctionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='oval-def:', name_='TimeDifferenceFunctionType'):
        if self.format_1 is not None and 'format_1' not in already_processed:
            already_processed.add('format_1')
            outfile.write(' format_1=%s' % (quote_attrib(self.format_1), ))
        if self.format_2 is not None and 'format_2' not in already_processed:
            already_processed.add('format_2')
            outfile.write(' format_2=%s' % (quote_attrib(self.format_2), ))
    def exportChildren(self, outfile, level, namespace_='oval-def:', name_='TimeDifferenceFunctionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.object_component is not None:
            self.object_component.export(outfile, level, '', name_='object_component', pretty_print=pretty_print)
        if self.variable_component is not None:
            self.variable_component.export(outfile, level, '', name_='variable_component', pretty_print=pretty_print)
        if self.literal_component is not None:
            self.literal_component.export(outfile, level, '', name_='literal_component', pretty_print=pretty_print)
        if self.arithmetic is not None:
            self.arithmetic.export(outfile, level, '', name_='arithmetic', pretty_print=pretty_print)
        if self.begin is not None:
            self.begin.export(outfile, level, '', name_='begin', pretty_print=pretty_print)
        if self.concat is not None:
            self.concat.export(outfile, level, '', name_='concat', pretty_print=pretty_print)
        if self.end is not None:
            self.end.export(outfile, level, '', name_='end', pretty_print=pretty_print)
        if self.escape_regex is not None:
            self.escape_regex.export(outfile, level, '', name_='escape_regex', pretty_print=pretty_print)
        if self.split is not None:
            self.split.export(outfile, level, '', name_='split', pretty_print=pretty_print)
        if self.substring is not None:
            self.substring.export(outfile, level, '', name_='substring', pretty_print=pretty_print)
        if self.time_difference is not None:
            self.time_difference.export(outfile, level, '', name_='time_difference', pretty_print=pretty_print)
        if self.regex_capture is not None:
            self.regex_capture.export(outfile, level, '', name_='regex_capture', pretty_print=pretty_print)
        if self.unique is not None:
            self.unique.export(outfile, level, '', name_='unique', pretty_print=pretty_print)
        if self.count is not None:
            self.count.export(outfile, level, '', name_='count', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='TimeDifferenceFunctionType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.format_1 is not None and 'format_1' not in already_processed:
            already_processed.add('format_1')
            showIndent(outfile, level)
            outfile.write('format_1 = %s,\n' % (self.format_1,))
        if self.format_2 is not None and 'format_2' not in already_processed:
            already_processed.add('format_2')
            showIndent(outfile, level)
            outfile.write('format_2 = %s,\n' % (self.format_2,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.object_component is not None:
            outfile.write('object_component=model_.ObjectComponentType(\n')
            self.object_component.exportLiteral(outfile, level, name_='object_component')
            outfile.write('),\n')
        if self.variable_component is not None:
            outfile.write('variable_component=model_.VariableComponentType(\n')
            self.variable_component.exportLiteral(outfile, level, name_='variable_component')
            outfile.write('),\n')
        if self.literal_component is not None:
            outfile.write('literal_component=model_.LiteralComponentType(\n')
            self.literal_component.exportLiteral(outfile, level, name_='literal_component')
            outfile.write('),\n')
        if self.arithmetic is not None:
            outfile.write('arithmetic=model_.ArithmeticFunctionType(\n')
            self.arithmetic.exportLiteral(outfile, level, name_='arithmetic')
            outfile.write('),\n')
        if self.begin is not None:
            outfile.write('begin=model_.BeginFunctionType(\n')
            self.begin.exportLiteral(outfile, level, name_='begin')
            outfile.write('),\n')
        if self.concat is not None:
            outfile.write('concat=model_.ConcatFunctionType(\n')
            self.concat.exportLiteral(outfile, level, name_='concat')
            outfile.write('),\n')
        if self.end is not None:
            outfile.write('end=model_.EndFunctionType(\n')
            self.end.exportLiteral(outfile, level, name_='end')
            outfile.write('),\n')
        if self.escape_regex is not None:
            outfile.write('escape_regex=model_.EscapeRegexFunctionType(\n')
            self.escape_regex.exportLiteral(outfile, level, name_='escape_regex')
            outfile.write('),\n')
        if self.split is not None:
            outfile.write('split=model_.SplitFunctionType(\n')
            self.split.exportLiteral(outfile, level, name_='split')
            outfile.write('),\n')
        if self.substring is not None:
            outfile.write('substring=model_.SubstringFunctionType(\n')
            self.substring.exportLiteral(outfile, level, name_='substring')
            outfile.write('),\n')
        if self.time_difference is not None:
            outfile.write('time_difference=model_.TimeDifferenceFunctionType(\n')
            self.time_difference.exportLiteral(outfile, level, name_='time_difference')
            outfile.write('),\n')
        if self.regex_capture is not None:
            outfile.write('regex_capture=model_.RegexCaptureFunctionType(\n')
            self.regex_capture.exportLiteral(outfile, level, name_='regex_capture')
            outfile.write('),\n')
        if self.unique is not None:
            outfile.write('unique=model_.UniqueFunctionType(\n')
            self.unique.exportLiteral(outfile, level, name_='unique')
            outfile.write('),\n')
        if self.count is not None:
            outfile.write('count=model_.CountFunctionType(\n')
            self.count.exportLiteral(outfile, level, name_='count')
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('format_1', node)
        if value is not None and 'format_1' not in already_processed:
            already_processed.add('format_1')
            self.format_1 = value
        value = find_attr_value_('format_2', node)
        if value is not None and 'format_2' not in already_processed:
            already_processed.add('format_2')
            self.format_2 = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'object_component':
            obj_ = ObjectComponentType.factory()
            obj_.build(child_)
            self.set_object_component(obj_)
        elif nodeName_ == 'variable_component':
            obj_ = VariableComponentType.factory()
            obj_.build(child_)
            self.set_variable_component(obj_)
        elif nodeName_ == 'literal_component':
            obj_ = LiteralComponentType.factory()
            obj_.build(child_)
            self.set_literal_component(obj_)
        elif nodeName_ == 'arithmetic':
            obj_ = ArithmeticFunctionType.factory()
            obj_.build(child_)
            self.set_arithmetic(obj_)
        elif nodeName_ == 'begin':
            obj_ = BeginFunctionType.factory()
            obj_.build(child_)
            self.set_begin(obj_)
        elif nodeName_ == 'concat':
            obj_ = ConcatFunctionType.factory()
            obj_.build(child_)
            self.set_concat(obj_)
        elif nodeName_ == 'end':
            obj_ = EndFunctionType.factory()
            obj_.build(child_)
            self.set_end(obj_)
        elif nodeName_ == 'escape_regex':
            obj_ = EscapeRegexFunctionType.factory()
            obj_.build(child_)
            self.set_escape_regex(obj_)
        elif nodeName_ == 'split':
            obj_ = SplitFunctionType.factory()
            obj_.build(child_)
            self.set_split(obj_)
        elif nodeName_ == 'substring':
            obj_ = SubstringFunctionType.factory()
            obj_.build(child_)
            self.set_substring(obj_)
        elif nodeName_ == 'time_difference':
            obj_ = TimeDifferenceFunctionType.factory()
            obj_.build(child_)
            self.set_time_difference(obj_)
        elif nodeName_ == 'regex_capture':
            obj_ = RegexCaptureFunctionType.factory()
            obj_.build(child_)
            self.set_regex_capture(obj_)
        elif nodeName_ == 'unique':
            obj_ = UniqueFunctionType.factory()
            obj_.build(child_)
            self.set_unique(obj_)
        elif nodeName_ == 'count':
            obj_ = CountFunctionType.factory()
            obj_.build(child_)
            self.set_count(obj_)
# end class TimeDifferenceFunctionType

class RegexCaptureFunctionType(GeneratedsSuper):
    """The regex_capture function captures a single substring from a string
    component. The 'pattern' attribute provides a regular expression
    that must contain a single subexpression (using parentheses).
    The first match of the subexpression is considered the captured
    substring. For example, the pattern ^abc(.*)xyz$ would capture a
    substring from each of the string component's values if the
    value starts with abc and ends with xyz. In this case the
    subexpression would be all the characters that exist in between
    the abc and the xyz. If more than one subexpression is supplied
    only the first match is considered. If more than one match is
    identified by a single subexpression only the first match is
    considered. If no matches are found or a subexpression is not
    supplied the function will evaluate to an empty string. Note
    that subexpressions match the longest possible substrings.Note
    that when using regular expressions, OVAL supports a common
    subset of the regular expression character classes, operations,
    expressions and other lexical tokens defined within Perl 5's
    regular expression specification. For more information on the
    supported regular expression syntax in OVAL see:
    http://oval.mitre.org/language/about/re_support_5.6.html."""
    subclass = None
    superclass = None
    def __init__(self, pattern=None, object_component=None, variable_component=None, literal_component=None, arithmetic=None, begin=None, concat=None, end=None, escape_regex=None, split=None, substring=None, time_difference=None, regex_capture=None, unique=None, count=None):
        self.pattern = _cast(None, pattern)
        self.object_component = object_component
        self.variable_component = variable_component
        self.literal_component = literal_component
        self.arithmetic = arithmetic
        self.begin = begin
        self.concat = concat
        self.end = end
        self.escape_regex = escape_regex
        self.split = split
        self.substring = substring
        self.time_difference = time_difference
        self.regex_capture = regex_capture
        self.unique = unique
        self.count = count
    def factory(*args_, **kwargs_):
        if RegexCaptureFunctionType.subclass:
            return RegexCaptureFunctionType.subclass(*args_, **kwargs_)
        else:
            return RegexCaptureFunctionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_object_component(self): return self.object_component
    def set_object_component(self, object_component): self.object_component = object_component
    def get_variable_component(self): return self.variable_component
    def set_variable_component(self, variable_component): self.variable_component = variable_component
    def get_literal_component(self): return self.literal_component
    def set_literal_component(self, literal_component): self.literal_component = literal_component
    def get_arithmetic(self): return self.arithmetic
    def set_arithmetic(self, arithmetic): self.arithmetic = arithmetic
    def get_begin(self): return self.begin
    def set_begin(self, begin): self.begin = begin
    def get_concat(self): return self.concat
    def set_concat(self, concat): self.concat = concat
    def get_end(self): return self.end
    def set_end(self, end): self.end = end
    def get_escape_regex(self): return self.escape_regex
    def set_escape_regex(self, escape_regex): self.escape_regex = escape_regex
    def get_split(self): return self.split
    def set_split(self, split): self.split = split
    def get_substring(self): return self.substring
    def set_substring(self, substring): self.substring = substring
    def get_time_difference(self): return self.time_difference
    def set_time_difference(self, time_difference): self.time_difference = time_difference
    def get_regex_capture(self): return self.regex_capture
    def set_regex_capture(self, regex_capture): self.regex_capture = regex_capture
    def get_unique(self): return self.unique
    def set_unique(self, unique): self.unique = unique
    def get_count(self): return self.count
    def set_count(self, count): self.count = count
    def get_pattern(self): return self.pattern
    def set_pattern(self, pattern): self.pattern = pattern
    def hasContent_(self):
        if (
            self.object_component is not None or
            self.variable_component is not None or
            self.literal_component is not None or
            self.arithmetic is not None or
            self.begin is not None or
            self.concat is not None or
            self.end is not None or
            self.escape_regex is not None or
            self.split is not None or
            self.substring is not None or
            self.time_difference is not None or
            self.regex_capture is not None or
            self.unique is not None or
            self.count is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='oval-def:', name_='RegexCaptureFunctionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RegexCaptureFunctionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='oval-def:', name_='RegexCaptureFunctionType'):
        if self.pattern is not None and 'pattern' not in already_processed:
            already_processed.add('pattern')
            outfile.write(' pattern=%s' % (self.gds_format_string(quote_attrib(self.pattern).encode(ExternalEncoding), input_name='pattern'), ))
    def exportChildren(self, outfile, level, namespace_='oval-def:', name_='RegexCaptureFunctionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.object_component is not None:
            self.object_component.export(outfile, level, '', name_='object_component', pretty_print=pretty_print)
        if self.variable_component is not None:
            self.variable_component.export(outfile, level, '', name_='variable_component', pretty_print=pretty_print)
        if self.literal_component is not None:
            self.literal_component.export(outfile, level, '', name_='literal_component', pretty_print=pretty_print)
        if self.arithmetic is not None:
            self.arithmetic.export(outfile, level, '', name_='arithmetic', pretty_print=pretty_print)
        if self.begin is not None:
            self.begin.export(outfile, level, '', name_='begin', pretty_print=pretty_print)
        if self.concat is not None:
            self.concat.export(outfile, level, '', name_='concat', pretty_print=pretty_print)
        if self.end is not None:
            self.end.export(outfile, level, '', name_='end', pretty_print=pretty_print)
        if self.escape_regex is not None:
            self.escape_regex.export(outfile, level, '', name_='escape_regex', pretty_print=pretty_print)
        if self.split is not None:
            self.split.export(outfile, level, '', name_='split', pretty_print=pretty_print)
        if self.substring is not None:
            self.substring.export(outfile, level, '', name_='substring', pretty_print=pretty_print)
        if self.time_difference is not None:
            self.time_difference.export(outfile, level, '', name_='time_difference', pretty_print=pretty_print)
        if self.regex_capture is not None:
            self.regex_capture.export(outfile, level, '', name_='regex_capture', pretty_print=pretty_print)
        if self.unique is not None:
            self.unique.export(outfile, level, '', name_='unique', pretty_print=pretty_print)
        if self.count is not None:
            self.count.export(outfile, level, '', name_='count', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='RegexCaptureFunctionType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.pattern is not None and 'pattern' not in already_processed:
            already_processed.add('pattern')
            showIndent(outfile, level)
            outfile.write('pattern = "%s",\n' % (self.pattern,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.object_component is not None:
            outfile.write('object_component=model_.ObjectComponentType(\n')
            self.object_component.exportLiteral(outfile, level, name_='object_component')
            outfile.write('),\n')
        if self.variable_component is not None:
            outfile.write('variable_component=model_.VariableComponentType(\n')
            self.variable_component.exportLiteral(outfile, level, name_='variable_component')
            outfile.write('),\n')
        if self.literal_component is not None:
            outfile.write('literal_component=model_.LiteralComponentType(\n')
            self.literal_component.exportLiteral(outfile, level, name_='literal_component')
            outfile.write('),\n')
        if self.arithmetic is not None:
            outfile.write('arithmetic=model_.ArithmeticFunctionType(\n')
            self.arithmetic.exportLiteral(outfile, level, name_='arithmetic')
            outfile.write('),\n')
        if self.begin is not None:
            outfile.write('begin=model_.BeginFunctionType(\n')
            self.begin.exportLiteral(outfile, level, name_='begin')
            outfile.write('),\n')
        if self.concat is not None:
            outfile.write('concat=model_.ConcatFunctionType(\n')
            self.concat.exportLiteral(outfile, level, name_='concat')
            outfile.write('),\n')
        if self.end is not None:
            outfile.write('end=model_.EndFunctionType(\n')
            self.end.exportLiteral(outfile, level, name_='end')
            outfile.write('),\n')
        if self.escape_regex is not None:
            outfile.write('escape_regex=model_.EscapeRegexFunctionType(\n')
            self.escape_regex.exportLiteral(outfile, level, name_='escape_regex')
            outfile.write('),\n')
        if self.split is not None:
            outfile.write('split=model_.SplitFunctionType(\n')
            self.split.exportLiteral(outfile, level, name_='split')
            outfile.write('),\n')
        if self.substring is not None:
            outfile.write('substring=model_.SubstringFunctionType(\n')
            self.substring.exportLiteral(outfile, level, name_='substring')
            outfile.write('),\n')
        if self.time_difference is not None:
            outfile.write('time_difference=model_.TimeDifferenceFunctionType(\n')
            self.time_difference.exportLiteral(outfile, level, name_='time_difference')
            outfile.write('),\n')
        if self.regex_capture is not None:
            outfile.write('regex_capture=model_.RegexCaptureFunctionType(\n')
            self.regex_capture.exportLiteral(outfile, level, name_='regex_capture')
            outfile.write('),\n')
        if self.unique is not None:
            outfile.write('unique=model_.UniqueFunctionType(\n')
            self.unique.exportLiteral(outfile, level, name_='unique')
            outfile.write('),\n')
        if self.count is not None:
            outfile.write('count=model_.CountFunctionType(\n')
            self.count.exportLiteral(outfile, level, name_='count')
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('pattern', node)
        if value is not None and 'pattern' not in already_processed:
            already_processed.add('pattern')
            self.pattern = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'object_component':
            obj_ = ObjectComponentType.factory()
            obj_.build(child_)
            self.set_object_component(obj_)
        elif nodeName_ == 'variable_component':
            obj_ = VariableComponentType.factory()
            obj_.build(child_)
            self.set_variable_component(obj_)
        elif nodeName_ == 'literal_component':
            obj_ = LiteralComponentType.factory()
            obj_.build(child_)
            self.set_literal_component(obj_)
        elif nodeName_ == 'arithmetic':
            obj_ = ArithmeticFunctionType.factory()
            obj_.build(child_)
            self.set_arithmetic(obj_)
        elif nodeName_ == 'begin':
            obj_ = BeginFunctionType.factory()
            obj_.build(child_)
            self.set_begin(obj_)
        elif nodeName_ == 'concat':
            obj_ = ConcatFunctionType.factory()
            obj_.build(child_)
            self.set_concat(obj_)
        elif nodeName_ == 'end':
            obj_ = EndFunctionType.factory()
            obj_.build(child_)
            self.set_end(obj_)
        elif nodeName_ == 'escape_regex':
            obj_ = EscapeRegexFunctionType.factory()
            obj_.build(child_)
            self.set_escape_regex(obj_)
        elif nodeName_ == 'split':
            obj_ = SplitFunctionType.factory()
            obj_.build(child_)
            self.set_split(obj_)
        elif nodeName_ == 'substring':
            obj_ = SubstringFunctionType.factory()
            obj_.build(child_)
            self.set_substring(obj_)
        elif nodeName_ == 'time_difference':
            obj_ = TimeDifferenceFunctionType.factory()
            obj_.build(child_)
            self.set_time_difference(obj_)
        elif nodeName_ == 'regex_capture':
            obj_ = RegexCaptureFunctionType.factory()
            obj_.build(child_)
            self.set_regex_capture(obj_)
        elif nodeName_ == 'unique':
            obj_ = UniqueFunctionType.factory()
            obj_.build(child_)
            self.set_unique(obj_)
        elif nodeName_ == 'count':
            obj_ = CountFunctionType.factory()
            obj_.build(child_)
            self.set_count(obj_)
# end class RegexCaptureFunctionType

class UniqueFunctionType(GeneratedsSuper):
    """The unique function takes one or more components and removes any
    duplicate value from the set of components. All components used
    in the unique function will be treated as strings. For example,
    assume that three components exist, one that contains a string
    value of 'foo', and two of which both resolve to the string
    value 'bar'. Applying the unique function to these three
    components resolves to a local_variable with two string values,
    'foo' and 'bar'. Additionally, if any of the components
    referenced by the unique function evaluate to multiple values,
    then those values are used in the unique calculation. For
    example, assume that there are two components, one of which
    resolves to a single string value, 'foo', the other of which
    resolves to two string values, 'foo' and 'bar'. If the unique
    function is used to remove duplicates from these two components,
    the function will resolve to a local_variable with two string
    values, 'foo' and 'bar'."""
    subclass = None
    superclass = None
    def __init__(self, object_component=None, variable_component=None, literal_component=None, arithmetic=None, begin=None, concat=None, end=None, escape_regex=None, split=None, substring=None, time_difference=None, regex_capture=None, unique=None, count=None):
        self.object_component = object_component
        self.variable_component = variable_component
        self.literal_component = literal_component
        self.arithmetic = arithmetic
        self.begin = begin
        self.concat = concat
        self.end = end
        self.escape_regex = escape_regex
        self.split = split
        self.substring = substring
        self.time_difference = time_difference
        self.regex_capture = regex_capture
        self.unique = unique
        self.count = count
    def factory(*args_, **kwargs_):
        if UniqueFunctionType.subclass:
            return UniqueFunctionType.subclass(*args_, **kwargs_)
        else:
            return UniqueFunctionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_object_component(self): return self.object_component
    def set_object_component(self, object_component): self.object_component = object_component
    def get_variable_component(self): return self.variable_component
    def set_variable_component(self, variable_component): self.variable_component = variable_component
    def get_literal_component(self): return self.literal_component
    def set_literal_component(self, literal_component): self.literal_component = literal_component
    def get_arithmetic(self): return self.arithmetic
    def set_arithmetic(self, arithmetic): self.arithmetic = arithmetic
    def get_begin(self): return self.begin
    def set_begin(self, begin): self.begin = begin
    def get_concat(self): return self.concat
    def set_concat(self, concat): self.concat = concat
    def get_end(self): return self.end
    def set_end(self, end): self.end = end
    def get_escape_regex(self): return self.escape_regex
    def set_escape_regex(self, escape_regex): self.escape_regex = escape_regex
    def get_split(self): return self.split
    def set_split(self, split): self.split = split
    def get_substring(self): return self.substring
    def set_substring(self, substring): self.substring = substring
    def get_time_difference(self): return self.time_difference
    def set_time_difference(self, time_difference): self.time_difference = time_difference
    def get_regex_capture(self): return self.regex_capture
    def set_regex_capture(self, regex_capture): self.regex_capture = regex_capture
    def get_unique(self): return self.unique
    def set_unique(self, unique): self.unique = unique
    def get_count(self): return self.count
    def set_count(self, count): self.count = count
    def hasContent_(self):
        if (
            self.object_component is not None or
            self.variable_component is not None or
            self.literal_component is not None or
            self.arithmetic is not None or
            self.begin is not None or
            self.concat is not None or
            self.end is not None or
            self.escape_regex is not None or
            self.split is not None or
            self.substring is not None or
            self.time_difference is not None or
            self.regex_capture is not None or
            self.unique is not None or
            self.count is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='oval-def:', name_='UniqueFunctionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='UniqueFunctionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='oval-def:', name_='UniqueFunctionType'):
        pass
    def exportChildren(self, outfile, level, namespace_='oval-def:', name_='UniqueFunctionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.object_component is not None:
            self.object_component.export(outfile, level, '', name_='object_component', pretty_print=pretty_print)
        if self.variable_component is not None:
            self.variable_component.export(outfile, level, '', name_='variable_component', pretty_print=pretty_print)
        if self.literal_component is not None:
            self.literal_component.export(outfile, level, '', name_='literal_component', pretty_print=pretty_print)
        if self.arithmetic is not None:
            self.arithmetic.export(outfile, level, '', name_='arithmetic', pretty_print=pretty_print)
        if self.begin is not None:
            self.begin.export(outfile, level, '', name_='begin', pretty_print=pretty_print)
        if self.concat is not None:
            self.concat.export(outfile, level, '', name_='concat', pretty_print=pretty_print)
        if self.end is not None:
            self.end.export(outfile, level, '', name_='end', pretty_print=pretty_print)
        if self.escape_regex is not None:
            self.escape_regex.export(outfile, level, '', name_='escape_regex', pretty_print=pretty_print)
        if self.split is not None:
            self.split.export(outfile, level, '', name_='split', pretty_print=pretty_print)
        if self.substring is not None:
            self.substring.export(outfile, level, '', name_='substring', pretty_print=pretty_print)
        if self.time_difference is not None:
            self.time_difference.export(outfile, level, '', name_='time_difference', pretty_print=pretty_print)
        if self.regex_capture is not None:
            self.regex_capture.export(outfile, level, '', name_='regex_capture', pretty_print=pretty_print)
        if self.unique is not None:
            self.unique.export(outfile, level, '', name_='unique', pretty_print=pretty_print)
        if self.count is not None:
            self.count.export(outfile, level, '', name_='count', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='UniqueFunctionType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.object_component is not None:
            outfile.write('object_component=model_.ObjectComponentType(\n')
            self.object_component.exportLiteral(outfile, level, name_='object_component')
            outfile.write('),\n')
        if self.variable_component is not None:
            outfile.write('variable_component=model_.VariableComponentType(\n')
            self.variable_component.exportLiteral(outfile, level, name_='variable_component')
            outfile.write('),\n')
        if self.literal_component is not None:
            outfile.write('literal_component=model_.LiteralComponentType(\n')
            self.literal_component.exportLiteral(outfile, level, name_='literal_component')
            outfile.write('),\n')
        if self.arithmetic is not None:
            outfile.write('arithmetic=model_.ArithmeticFunctionType(\n')
            self.arithmetic.exportLiteral(outfile, level, name_='arithmetic')
            outfile.write('),\n')
        if self.begin is not None:
            outfile.write('begin=model_.BeginFunctionType(\n')
            self.begin.exportLiteral(outfile, level, name_='begin')
            outfile.write('),\n')
        if self.concat is not None:
            outfile.write('concat=model_.ConcatFunctionType(\n')
            self.concat.exportLiteral(outfile, level, name_='concat')
            outfile.write('),\n')
        if self.end is not None:
            outfile.write('end=model_.EndFunctionType(\n')
            self.end.exportLiteral(outfile, level, name_='end')
            outfile.write('),\n')
        if self.escape_regex is not None:
            outfile.write('escape_regex=model_.EscapeRegexFunctionType(\n')
            self.escape_regex.exportLiteral(outfile, level, name_='escape_regex')
            outfile.write('),\n')
        if self.split is not None:
            outfile.write('split=model_.SplitFunctionType(\n')
            self.split.exportLiteral(outfile, level, name_='split')
            outfile.write('),\n')
        if self.substring is not None:
            outfile.write('substring=model_.SubstringFunctionType(\n')
            self.substring.exportLiteral(outfile, level, name_='substring')
            outfile.write('),\n')
        if self.time_difference is not None:
            outfile.write('time_difference=model_.TimeDifferenceFunctionType(\n')
            self.time_difference.exportLiteral(outfile, level, name_='time_difference')
            outfile.write('),\n')
        if self.regex_capture is not None:
            outfile.write('regex_capture=model_.RegexCaptureFunctionType(\n')
            self.regex_capture.exportLiteral(outfile, level, name_='regex_capture')
            outfile.write('),\n')
        if self.unique is not None:
            outfile.write('unique=model_.UniqueFunctionType(\n')
            self.unique.exportLiteral(outfile, level, name_='unique')
            outfile.write('),\n')
        if self.count is not None:
            outfile.write('count=model_.CountFunctionType(\n')
            self.count.exportLiteral(outfile, level, name_='count')
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'object_component':
            obj_ = ObjectComponentType.factory()
            obj_.build(child_)
            self.set_object_component(obj_)
        elif nodeName_ == 'variable_component':
            obj_ = VariableComponentType.factory()
            obj_.build(child_)
            self.set_variable_component(obj_)
        elif nodeName_ == 'literal_component':
            obj_ = LiteralComponentType.factory()
            obj_.build(child_)
            self.set_literal_component(obj_)
        elif nodeName_ == 'arithmetic':
            obj_ = ArithmeticFunctionType.factory()
            obj_.build(child_)
            self.set_arithmetic(obj_)
        elif nodeName_ == 'begin':
            obj_ = BeginFunctionType.factory()
            obj_.build(child_)
            self.set_begin(obj_)
        elif nodeName_ == 'concat':
            obj_ = ConcatFunctionType.factory()
            obj_.build(child_)
            self.set_concat(obj_)
        elif nodeName_ == 'end':
            obj_ = EndFunctionType.factory()
            obj_.build(child_)
            self.set_end(obj_)
        elif nodeName_ == 'escape_regex':
            obj_ = EscapeRegexFunctionType.factory()
            obj_.build(child_)
            self.set_escape_regex(obj_)
        elif nodeName_ == 'split':
            obj_ = SplitFunctionType.factory()
            obj_.build(child_)
            self.set_split(obj_)
        elif nodeName_ == 'substring':
            obj_ = SubstringFunctionType.factory()
            obj_.build(child_)
            self.set_substring(obj_)
        elif nodeName_ == 'time_difference':
            obj_ = TimeDifferenceFunctionType.factory()
            obj_.build(child_)
            self.set_time_difference(obj_)
        elif nodeName_ == 'regex_capture':
            obj_ = RegexCaptureFunctionType.factory()
            obj_.build(child_)
            self.set_regex_capture(obj_)
        elif nodeName_ == 'unique':
            obj_ = UniqueFunctionType.factory()
            obj_.build(child_)
            self.set_unique(obj_)
        elif nodeName_ == 'count':
            obj_ = CountFunctionType.factory()
            obj_.build(child_)
            self.set_count(obj_)
# end class UniqueFunctionType

class CountFunctionType(GeneratedsSuper):
    """The count function takes one or more components and returns the
    count of all of the values represented by the components. For
    example, assume that two variables exist, each with a single
    value. By applying the count function against two variable
    components that resolve to the two variables, the resulting
    local_variable would have a value of '2'. Additionally, if any
    of the components referenced by the count function evaluate to
    multiple values, then those values are used in the count
    calculation. For example, assume that there are two components,
    one of which resolves to a single value, the other of which
    resolves to two values. If the count function is used to provide
    a count of these two components, the function will resolve to a
    local_variable with the values '3'."""
    subclass = None
    superclass = None
    def __init__(self, object_component=None, variable_component=None, literal_component=None, arithmetic=None, begin=None, concat=None, end=None, escape_regex=None, split=None, substring=None, time_difference=None, regex_capture=None, unique=None, count=None):
        self.object_component = object_component
        self.variable_component = variable_component
        self.literal_component = literal_component
        self.arithmetic = arithmetic
        self.begin = begin
        self.concat = concat
        self.end = end
        self.escape_regex = escape_regex
        self.split = split
        self.substring = substring
        self.time_difference = time_difference
        self.regex_capture = regex_capture
        self.unique = unique
        self.count = count
    def factory(*args_, **kwargs_):
        if CountFunctionType.subclass:
            return CountFunctionType.subclass(*args_, **kwargs_)
        else:
            return CountFunctionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_object_component(self): return self.object_component
    def set_object_component(self, object_component): self.object_component = object_component
    def get_variable_component(self): return self.variable_component
    def set_variable_component(self, variable_component): self.variable_component = variable_component
    def get_literal_component(self): return self.literal_component
    def set_literal_component(self, literal_component): self.literal_component = literal_component
    def get_arithmetic(self): return self.arithmetic
    def set_arithmetic(self, arithmetic): self.arithmetic = arithmetic
    def get_begin(self): return self.begin
    def set_begin(self, begin): self.begin = begin
    def get_concat(self): return self.concat
    def set_concat(self, concat): self.concat = concat
    def get_end(self): return self.end
    def set_end(self, end): self.end = end
    def get_escape_regex(self): return self.escape_regex
    def set_escape_regex(self, escape_regex): self.escape_regex = escape_regex
    def get_split(self): return self.split
    def set_split(self, split): self.split = split
    def get_substring(self): return self.substring
    def set_substring(self, substring): self.substring = substring
    def get_time_difference(self): return self.time_difference
    def set_time_difference(self, time_difference): self.time_difference = time_difference
    def get_regex_capture(self): return self.regex_capture
    def set_regex_capture(self, regex_capture): self.regex_capture = regex_capture
    def get_unique(self): return self.unique
    def set_unique(self, unique): self.unique = unique
    def get_count(self): return self.count
    def set_count(self, count): self.count = count
    def hasContent_(self):
        if (
            self.object_component is not None or
            self.variable_component is not None or
            self.literal_component is not None or
            self.arithmetic is not None or
            self.begin is not None or
            self.concat is not None or
            self.end is not None or
            self.escape_regex is not None or
            self.split is not None or
            self.substring is not None or
            self.time_difference is not None or
            self.regex_capture is not None or
            self.unique is not None or
            self.count is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='oval-def:', name_='CountFunctionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CountFunctionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='oval-def:', name_='CountFunctionType'):
        pass
    def exportChildren(self, outfile, level, namespace_='oval-def:', name_='CountFunctionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.object_component is not None:
            self.object_component.export(outfile, level, '', name_='object_component', pretty_print=pretty_print)
        if self.variable_component is not None:
            self.variable_component.export(outfile, level, '', name_='variable_component', pretty_print=pretty_print)
        if self.literal_component is not None:
            self.literal_component.export(outfile, level, '', name_='literal_component', pretty_print=pretty_print)
        if self.arithmetic is not None:
            self.arithmetic.export(outfile, level, '', name_='arithmetic', pretty_print=pretty_print)
        if self.begin is not None:
            self.begin.export(outfile, level, '', name_='begin', pretty_print=pretty_print)
        if self.concat is not None:
            self.concat.export(outfile, level, '', name_='concat', pretty_print=pretty_print)
        if self.end is not None:
            self.end.export(outfile, level, '', name_='end', pretty_print=pretty_print)
        if self.escape_regex is not None:
            self.escape_regex.export(outfile, level, '', name_='escape_regex', pretty_print=pretty_print)
        if self.split is not None:
            self.split.export(outfile, level, '', name_='split', pretty_print=pretty_print)
        if self.substring is not None:
            self.substring.export(outfile, level, '', name_='substring', pretty_print=pretty_print)
        if self.time_difference is not None:
            self.time_difference.export(outfile, level, '', name_='time_difference', pretty_print=pretty_print)
        if self.regex_capture is not None:
            self.regex_capture.export(outfile, level, '', name_='regex_capture', pretty_print=pretty_print)
        if self.unique is not None:
            self.unique.export(outfile, level, '', name_='unique', pretty_print=pretty_print)
        if self.count is not None:
            self.count.export(outfile, level, '', name_='count', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='CountFunctionType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.object_component is not None:
            outfile.write('object_component=model_.ObjectComponentType(\n')
            self.object_component.exportLiteral(outfile, level, name_='object_component')
            outfile.write('),\n')
        if self.variable_component is not None:
            outfile.write('variable_component=model_.VariableComponentType(\n')
            self.variable_component.exportLiteral(outfile, level, name_='variable_component')
            outfile.write('),\n')
        if self.literal_component is not None:
            outfile.write('literal_component=model_.LiteralComponentType(\n')
            self.literal_component.exportLiteral(outfile, level, name_='literal_component')
            outfile.write('),\n')
        if self.arithmetic is not None:
            outfile.write('arithmetic=model_.ArithmeticFunctionType(\n')
            self.arithmetic.exportLiteral(outfile, level, name_='arithmetic')
            outfile.write('),\n')
        if self.begin is not None:
            outfile.write('begin=model_.BeginFunctionType(\n')
            self.begin.exportLiteral(outfile, level, name_='begin')
            outfile.write('),\n')
        if self.concat is not None:
            outfile.write('concat=model_.ConcatFunctionType(\n')
            self.concat.exportLiteral(outfile, level, name_='concat')
            outfile.write('),\n')
        if self.end is not None:
            outfile.write('end=model_.EndFunctionType(\n')
            self.end.exportLiteral(outfile, level, name_='end')
            outfile.write('),\n')
        if self.escape_regex is not None:
            outfile.write('escape_regex=model_.EscapeRegexFunctionType(\n')
            self.escape_regex.exportLiteral(outfile, level, name_='escape_regex')
            outfile.write('),\n')
        if self.split is not None:
            outfile.write('split=model_.SplitFunctionType(\n')
            self.split.exportLiteral(outfile, level, name_='split')
            outfile.write('),\n')
        if self.substring is not None:
            outfile.write('substring=model_.SubstringFunctionType(\n')
            self.substring.exportLiteral(outfile, level, name_='substring')
            outfile.write('),\n')
        if self.time_difference is not None:
            outfile.write('time_difference=model_.TimeDifferenceFunctionType(\n')
            self.time_difference.exportLiteral(outfile, level, name_='time_difference')
            outfile.write('),\n')
        if self.regex_capture is not None:
            outfile.write('regex_capture=model_.RegexCaptureFunctionType(\n')
            self.regex_capture.exportLiteral(outfile, level, name_='regex_capture')
            outfile.write('),\n')
        if self.unique is not None:
            outfile.write('unique=model_.UniqueFunctionType(\n')
            self.unique.exportLiteral(outfile, level, name_='unique')
            outfile.write('),\n')
        if self.count is not None:
            outfile.write('count=model_.CountFunctionType(\n')
            self.count.exportLiteral(outfile, level, name_='count')
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'object_component':
            obj_ = ObjectComponentType.factory()
            obj_.build(child_)
            self.set_object_component(obj_)
        elif nodeName_ == 'variable_component':
            obj_ = VariableComponentType.factory()
            obj_.build(child_)
            self.set_variable_component(obj_)
        elif nodeName_ == 'literal_component':
            obj_ = LiteralComponentType.factory()
            obj_.build(child_)
            self.set_literal_component(obj_)
        elif nodeName_ == 'arithmetic':
            obj_ = ArithmeticFunctionType.factory()
            obj_.build(child_)
            self.set_arithmetic(obj_)
        elif nodeName_ == 'begin':
            obj_ = BeginFunctionType.factory()
            obj_.build(child_)
            self.set_begin(obj_)
        elif nodeName_ == 'concat':
            obj_ = ConcatFunctionType.factory()
            obj_.build(child_)
            self.set_concat(obj_)
        elif nodeName_ == 'end':
            obj_ = EndFunctionType.factory()
            obj_.build(child_)
            self.set_end(obj_)
        elif nodeName_ == 'escape_regex':
            obj_ = EscapeRegexFunctionType.factory()
            obj_.build(child_)
            self.set_escape_regex(obj_)
        elif nodeName_ == 'split':
            obj_ = SplitFunctionType.factory()
            obj_.build(child_)
            self.set_split(obj_)
        elif nodeName_ == 'substring':
            obj_ = SubstringFunctionType.factory()
            obj_.build(child_)
            self.set_substring(obj_)
        elif nodeName_ == 'time_difference':
            obj_ = TimeDifferenceFunctionType.factory()
            obj_.build(child_)
            self.set_time_difference(obj_)
        elif nodeName_ == 'regex_capture':
            obj_ = RegexCaptureFunctionType.factory()
            obj_.build(child_)
            self.set_regex_capture(obj_)
        elif nodeName_ == 'unique':
            obj_ = UniqueFunctionType.factory()
            obj_.build(child_)
            self.set_unique(obj_)
        elif nodeName_ == 'count':
            obj_ = CountFunctionType.factory()
            obj_.build(child_)
            self.set_count(obj_)
# end class CountFunctionType

class EntitySimpleBaseType(GeneratedsSuper):
    """The EntitySimpleBaseType complex type is an abstract type that
    defines the default attributes associated with every simple
    entity. Entities can be found in both OVAL Objects and OVAL
    States and represent the individual properties associated with
    items found on a system. An example of a single entity would be
    the path of a file. Another example would be the version of the
    file."""
    subclass = None
    superclass = None
    def __init__(self, datatype='string', operation='equals', mask=False, var_ref=None, var_check=None, valueOf_=None, extensiontype_=None):
        self.datatype = _cast(None, datatype)
        self.operation = _cast(None, operation)
        self.mask = _cast(bool, mask)
        self.var_ref = _cast(None, var_ref)
        self.var_check = _cast(None, var_check)
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if EntitySimpleBaseType.subclass:
            return EntitySimpleBaseType.subclass(*args_, **kwargs_)
        else:
            return EntitySimpleBaseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_datatype(self): return self.datatype
    def set_datatype(self, datatype): self.datatype = datatype
    def get_operation(self): return self.operation
    def set_operation(self, operation): self.operation = operation
    def get_mask(self): return self.mask
    def set_mask(self, mask): self.mask = mask
    def get_var_ref(self): return self.var_ref
    def set_var_ref(self, var_ref): self.var_ref = var_ref
    def get_var_check(self): return self.var_check
    def set_var_check(self, var_check): self.var_check = var_check
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='oval-def:', name_='EntitySimpleBaseType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EntitySimpleBaseType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='oval-def:', name_='EntitySimpleBaseType'):
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            outfile.write(' datatype=%s' % (quote_attrib(self.datatype), ))
        if self.operation is not None and 'operation' not in already_processed:
            already_processed.add('operation')
            outfile.write(' operation=%s' % (quote_attrib(self.operation), ))
        if self.mask is not None and 'mask' not in already_processed:
            already_processed.add('mask')
            outfile.write(' mask="%s"' % self.gds_format_boolean(self.mask, input_name='mask'))
        if self.var_ref is not None and 'var_ref' not in already_processed:
            already_processed.add('var_ref')
            outfile.write(' var_ref=%s' % (quote_attrib(self.var_ref), ))
        if self.var_check is not None and 'var_check' not in already_processed:
            already_processed.add('var_check')
            outfile.write(' var_check=%s' % (quote_attrib(self.var_check), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='oval-def:', name_='EntitySimpleBaseType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='EntitySimpleBaseType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            showIndent(outfile, level)
            outfile.write('datatype = %s,\n' % (self.datatype,))
        if self.operation is not None and 'operation' not in already_processed:
            already_processed.add('operation')
            showIndent(outfile, level)
            outfile.write('operation = %s,\n' % (self.operation,))
        if self.mask is not None and 'mask' not in already_processed:
            already_processed.add('mask')
            showIndent(outfile, level)
            outfile.write('mask = %s,\n' % (self.mask,))
        if self.var_ref is not None and 'var_ref' not in already_processed:
            already_processed.add('var_ref')
            showIndent(outfile, level)
            outfile.write('var_ref = %s,\n' % (self.var_ref,))
        if self.var_check is not None and 'var_check' not in already_processed:
            already_processed.add('var_check')
            showIndent(outfile, level)
            outfile.write('var_check = %s,\n' % (self.var_check,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('datatype', node)
        if value is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            self.datatype = value
        value = find_attr_value_('operation', node)
        if value is not None and 'operation' not in already_processed:
            already_processed.add('operation')
            self.operation = value
        value = find_attr_value_('mask', node)
        if value is not None and 'mask' not in already_processed:
            already_processed.add('mask')
            if value in ('true', '1'):
                self.mask = True
            elif value in ('false', '0'):
                self.mask = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('var_ref', node)
        if value is not None and 'var_ref' not in already_processed:
            already_processed.add('var_ref')
            self.var_ref = value
        value = find_attr_value_('var_check', node)
        if value is not None and 'var_check' not in already_processed:
            already_processed.add('var_check')
            self.var_check = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EntitySimpleBaseType

class EntityComplexBaseType(GeneratedsSuper):
    """The EntityComplexBaseType complex type is an abstract type that
    defines the default attributes associated with every complex
    entity. Entities can be found in both OVAL Objects and OVAL
    States and represent the individual properties associated with
    items found on a system. An example of a single entity would be
    the path of a file. Another example would be the version of the
    file."""
    subclass = None
    superclass = None
    def __init__(self, datatype='string', operation='equals', mask=False, var_ref=None, var_check=None, extensiontype_=None):
        self.datatype = _cast(None, datatype)
        self.operation = _cast(None, operation)
        self.mask = _cast(bool, mask)
        self.var_ref = _cast(None, var_ref)
        self.var_check = _cast(None, var_check)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if EntityComplexBaseType.subclass:
            return EntityComplexBaseType.subclass(*args_, **kwargs_)
        else:
            return EntityComplexBaseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_datatype(self): return self.datatype
    def set_datatype(self, datatype): self.datatype = datatype
    def get_operation(self): return self.operation
    def set_operation(self, operation): self.operation = operation
    def get_mask(self): return self.mask
    def set_mask(self, mask): self.mask = mask
    def get_var_ref(self): return self.var_ref
    def set_var_ref(self, var_ref): self.var_ref = var_ref
    def get_var_check(self): return self.var_check
    def set_var_check(self, var_check): self.var_check = var_check
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='oval-def:', name_='EntityComplexBaseType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EntityComplexBaseType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='oval-def:', name_='EntityComplexBaseType'):
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            outfile.write(' datatype=%s' % (quote_attrib(self.datatype), ))
        if self.operation is not None and 'operation' not in already_processed:
            already_processed.add('operation')
            outfile.write(' operation=%s' % (quote_attrib(self.operation), ))
        if self.mask is not None and 'mask' not in already_processed:
            already_processed.add('mask')
            outfile.write(' mask="%s"' % self.gds_format_boolean(self.mask, input_name='mask'))
        if self.var_ref is not None and 'var_ref' not in already_processed:
            already_processed.add('var_ref')
            outfile.write(' var_ref=%s' % (quote_attrib(self.var_ref), ))
        if self.var_check is not None and 'var_check' not in already_processed:
            already_processed.add('var_check')
            outfile.write(' var_check=%s' % (quote_attrib(self.var_check), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='oval-def:', name_='EntityComplexBaseType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='EntityComplexBaseType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            showIndent(outfile, level)
            outfile.write('datatype = %s,\n' % (self.datatype,))
        if self.operation is not None and 'operation' not in already_processed:
            already_processed.add('operation')
            showIndent(outfile, level)
            outfile.write('operation = %s,\n' % (self.operation,))
        if self.mask is not None and 'mask' not in already_processed:
            already_processed.add('mask')
            showIndent(outfile, level)
            outfile.write('mask = %s,\n' % (self.mask,))
        if self.var_ref is not None and 'var_ref' not in already_processed:
            already_processed.add('var_ref')
            showIndent(outfile, level)
            outfile.write('var_ref = %s,\n' % (self.var_ref,))
        if self.var_check is not None and 'var_check' not in already_processed:
            already_processed.add('var_check')
            showIndent(outfile, level)
            outfile.write('var_check = %s,\n' % (self.var_check,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('datatype', node)
        if value is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            self.datatype = value
        value = find_attr_value_('operation', node)
        if value is not None and 'operation' not in already_processed:
            already_processed.add('operation')
            self.operation = value
        value = find_attr_value_('mask', node)
        if value is not None and 'mask' not in already_processed:
            already_processed.add('mask')
            if value in ('true', '1'):
                self.mask = True
            elif value in ('false', '0'):
                self.mask = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('var_ref', node)
        if value is not None and 'var_ref' not in already_processed:
            already_processed.add('var_ref')
            self.var_ref = value
        value = find_attr_value_('var_check', node)
        if value is not None and 'var_check' not in already_processed:
            already_processed.add('var_check')
            self.var_check = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EntityComplexBaseType

class EntityObjectIPAddressType(EntitySimpleBaseType):
    """The EntityObjectIPAddressType type is extended by the entities of an
    individual OVAL Object. This type provides uniformity to each
    object entity by including the attributes found in the
    EntitySimpleBaseType. This specific type describes any IPv4/IPv6
    address or address prefix."""
    subclass = None
    superclass = EntitySimpleBaseType
    def __init__(self, datatype='string', operation='equals', mask=False, var_ref=None, var_check=None, valueOf_=None):
        super(EntityObjectIPAddressType, self).__init__(datatype, operation, mask, var_ref, var_check, valueOf_, )
        self.datatype = _cast(None, datatype)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if EntityObjectIPAddressType.subclass:
            return EntityObjectIPAddressType.subclass(*args_, **kwargs_)
        else:
            return EntityObjectIPAddressType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_datatype(self): return self.datatype
    def set_datatype(self, datatype): self.datatype = datatype
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(EntityObjectIPAddressType, self).hasContent_()
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='oval-def:', name_='EntityObjectIPAddressType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EntityObjectIPAddressType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='oval-def:', name_='EntityObjectIPAddressType'):
        super(EntityObjectIPAddressType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='EntityObjectIPAddressType')
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            outfile.write(' datatype=%s' % (quote_attrib(self.datatype), ))
    def exportChildren(self, outfile, level, namespace_='oval-def:', name_='EntityObjectIPAddressType', fromsubclass_=False, pretty_print=True):
        super(EntityObjectIPAddressType, self).exportChildren(outfile, level, '', name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='EntityObjectIPAddressType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            showIndent(outfile, level)
            outfile.write('datatype = %s,\n' % (self.datatype,))
        super(EntityObjectIPAddressType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(EntityObjectIPAddressType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('datatype', node)
        if value is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            self.datatype = value
        super(EntityObjectIPAddressType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EntityObjectIPAddressType

class EntityObjectIPAddressStringType(EntitySimpleBaseType):
    """The EntityObjectIPAddressStringType type is extended by the entities
    of an individual OVAL Object. This type provides uniformity to
    each object entity by including the attributes found in the
    EntitySimpleBaseType. This specific type describes any IPv4/IPv6
    address, address prefix, or its string representation."""
    subclass = None
    superclass = EntitySimpleBaseType
    def __init__(self, datatype='string', operation='equals', mask=False, var_ref=None, var_check=None, valueOf_=None):
        super(EntityObjectIPAddressStringType, self).__init__(datatype, operation, mask, var_ref, var_check, valueOf_, )
        self.datatype = _cast(None, datatype)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if EntityObjectIPAddressStringType.subclass:
            return EntityObjectIPAddressStringType.subclass(*args_, **kwargs_)
        else:
            return EntityObjectIPAddressStringType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_datatype(self): return self.datatype
    def set_datatype(self, datatype): self.datatype = datatype
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(EntityObjectIPAddressStringType, self).hasContent_()
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='oval-def:', name_='EntityObjectIPAddressStringType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EntityObjectIPAddressStringType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='oval-def:', name_='EntityObjectIPAddressStringType'):
        super(EntityObjectIPAddressStringType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='EntityObjectIPAddressStringType')
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            outfile.write(' datatype=%s' % (quote_attrib(self.datatype), ))
    def exportChildren(self, outfile, level, namespace_='oval-def:', name_='EntityObjectIPAddressStringType', fromsubclass_=False, pretty_print=True):
        super(EntityObjectIPAddressStringType, self).exportChildren(outfile, level, '', name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='EntityObjectIPAddressStringType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            showIndent(outfile, level)
            outfile.write('datatype = %s,\n' % (self.datatype,))
        super(EntityObjectIPAddressStringType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(EntityObjectIPAddressStringType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('datatype', node)
        if value is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            self.datatype = value
        super(EntityObjectIPAddressStringType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EntityObjectIPAddressStringType

class EntityObjectAnySimpleType(EntitySimpleBaseType):
    """The EntityObjectAnySimpleType type is extended by the entities of an
    individual OVAL Object. This type provides uniformity to each
    object entity by including the attributes found in the
    EntitySimpleBaseType. This specific type describes any simple
    data."""
    subclass = None
    superclass = EntitySimpleBaseType
    def __init__(self, datatype='string', operation='equals', mask=False, var_ref=None, var_check=None, valueOf_=None):
        super(EntityObjectAnySimpleType, self).__init__(datatype, operation, mask, var_ref, var_check, valueOf_, )
        self.datatype = _cast(None, datatype)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if EntityObjectAnySimpleType.subclass:
            return EntityObjectAnySimpleType.subclass(*args_, **kwargs_)
        else:
            return EntityObjectAnySimpleType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_datatype(self): return self.datatype
    def set_datatype(self, datatype): self.datatype = datatype
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(EntityObjectAnySimpleType, self).hasContent_()
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='oval-def:', name_='EntityObjectAnySimpleType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EntityObjectAnySimpleType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='oval-def:', name_='EntityObjectAnySimpleType'):
        super(EntityObjectAnySimpleType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='EntityObjectAnySimpleType')
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            outfile.write(' datatype=%s' % (quote_attrib(self.datatype), ))
    def exportChildren(self, outfile, level, namespace_='oval-def:', name_='EntityObjectAnySimpleType', fromsubclass_=False, pretty_print=True):
        super(EntityObjectAnySimpleType, self).exportChildren(outfile, level, '', name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='EntityObjectAnySimpleType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            showIndent(outfile, level)
            outfile.write('datatype = %s,\n' % (self.datatype,))
        super(EntityObjectAnySimpleType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(EntityObjectAnySimpleType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('datatype', node)
        if value is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            self.datatype = value
        super(EntityObjectAnySimpleType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EntityObjectAnySimpleType

class EntityObjectBinaryType(EntitySimpleBaseType):
    """The EntityBinaryType type is extended by the entities of an
    individual OVAL Object. This type provides uniformity to each
    object entity by including the attributes found in the
    EntitySimpleBaseType. This specific type describes simple binary
    data. The empty string is also allowed when using a variable
    reference with an element."""
    subclass = None
    superclass = EntitySimpleBaseType
    def __init__(self, datatype='string', operation='equals', mask=False, var_ref=None, var_check=None, valueOf_=None):
        super(EntityObjectBinaryType, self).__init__(datatype, operation, mask, var_ref, var_check, valueOf_, )
        self.datatype = _cast(None, datatype)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if EntityObjectBinaryType.subclass:
            return EntityObjectBinaryType.subclass(*args_, **kwargs_)
        else:
            return EntityObjectBinaryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_datatype(self): return self.datatype
    def set_datatype(self, datatype): self.datatype = datatype
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(EntityObjectBinaryType, self).hasContent_()
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='oval-def:', name_='EntityObjectBinaryType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EntityObjectBinaryType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='oval-def:', name_='EntityObjectBinaryType'):
        super(EntityObjectBinaryType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='EntityObjectBinaryType')
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            outfile.write(' datatype=%s' % (quote_attrib(self.datatype), ))
    def exportChildren(self, outfile, level, namespace_='oval-def:', name_='EntityObjectBinaryType', fromsubclass_=False, pretty_print=True):
        super(EntityObjectBinaryType, self).exportChildren(outfile, level, '', name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='EntityObjectBinaryType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            showIndent(outfile, level)
            outfile.write('datatype = %s,\n' % (self.datatype,))
        super(EntityObjectBinaryType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(EntityObjectBinaryType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('datatype', node)
        if value is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            self.datatype = value
        super(EntityObjectBinaryType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EntityObjectBinaryType

class EntityObjectBoolType(EntitySimpleBaseType):
    """The EntityBoolType type is extended by the entities of an individual
    OVAL Object. This type provides uniformity to each object entity
    by including the attributes found in the EntitySimpleBaseType.
    This specific type describes simple boolean data. The empty
    string is also allowed when using a variable reference with an
    element."""
    subclass = None
    superclass = EntitySimpleBaseType
    def __init__(self, datatype='string', operation='equals', mask=False, var_ref=None, var_check=None, valueOf_=None):
        super(EntityObjectBoolType, self).__init__(datatype, operation, mask, var_ref, var_check, valueOf_, )
        self.datatype = _cast(None, datatype)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if EntityObjectBoolType.subclass:
            return EntityObjectBoolType.subclass(*args_, **kwargs_)
        else:
            return EntityObjectBoolType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_datatype(self): return self.datatype
    def set_datatype(self, datatype): self.datatype = datatype
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(EntityObjectBoolType, self).hasContent_()
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='oval-def:', name_='EntityObjectBoolType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EntityObjectBoolType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='oval-def:', name_='EntityObjectBoolType'):
        super(EntityObjectBoolType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='EntityObjectBoolType')
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            outfile.write(' datatype=%s' % (quote_attrib(self.datatype), ))
    def exportChildren(self, outfile, level, namespace_='oval-def:', name_='EntityObjectBoolType', fromsubclass_=False, pretty_print=True):
        super(EntityObjectBoolType, self).exportChildren(outfile, level, '', name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='EntityObjectBoolType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            showIndent(outfile, level)
            outfile.write('datatype = %s,\n' % (self.datatype,))
        super(EntityObjectBoolType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(EntityObjectBoolType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('datatype', node)
        if value is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            self.datatype = value
        super(EntityObjectBoolType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EntityObjectBoolType

class EntityObjectFloatType(EntitySimpleBaseType):
    """The EntityObjectFloatType type is extended by the entities of an
    individual OVAL Object. This type provides uniformity to each
    object entity by including the attributes found in the
    EntitySimpleBaseType. This specific type describes simple float
    data. The empty string is also allowed when using a variable
    reference with an element."""
    subclass = None
    superclass = EntitySimpleBaseType
    def __init__(self, datatype='string', operation='equals', mask=False, var_ref=None, var_check=None, valueOf_=None):
        super(EntityObjectFloatType, self).__init__(datatype, operation, mask, var_ref, var_check, valueOf_, )
        self.datatype = _cast(None, datatype)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if EntityObjectFloatType.subclass:
            return EntityObjectFloatType.subclass(*args_, **kwargs_)
        else:
            return EntityObjectFloatType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_datatype(self): return self.datatype
    def set_datatype(self, datatype): self.datatype = datatype
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(EntityObjectFloatType, self).hasContent_()
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='oval-def:', name_='EntityObjectFloatType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EntityObjectFloatType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='oval-def:', name_='EntityObjectFloatType'):
        super(EntityObjectFloatType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='EntityObjectFloatType')
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            outfile.write(' datatype=%s' % (quote_attrib(self.datatype), ))
    def exportChildren(self, outfile, level, namespace_='oval-def:', name_='EntityObjectFloatType', fromsubclass_=False, pretty_print=True):
        super(EntityObjectFloatType, self).exportChildren(outfile, level, '', name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='EntityObjectFloatType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            showIndent(outfile, level)
            outfile.write('datatype = %s,\n' % (self.datatype,))
        super(EntityObjectFloatType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(EntityObjectFloatType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('datatype', node)
        if value is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            self.datatype = value
        super(EntityObjectFloatType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EntityObjectFloatType

class EntityObjectIntType(EntitySimpleBaseType):
    """The EntityIntType type is extended by the entities of an individual
    OVAL Object. This type provides uniformity to each object entity
    by including the attributes found in the EntitySimpleBaseType.
    This specific type describes simple integer data. The empty
    string is also allowed when using a variable reference with an
    element."""
    subclass = None
    superclass = EntitySimpleBaseType
    def __init__(self, datatype='string', operation='equals', mask=False, var_ref=None, var_check=None, valueOf_=None):
        super(EntityObjectIntType, self).__init__(datatype, operation, mask, var_ref, var_check, valueOf_, )
        self.datatype = _cast(None, datatype)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if EntityObjectIntType.subclass:
            return EntityObjectIntType.subclass(*args_, **kwargs_)
        else:
            return EntityObjectIntType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_datatype(self): return self.datatype
    def set_datatype(self, datatype): self.datatype = datatype
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(EntityObjectIntType, self).hasContent_()
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='oval-def:', name_='EntityObjectIntType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EntityObjectIntType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='oval-def:', name_='EntityObjectIntType'):
        super(EntityObjectIntType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='EntityObjectIntType')
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            outfile.write(' datatype=%s' % (quote_attrib(self.datatype), ))
    def exportChildren(self, outfile, level, namespace_='oval-def:', name_='EntityObjectIntType', fromsubclass_=False, pretty_print=True):
        super(EntityObjectIntType, self).exportChildren(outfile, level, '', name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='EntityObjectIntType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            showIndent(outfile, level)
            outfile.write('datatype = %s,\n' % (self.datatype,))
        super(EntityObjectIntType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(EntityObjectIntType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('datatype', node)
        if value is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            self.datatype = value
        super(EntityObjectIntType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EntityObjectIntType

class EntityObjectStringType(EntitySimpleBaseType):
    """The EntityStringType type is extended by the entities of an
    individual OVAL Object. This type provides uniformity to each
    object entity by including the attributes found in the
    EntitySimpleBaseType. This specific type describes simple string
    data."""
    subclass = None
    superclass = EntitySimpleBaseType
    def __init__(self, datatype='string', operation='equals', mask=False, var_ref=None, var_check=None, valueOf_=None):
        super(EntityObjectStringType, self).__init__(datatype, operation, mask, var_ref, var_check, valueOf_, )
        self.datatype = _cast(None, datatype)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if EntityObjectStringType.subclass:
            return EntityObjectStringType.subclass(*args_, **kwargs_)
        else:
            return EntityObjectStringType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_datatype(self): return self.datatype
    def set_datatype(self, datatype): self.datatype = datatype
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(EntityObjectStringType, self).hasContent_()
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='oval-def:', name_='EntityObjectStringType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EntityObjectStringType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='oval-def:', name_='EntityObjectStringType'):
        super(EntityObjectStringType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='EntityObjectStringType')
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            outfile.write(' datatype=%s' % (quote_attrib(self.datatype), ))
    def exportChildren(self, outfile, level, namespace_='oval-def:', name_='EntityObjectStringType', fromsubclass_=False, pretty_print=True):
        super(EntityObjectStringType, self).exportChildren(outfile, level, '', name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='EntityObjectStringType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            showIndent(outfile, level)
            outfile.write('datatype = %s,\n' % (self.datatype,))
        super(EntityObjectStringType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(EntityObjectStringType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('datatype', node)
        if value is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            self.datatype = value
        super(EntityObjectStringType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EntityObjectStringType

class EntityObjectVersionType(EntitySimpleBaseType):
    """The EntityObjectVersionType type is extended by the entities of an
    individual OVAL State. This type provides uniformity to each
    state entity by including the attributes found in the
    EntityStateSimpleBaseType. This specific type describes simple
    version data."""
    subclass = None
    superclass = EntitySimpleBaseType
    def __init__(self, datatype='string', operation='equals', mask=False, var_ref=None, var_check=None, valueOf_=None):
        super(EntityObjectVersionType, self).__init__(datatype, operation, mask, var_ref, var_check, valueOf_, )
        self.datatype = _cast(None, datatype)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if EntityObjectVersionType.subclass:
            return EntityObjectVersionType.subclass(*args_, **kwargs_)
        else:
            return EntityObjectVersionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_datatype(self): return self.datatype
    def set_datatype(self, datatype): self.datatype = datatype
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(EntityObjectVersionType, self).hasContent_()
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='oval-def:', name_='EntityObjectVersionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EntityObjectVersionType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='oval-def:', name_='EntityObjectVersionType'):
        super(EntityObjectVersionType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='EntityObjectVersionType')
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            outfile.write(' datatype=%s' % (quote_attrib(self.datatype), ))
    def exportChildren(self, outfile, level, namespace_='oval-def:', name_='EntityObjectVersionType', fromsubclass_=False, pretty_print=True):
        super(EntityObjectVersionType, self).exportChildren(outfile, level, '', name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='EntityObjectVersionType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            showIndent(outfile, level)
            outfile.write('datatype = %s,\n' % (self.datatype,))
        super(EntityObjectVersionType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(EntityObjectVersionType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('datatype', node)
        if value is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            self.datatype = value
        super(EntityObjectVersionType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EntityObjectVersionType

class EntityObjectRecordType(EntityComplexBaseType):
    """The EntityObjectRecordType defines an entity that consists of a
    number of uniquely named fields. This structure is used for
    representing a record from a database query and other similar
    structures where multiple related fields must be represented at
    once. Note that for all entities of this type, the only allowed
    datatype is 'record' and the only allowed operation is 'equals'.
    During analysis of a system characteristics item, each field is
    analyzed and then the overall result for elements of this type
    is computed by logically anding the results for each field and
    then applying the entity_check attribute.Note the datatype
    attribute must be set to 'record'.Note the operation attribute
    must be set to 'equals'.Note the var_ref attribute is not
    permitted and the var_check attribute does not apply.Note that
    when the mask attribute is set to 'true', all child field
    elements must be masked regardless of the child field's mask
    attribute value."""
    subclass = None
    superclass = EntityComplexBaseType
    def __init__(self, datatype='string', operation='equals', mask=False, var_ref=None, var_check=None, field=None):
        super(EntityObjectRecordType, self).__init__(datatype, operation, mask, var_ref, var_check, )
        if field is None:
            self.field = []
        else:
            self.field = field
    def factory(*args_, **kwargs_):
        if EntityObjectRecordType.subclass:
            return EntityObjectRecordType.subclass(*args_, **kwargs_)
        else:
            return EntityObjectRecordType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_field(self): return self.field
    def set_field(self, field): self.field = field
    def add_field(self, value): self.field.append(value)
    def insert_field(self, index, value): self.field[index] = value
    def hasContent_(self):
        if (
            self.field or
            super(EntityObjectRecordType, self).hasContent_()
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='oval-def:', name_='EntityObjectRecordType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EntityObjectRecordType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='oval-def:', name_='EntityObjectRecordType'):
        super(EntityObjectRecordType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='EntityObjectRecordType')
    def exportChildren(self, outfile, level, namespace_='oval-def:', name_='EntityObjectRecordType', fromsubclass_=False, pretty_print=True):
        super(EntityObjectRecordType, self).exportChildren(outfile, level, '', name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for field_ in self.field:
            field_.export(outfile, level, '', name_='field', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='EntityObjectRecordType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(EntityObjectRecordType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(EntityObjectRecordType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('field=[\n')
        level += 1
        for field_ in self.field:
            outfile.write('model_.EntityObjectFieldType(\n')
            field_.exportLiteral(outfile, level, name_='EntityObjectFieldType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(EntityObjectRecordType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'field':
            obj_ = EntityObjectFieldType.factory()
            obj_.build(child_)
            self.field.append(obj_)
        super(EntityObjectRecordType, self).buildChildren(child_, node, nodeName_, True)
# end class EntityObjectRecordType

class EntityObjectFieldType(GeneratedsSuper):
    """The EntityObjectFieldType defines an element with simple content
    that represents a named field in a record that may contain any
    number of named fields. The EntityObjectFieldType is much like
    all other entities with one significant difference, the
    EntityObjectFieldType has a name attributeThe required name
    attribute specifies a unique name for the field. Field names are
    lowercase and must be unique within a given parent record
    element. When analyzing system characteristics an error should
    be reported for the result of a field that is present in the
    OVAL State, but not found in the system characteristics Item.The
    optional entity_check attribute specifies how to handle multiple
    record fields with the same name in the OVAL Systems
    Characteristics file. For example, while collecting group
    information where one field is the represents the users that are
    members of the group. It is very likely that there will be
    multiple fields with a name of 'user' associated with the group.
    If the OVAL State defines the value of the field with name equal
    'user' to equal 'Fred', then the entity_check attribute
    determines if all values for field entities must be equal to
    'Fred', or at least one value must be equal to 'Fred', etc.Note
    that when the mask attribute is set to 'true' on a field's
    parent element the field must be masked regardless of the
    field's mask attribute value.A string restricted to disallow
    upper case characters."""
    subclass = None
    superclass = None
    def __init__(self, name=None, var_ref=None, var_check=None, datatype='string', mask=False, entity_check='all', operation='equals', valueOf_=None):
        self.name = _cast(None, name)
        self.var_ref = _cast(None, var_ref)
        self.var_check = _cast(None, var_check)
        self.datatype = _cast(None, datatype)
        self.mask = _cast(bool, mask)
        self.entity_check = _cast(None, entity_check)
        self.operation = _cast(None, operation)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if EntityObjectFieldType.subclass:
            return EntityObjectFieldType.subclass(*args_, **kwargs_)
        else:
            return EntityObjectFieldType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_var_ref(self): return self.var_ref
    def set_var_ref(self, var_ref): self.var_ref = var_ref
    def get_var_check(self): return self.var_check
    def set_var_check(self, var_check): self.var_check = var_check
    def get_datatype(self): return self.datatype
    def set_datatype(self, datatype): self.datatype = datatype
    def get_mask(self): return self.mask
    def set_mask(self, mask): self.mask = mask
    def get_entity_check(self): return self.entity_check
    def set_entity_check(self, entity_check): self.entity_check = entity_check
    def get_operation(self): return self.operation
    def set_operation(self, operation): self.operation = operation
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='oval-def:', name_='EntityObjectFieldType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EntityObjectFieldType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='oval-def:', name_='EntityObjectFieldType'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.var_ref is not None and 'var_ref' not in already_processed:
            already_processed.add('var_ref')
            outfile.write(' var_ref=%s' % (quote_attrib(self.var_ref), ))
        if self.var_check is not None and 'var_check' not in already_processed:
            already_processed.add('var_check')
            outfile.write(' var_check=%s' % (quote_attrib(self.var_check), ))
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            outfile.write(' datatype=%s' % (quote_attrib(self.datatype), ))
        if self.mask is not None and 'mask' not in already_processed:
            already_processed.add('mask')
            outfile.write(' mask="%s"' % self.gds_format_boolean(self.mask, input_name='mask'))
        if self.entity_check is not None and 'entity_check' not in already_processed:
            already_processed.add('entity_check')
            outfile.write(' entity_check=%s' % (quote_attrib(self.entity_check), ))
        if self.operation is not None and 'operation' not in already_processed:
            already_processed.add('operation')
            outfile.write(' operation=%s' % (quote_attrib(self.operation), ))
    def exportChildren(self, outfile, level, namespace_='oval-def:', name_='EntityObjectFieldType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='EntityObjectFieldType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.var_ref is not None and 'var_ref' not in already_processed:
            already_processed.add('var_ref')
            showIndent(outfile, level)
            outfile.write('var_ref = %s,\n' % (self.var_ref,))
        if self.var_check is not None and 'var_check' not in already_processed:
            already_processed.add('var_check')
            showIndent(outfile, level)
            outfile.write('var_check = %s,\n' % (self.var_check,))
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            showIndent(outfile, level)
            outfile.write('datatype = %s,\n' % (self.datatype,))
        if self.mask is not None and 'mask' not in already_processed:
            already_processed.add('mask')
            showIndent(outfile, level)
            outfile.write('mask = %s,\n' % (self.mask,))
        if self.entity_check is not None and 'entity_check' not in already_processed:
            already_processed.add('entity_check')
            showIndent(outfile, level)
            outfile.write('entity_check = %s,\n' % (self.entity_check,))
        if self.operation is not None and 'operation' not in already_processed:
            already_processed.add('operation')
            showIndent(outfile, level)
            outfile.write('operation = %s,\n' % (self.operation,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('var_ref', node)
        if value is not None and 'var_ref' not in already_processed:
            already_processed.add('var_ref')
            self.var_ref = value
        value = find_attr_value_('var_check', node)
        if value is not None and 'var_check' not in already_processed:
            already_processed.add('var_check')
            self.var_check = value
        value = find_attr_value_('datatype', node)
        if value is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            self.datatype = value
        value = find_attr_value_('mask', node)
        if value is not None and 'mask' not in already_processed:
            already_processed.add('mask')
            if value in ('true', '1'):
                self.mask = True
            elif value in ('false', '0'):
                self.mask = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('entity_check', node)
        if value is not None and 'entity_check' not in already_processed:
            already_processed.add('entity_check')
            self.entity_check = value
        value = find_attr_value_('operation', node)
        if value is not None and 'operation' not in already_processed:
            already_processed.add('operation')
            self.operation = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EntityObjectFieldType

class EntityStateSimpleBaseType(EntitySimpleBaseType):
    """The EntityStateSimpleBaseType complex type is an abstract type that
    extends the EntitySimpleBaseType and is used by some entities
    within an OVAL State.The optional entity_check attribute
    specifies how to handle multiple item entities with the same
    name in the OVAL Systems Characteristics file. For example,
    suppose we are dealing with a Group Test and an entity in the
    state is related to the user. It is very likely that when the
    information about the group is collected off of the system (and
    represented in the OVAL System Characteristics file) that there
    will be multiple users associated with the group (i.e. multiple
    'user' item entities associated with the same 'user' state
    entity). If the OVAL State defines the value of the user entity
    to equal 'Fred', then the entity_check attribute determines if
    all values for 'user' item entities must be equal to 'Fred', or
    at least one value must be equal to 'Fred', etc. Note that with
    the exception of the 'none_satisfy' check value, the
    entity_check attribute can only affect the result of the test if
    the corresponding OVAL Item allows more than one occurrence of
    the entity (e.g. 'maxOccurs' is some value greater than one).The
    entity_check and var_check attributes are considered together
    when evaluating a single state entity. When a variable
    identifies more than one value and multiple item entities with
    the same name exist, for a single state entity, a many-to-many
    comparison must be conducted. In this situation, there are many
    values for the state entity that must be compared to many item
    entities. Each item entity is compared to the state entity. For
    each item entity, an interim result is calculated by using the
    var_check attribute to combine the result of comparing each
    variable value with a single system value. Then these interim
    results are combined for each system value using the
    entity_check attribute."""
    subclass = None
    superclass = EntitySimpleBaseType
    def __init__(self, datatype='string', operation='equals', mask=False, var_ref=None, var_check=None, entity_check='all', valueOf_=None, extensiontype_=None):
        super(EntityStateSimpleBaseType, self).__init__(datatype, operation, mask, var_ref, var_check, valueOf_, extensiontype_, )
        self.entity_check = _cast(None, entity_check)
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if EntityStateSimpleBaseType.subclass:
            return EntityStateSimpleBaseType.subclass(*args_, **kwargs_)
        else:
            return EntityStateSimpleBaseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_entity_check(self): return self.entity_check
    def set_entity_check(self, entity_check): self.entity_check = entity_check
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(EntityStateSimpleBaseType, self).hasContent_()
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='oval-def:', name_='EntityStateSimpleBaseType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EntityStateSimpleBaseType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='oval-def:', name_='EntityStateSimpleBaseType'):
        super(EntityStateSimpleBaseType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='EntityStateSimpleBaseType')
        if self.entity_check is not None and 'entity_check' not in already_processed:
            already_processed.add('entity_check')
            outfile.write(' entity_check=%s' % (quote_attrib(self.entity_check), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='oval-def:', name_='EntityStateSimpleBaseType', fromsubclass_=False, pretty_print=True):
        super(EntityStateSimpleBaseType, self).exportChildren(outfile, level, '', name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='EntityStateSimpleBaseType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.entity_check is not None and 'entity_check' not in already_processed:
            already_processed.add('entity_check')
            showIndent(outfile, level)
            outfile.write('entity_check = %s,\n' % (self.entity_check,))
        super(EntityStateSimpleBaseType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(EntityStateSimpleBaseType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('entity_check', node)
        if value is not None and 'entity_check' not in already_processed:
            already_processed.add('entity_check')
            self.entity_check = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(EntityStateSimpleBaseType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EntityStateSimpleBaseType

class EntityStateComplexBaseType(EntityComplexBaseType):
    """The EntityStateComplexBaseType complex type is an abstract type that
    extends the EntityComplexBaseType and is used by some entities
    within an OVAL State.The optional entity_check attribute
    specifies how to handle multiple item entities with the same
    name in the OVAL Systems Characteristics file. For example,
    suppose we are dealing with a Group Test and an entity in the
    state is related to the user. It is very likely that when the
    information about the group is collected off of the system (and
    represented in the OVAL System Characteristics file) that there
    will be multiple users associated with the group (i.e. multiple
    'user' item entities associated with the same 'user' state
    entity). If the OVAL State defines the value of the user entity
    to equal 'Fred', then the entity_check attribute determines if
    all values for 'user' item entities must be equal to 'Fred', or
    at least one value must be equal to 'Fred', etc. Note that with
    the exception of the 'none_satisfy' check value, the
    entity_check attribute can only affect the result of the test if
    the corresponding OVAL Item allows more than one occurrence of
    the entity (e.g. 'maxOccurs' is some value greater than one).The
    entity_check and var_check attributes are considered together
    when evaluating a single state entity. When a variable
    identifies more than one value and multiple item entities with
    the same name exist, for a single state entity, a many-to-many
    comparison must be conducted. In this situation, there are many
    values for the state entity that must be compared to many item
    entities. Each item entity is compared to the state entity. For
    each item entity, an interim result is calculated by using the
    var_check attribute to combine the result of comparing each
    variable value with a single system value. Then these interim
    results are combined for each system value using the
    entity_check attribute."""
    subclass = None
    superclass = EntityComplexBaseType
    def __init__(self, datatype='string', operation='equals', mask=False, var_ref=None, var_check=None, entity_check='all', extensiontype_=None):
        super(EntityStateComplexBaseType, self).__init__(datatype, operation, mask, var_ref, var_check, extensiontype_, )
        self.entity_check = _cast(None, entity_check)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if EntityStateComplexBaseType.subclass:
            return EntityStateComplexBaseType.subclass(*args_, **kwargs_)
        else:
            return EntityStateComplexBaseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_entity_check(self): return self.entity_check
    def set_entity_check(self, entity_check): self.entity_check = entity_check
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            super(EntityStateComplexBaseType, self).hasContent_()
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='oval-def:', name_='EntityStateComplexBaseType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EntityStateComplexBaseType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='oval-def:', name_='EntityStateComplexBaseType'):
        super(EntityStateComplexBaseType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='EntityStateComplexBaseType')
        if self.entity_check is not None and 'entity_check' not in already_processed:
            already_processed.add('entity_check')
            outfile.write(' entity_check=%s' % (quote_attrib(self.entity_check), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='oval-def:', name_='EntityStateComplexBaseType', fromsubclass_=False, pretty_print=True):
        super(EntityStateComplexBaseType, self).exportChildren(outfile, level, '', name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='EntityStateComplexBaseType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.entity_check is not None and 'entity_check' not in already_processed:
            already_processed.add('entity_check')
            showIndent(outfile, level)
            outfile.write('entity_check = %s,\n' % (self.entity_check,))
        super(EntityStateComplexBaseType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(EntityStateComplexBaseType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('entity_check', node)
        if value is not None and 'entity_check' not in already_processed:
            already_processed.add('entity_check')
            self.entity_check = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(EntityStateComplexBaseType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(EntityStateComplexBaseType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class EntityStateComplexBaseType

class EntityStateIPAddressType(EntityStateSimpleBaseType):
    """The EntityStateIPAddressType type is extended by the entities of an
    individual OVAL State. This type provides uniformity to each
    object entity by including the attributes found in the
    EntityStateSimpleBaseType. This specific type describes any
    IPv4/IPv6 address or address prefix."""
    subclass = None
    superclass = EntityStateSimpleBaseType
    def __init__(self, datatype='string', operation='equals', mask=False, var_ref=None, var_check=None, entity_check='all', valueOf_=None):
        super(EntityStateIPAddressType, self).__init__(datatype, operation, mask, var_ref, var_check, entity_check, valueOf_, )
        self.datatype = _cast(None, datatype)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if EntityStateIPAddressType.subclass:
            return EntityStateIPAddressType.subclass(*args_, **kwargs_)
        else:
            return EntityStateIPAddressType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_datatype(self): return self.datatype
    def set_datatype(self, datatype): self.datatype = datatype
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(EntityStateIPAddressType, self).hasContent_()
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='oval-def:', name_='EntityStateIPAddressType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EntityStateIPAddressType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='oval-def:', name_='EntityStateIPAddressType'):
        super(EntityStateIPAddressType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='EntityStateIPAddressType')
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            outfile.write(' datatype=%s' % (quote_attrib(self.datatype), ))
    def exportChildren(self, outfile, level, namespace_='oval-def:', name_='EntityStateIPAddressType', fromsubclass_=False, pretty_print=True):
        super(EntityStateIPAddressType, self).exportChildren(outfile, level, '', name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='EntityStateIPAddressType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            showIndent(outfile, level)
            outfile.write('datatype = %s,\n' % (self.datatype,))
        super(EntityStateIPAddressType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(EntityStateIPAddressType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('datatype', node)
        if value is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            self.datatype = value
        super(EntityStateIPAddressType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EntityStateIPAddressType

class EntityStateIPAddressStringType(EntityStateSimpleBaseType):
    """The EntityStateIPAddressStringType type is extended by the entities
    of an individual OVAL State. This type provides uniformity to
    each object entity by including the attributes found in the
    EntityStateSimpleBaseType. This specific type describes any
    IPv4/IPv6 address, address prefix, or its string representation."""
    subclass = None
    superclass = EntityStateSimpleBaseType
    def __init__(self, datatype='string', operation='equals', mask=False, var_ref=None, var_check=None, entity_check='all', valueOf_=None):
        super(EntityStateIPAddressStringType, self).__init__(datatype, operation, mask, var_ref, var_check, entity_check, valueOf_, )
        self.datatype = _cast(None, datatype)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if EntityStateIPAddressStringType.subclass:
            return EntityStateIPAddressStringType.subclass(*args_, **kwargs_)
        else:
            return EntityStateIPAddressStringType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_datatype(self): return self.datatype
    def set_datatype(self, datatype): self.datatype = datatype
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(EntityStateIPAddressStringType, self).hasContent_()
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='oval-def:', name_='EntityStateIPAddressStringType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EntityStateIPAddressStringType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='oval-def:', name_='EntityStateIPAddressStringType'):
        super(EntityStateIPAddressStringType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='EntityStateIPAddressStringType')
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            outfile.write(' datatype=%s' % (quote_attrib(self.datatype), ))
    def exportChildren(self, outfile, level, namespace_='oval-def:', name_='EntityStateIPAddressStringType', fromsubclass_=False, pretty_print=True):
        super(EntityStateIPAddressStringType, self).exportChildren(outfile, level, '', name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='EntityStateIPAddressStringType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            showIndent(outfile, level)
            outfile.write('datatype = %s,\n' % (self.datatype,))
        super(EntityStateIPAddressStringType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(EntityStateIPAddressStringType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('datatype', node)
        if value is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            self.datatype = value
        super(EntityStateIPAddressStringType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EntityStateIPAddressStringType

class EntityStateAnySimpleType(EntityStateSimpleBaseType):
    """The EntityStateAnySimpleType type is extended by the entities of an
    individual OVAL State. This type provides uniformity to each
    state entity by including the attributes found in the
    EntityStateSimpleBaseType. This specific type describes any
    simple data."""
    subclass = None
    superclass = EntityStateSimpleBaseType
    def __init__(self, datatype='string', operation='equals', mask=False, var_ref=None, var_check=None, entity_check='all', valueOf_=None):
        super(EntityStateAnySimpleType, self).__init__(datatype, operation, mask, var_ref, var_check, entity_check, valueOf_, )
        self.datatype = _cast(None, datatype)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if EntityStateAnySimpleType.subclass:
            return EntityStateAnySimpleType.subclass(*args_, **kwargs_)
        else:
            return EntityStateAnySimpleType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_datatype(self): return self.datatype
    def set_datatype(self, datatype): self.datatype = datatype
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(EntityStateAnySimpleType, self).hasContent_()
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='oval-def:', name_='EntityStateAnySimpleType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EntityStateAnySimpleType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='oval-def:', name_='EntityStateAnySimpleType'):
        super(EntityStateAnySimpleType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='EntityStateAnySimpleType')
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            outfile.write(' datatype=%s' % (quote_attrib(self.datatype), ))
    def exportChildren(self, outfile, level, namespace_='oval-def:', name_='EntityStateAnySimpleType', fromsubclass_=False, pretty_print=True):
        super(EntityStateAnySimpleType, self).exportChildren(outfile, level, '', name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='EntityStateAnySimpleType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            showIndent(outfile, level)
            outfile.write('datatype = %s,\n' % (self.datatype,))
        super(EntityStateAnySimpleType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(EntityStateAnySimpleType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('datatype', node)
        if value is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            self.datatype = value
        super(EntityStateAnySimpleType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EntityStateAnySimpleType

class EntityStateBinaryType(EntityStateSimpleBaseType):
    """The EntityStateBinaryType type is extended by the entities of an
    individual OVAL State. This type provides uniformity to each
    state entity by including the attributes found in the
    EntityStateSimpleBaseType. This specific type describes simple
    binary data. The empty string is also allowed when using a
    variable reference with an element."""
    subclass = None
    superclass = EntityStateSimpleBaseType
    def __init__(self, datatype='string', operation='equals', mask=False, var_ref=None, var_check=None, entity_check='all', valueOf_=None):
        super(EntityStateBinaryType, self).__init__(datatype, operation, mask, var_ref, var_check, entity_check, valueOf_, )
        self.datatype = _cast(None, datatype)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if EntityStateBinaryType.subclass:
            return EntityStateBinaryType.subclass(*args_, **kwargs_)
        else:
            return EntityStateBinaryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_datatype(self): return self.datatype
    def set_datatype(self, datatype): self.datatype = datatype
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(EntityStateBinaryType, self).hasContent_()
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='oval-def:', name_='EntityStateBinaryType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EntityStateBinaryType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='oval-def:', name_='EntityStateBinaryType'):
        super(EntityStateBinaryType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='EntityStateBinaryType')
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            outfile.write(' datatype=%s' % (quote_attrib(self.datatype), ))
    def exportChildren(self, outfile, level, namespace_='oval-def:', name_='EntityStateBinaryType', fromsubclass_=False, pretty_print=True):
        super(EntityStateBinaryType, self).exportChildren(outfile, level, '', name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='EntityStateBinaryType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            showIndent(outfile, level)
            outfile.write('datatype = %s,\n' % (self.datatype,))
        super(EntityStateBinaryType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(EntityStateBinaryType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('datatype', node)
        if value is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            self.datatype = value
        super(EntityStateBinaryType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EntityStateBinaryType

class EntityStateBoolType(EntityStateSimpleBaseType):
    """The EntityStateBoolType type is extended by the entities of an
    individual OVAL State. This type provides uniformity to each
    state entity by including the attributes found in the
    EntityStateSimpleBaseType. This specific type describes simple
    boolean data. The empty string is also allowed when using a
    variable reference with an element."""
    subclass = None
    superclass = EntityStateSimpleBaseType
    def __init__(self, datatype='string', operation='equals', mask=False, var_ref=None, var_check=None, entity_check='all', valueOf_=None):
        super(EntityStateBoolType, self).__init__(datatype, operation, mask, var_ref, var_check, entity_check, valueOf_, )
        self.datatype = _cast(None, datatype)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if EntityStateBoolType.subclass:
            return EntityStateBoolType.subclass(*args_, **kwargs_)
        else:
            return EntityStateBoolType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_datatype(self): return self.datatype
    def set_datatype(self, datatype): self.datatype = datatype
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(EntityStateBoolType, self).hasContent_()
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='oval-def:', name_='EntityStateBoolType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EntityStateBoolType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='oval-def:', name_='EntityStateBoolType'):
        super(EntityStateBoolType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='EntityStateBoolType')
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            outfile.write(' datatype=%s' % (quote_attrib(self.datatype), ))
    def exportChildren(self, outfile, level, namespace_='oval-def:', name_='EntityStateBoolType', fromsubclass_=False, pretty_print=True):
        super(EntityStateBoolType, self).exportChildren(outfile, level, '', name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='EntityStateBoolType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            showIndent(outfile, level)
            outfile.write('datatype = %s,\n' % (self.datatype,))
        super(EntityStateBoolType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(EntityStateBoolType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('datatype', node)
        if value is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            self.datatype = value
        super(EntityStateBoolType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EntityStateBoolType

class EntityStateFloatType(EntityStateSimpleBaseType):
    """The EntityStateFloatType type is extended by the entities of an
    individual OVAL State. This type provides uniformity to each
    state entity by including the attributes found in the
    EntityStateSimpleBaseType. This specific type describes simple
    float data. The empty string is also allowed when using a
    variable reference with an element."""
    subclass = None
    superclass = EntityStateSimpleBaseType
    def __init__(self, datatype='string', operation='equals', mask=False, var_ref=None, var_check=None, entity_check='all', valueOf_=None):
        super(EntityStateFloatType, self).__init__(datatype, operation, mask, var_ref, var_check, entity_check, valueOf_, )
        self.datatype = _cast(None, datatype)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if EntityStateFloatType.subclass:
            return EntityStateFloatType.subclass(*args_, **kwargs_)
        else:
            return EntityStateFloatType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_datatype(self): return self.datatype
    def set_datatype(self, datatype): self.datatype = datatype
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(EntityStateFloatType, self).hasContent_()
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='oval-def:', name_='EntityStateFloatType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EntityStateFloatType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='oval-def:', name_='EntityStateFloatType'):
        super(EntityStateFloatType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='EntityStateFloatType')
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            outfile.write(' datatype=%s' % (quote_attrib(self.datatype), ))
    def exportChildren(self, outfile, level, namespace_='oval-def:', name_='EntityStateFloatType', fromsubclass_=False, pretty_print=True):
        super(EntityStateFloatType, self).exportChildren(outfile, level, '', name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='EntityStateFloatType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            showIndent(outfile, level)
            outfile.write('datatype = %s,\n' % (self.datatype,))
        super(EntityStateFloatType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(EntityStateFloatType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('datatype', node)
        if value is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            self.datatype = value
        super(EntityStateFloatType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EntityStateFloatType

class EntityStateIntType(EntityStateSimpleBaseType):
    """The EntityStateIntType type is extended by the entities of an
    individual OVAL State. This type provides uniformity to each
    state entity by including the attributes found in the
    EntityStateSimpleBaseType. This specific type describes simple
    integer data. The empty string is also allowed when using a
    variable reference with an element."""
    subclass = None
    superclass = EntityStateSimpleBaseType
    def __init__(self, datatype='string', operation='equals', mask=False, var_ref=None, var_check=None, entity_check='all', valueOf_=None):
        super(EntityStateIntType, self).__init__(datatype, operation, mask, var_ref, var_check, entity_check, valueOf_, )
        self.datatype = _cast(None, datatype)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if EntityStateIntType.subclass:
            return EntityStateIntType.subclass(*args_, **kwargs_)
        else:
            return EntityStateIntType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_datatype(self): return self.datatype
    def set_datatype(self, datatype): self.datatype = datatype
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(EntityStateIntType, self).hasContent_()
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='oval-def:', name_='EntityStateIntType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EntityStateIntType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='oval-def:', name_='EntityStateIntType'):
        super(EntityStateIntType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='EntityStateIntType')
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            outfile.write(' datatype=%s' % (quote_attrib(self.datatype), ))
    def exportChildren(self, outfile, level, namespace_='oval-def:', name_='EntityStateIntType', fromsubclass_=False, pretty_print=True):
        super(EntityStateIntType, self).exportChildren(outfile, level, '', name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='EntityStateIntType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            showIndent(outfile, level)
            outfile.write('datatype = %s,\n' % (self.datatype,))
        super(EntityStateIntType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(EntityStateIntType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('datatype', node)
        if value is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            self.datatype = value
        super(EntityStateIntType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EntityStateIntType

class EntityStateEVRStringType(EntityStateSimpleBaseType):
    """The EntityStateEVRStringType type is extended by the entities of an
    individual OVAL State. This type provides uniformity to each
    state entity by including the attributes found in the
    EntityStateSimpleBaseType. This type represents the epoch,
    version, and release fields as a single version string. It has
    the form "EPOCH:VERSION-RELEASE". Note that a null epoch (or
    '(none)' as returned by rpm) is equivalent to '0' and would
    hence have the form 0:VERSION-RELEASE. Comparisons involving
    this datatype should follow the algorithm of librpm's
    rpmvercmp() function."""
    subclass = None
    superclass = EntityStateSimpleBaseType
    def __init__(self, datatype='string', operation='equals', mask=False, var_ref=None, var_check=None, entity_check='all', valueOf_=None):
        super(EntityStateEVRStringType, self).__init__(datatype, operation, mask, var_ref, var_check, entity_check, valueOf_, )
        self.datatype = _cast(None, datatype)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if EntityStateEVRStringType.subclass:
            return EntityStateEVRStringType.subclass(*args_, **kwargs_)
        else:
            return EntityStateEVRStringType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_datatype(self): return self.datatype
    def set_datatype(self, datatype): self.datatype = datatype
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(EntityStateEVRStringType, self).hasContent_()
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='oval-def:', name_='EntityStateEVRStringType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EntityStateEVRStringType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='oval-def:', name_='EntityStateEVRStringType'):
        super(EntityStateEVRStringType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='EntityStateEVRStringType')
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            outfile.write(' datatype=%s' % (quote_attrib(self.datatype), ))
    def exportChildren(self, outfile, level, namespace_='oval-def:', name_='EntityStateEVRStringType', fromsubclass_=False, pretty_print=True):
        super(EntityStateEVRStringType, self).exportChildren(outfile, level, '', name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='EntityStateEVRStringType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            showIndent(outfile, level)
            outfile.write('datatype = %s,\n' % (self.datatype,))
        super(EntityStateEVRStringType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(EntityStateEVRStringType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('datatype', node)
        if value is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            self.datatype = value
        super(EntityStateEVRStringType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EntityStateEVRStringType

class EntityStateVersionType(EntityStateSimpleBaseType):
    """The EntityStateVersionType type is extended by the entities of an
    individual OVAL State. This type provides uniformity to each
    state entity by including the attributes found in the
    EntityStateSimpleBaseType. This specific type describes simple
    version data."""
    subclass = None
    superclass = EntityStateSimpleBaseType
    def __init__(self, datatype='string', operation='equals', mask=False, var_ref=None, var_check=None, entity_check='all', valueOf_=None):
        super(EntityStateVersionType, self).__init__(datatype, operation, mask, var_ref, var_check, entity_check, valueOf_, )
        self.datatype = _cast(None, datatype)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if EntityStateVersionType.subclass:
            return EntityStateVersionType.subclass(*args_, **kwargs_)
        else:
            return EntityStateVersionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_datatype(self): return self.datatype
    def set_datatype(self, datatype): self.datatype = datatype
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(EntityStateVersionType, self).hasContent_()
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='oval-def:', name_='EntityStateVersionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EntityStateVersionType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='oval-def:', name_='EntityStateVersionType'):
        super(EntityStateVersionType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='EntityStateVersionType')
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            outfile.write(' datatype=%s' % (quote_attrib(self.datatype), ))
    def exportChildren(self, outfile, level, namespace_='oval-def:', name_='EntityStateVersionType', fromsubclass_=False, pretty_print=True):
        super(EntityStateVersionType, self).exportChildren(outfile, level, '', name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='EntityStateVersionType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            showIndent(outfile, level)
            outfile.write('datatype = %s,\n' % (self.datatype,))
        super(EntityStateVersionType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(EntityStateVersionType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('datatype', node)
        if value is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            self.datatype = value
        super(EntityStateVersionType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EntityStateVersionType

class EntityStateFileSetRevisionType(EntityStateSimpleBaseType):
    """The EntityStateFileSetRevisionType type is extended by the entities
    of an individual OVAL State. This type provides uniformity to
    each state entity by including the attributes found in the
    EntityStateSimpleBaseType. This specific type represents the
    version string related to filesets in HP-UX."""
    subclass = None
    superclass = EntityStateSimpleBaseType
    def __init__(self, datatype='string', operation='equals', mask=False, var_ref=None, var_check=None, entity_check='all', valueOf_=None):
        super(EntityStateFileSetRevisionType, self).__init__(datatype, operation, mask, var_ref, var_check, entity_check, valueOf_, )
        self.datatype = _cast(None, datatype)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if EntityStateFileSetRevisionType.subclass:
            return EntityStateFileSetRevisionType.subclass(*args_, **kwargs_)
        else:
            return EntityStateFileSetRevisionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_datatype(self): return self.datatype
    def set_datatype(self, datatype): self.datatype = datatype
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(EntityStateFileSetRevisionType, self).hasContent_()
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='oval-def:', name_='EntityStateFileSetRevisionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EntityStateFileSetRevisionType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='oval-def:', name_='EntityStateFileSetRevisionType'):
        super(EntityStateFileSetRevisionType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='EntityStateFileSetRevisionType')
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            outfile.write(' datatype=%s' % (quote_attrib(self.datatype), ))
    def exportChildren(self, outfile, level, namespace_='oval-def:', name_='EntityStateFileSetRevisionType', fromsubclass_=False, pretty_print=True):
        super(EntityStateFileSetRevisionType, self).exportChildren(outfile, level, '', name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='EntityStateFileSetRevisionType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            showIndent(outfile, level)
            outfile.write('datatype = %s,\n' % (self.datatype,))
        super(EntityStateFileSetRevisionType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(EntityStateFileSetRevisionType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('datatype', node)
        if value is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            self.datatype = value
        super(EntityStateFileSetRevisionType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EntityStateFileSetRevisionType

class EntityStateIOSVersionType(EntityStateSimpleBaseType):
    """The EntityStateIOSVersionType type is extended by the entities of an
    individual OVAL State. This type provides uniformity to each
    state entity by including the attributes found in the
    EntityStateSimpleBaseType. This specific type represents the
    version string related to CISCO IOS.'string' is included to
    allow for regular expressions on IOS version strings."""
    subclass = None
    superclass = EntityStateSimpleBaseType
    def __init__(self, datatype='string', operation='equals', mask=False, var_ref=None, var_check=None, entity_check='all', valueOf_=None):
        super(EntityStateIOSVersionType, self).__init__(datatype, operation, mask, var_ref, var_check, entity_check, valueOf_, )
        self.datatype = _cast(None, datatype)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if EntityStateIOSVersionType.subclass:
            return EntityStateIOSVersionType.subclass(*args_, **kwargs_)
        else:
            return EntityStateIOSVersionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_datatype(self): return self.datatype
    def set_datatype(self, datatype): self.datatype = datatype
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(EntityStateIOSVersionType, self).hasContent_()
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='oval-def:', name_='EntityStateIOSVersionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EntityStateIOSVersionType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='oval-def:', name_='EntityStateIOSVersionType'):
        super(EntityStateIOSVersionType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='EntityStateIOSVersionType')
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            outfile.write(' datatype=%s' % (quote_attrib(self.datatype), ))
    def exportChildren(self, outfile, level, namespace_='oval-def:', name_='EntityStateIOSVersionType', fromsubclass_=False, pretty_print=True):
        super(EntityStateIOSVersionType, self).exportChildren(outfile, level, '', name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='EntityStateIOSVersionType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            showIndent(outfile, level)
            outfile.write('datatype = %s,\n' % (self.datatype,))
        super(EntityStateIOSVersionType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(EntityStateIOSVersionType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('datatype', node)
        if value is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            self.datatype = value
        super(EntityStateIOSVersionType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EntityStateIOSVersionType

class EntityStateStringType(EntityStateSimpleBaseType):
    """The EntityStateStringType type is extended by the entities of an
    individual OVAL State. This type provides uniformity to each
    state entity by including the attributes found in the
    EntityStateSimpleBaseType. This specific type describes simple
    string data."""
    subclass = None
    superclass = EntityStateSimpleBaseType
    def __init__(self, datatype='string', operation='equals', mask=False, var_ref=None, var_check=None, entity_check='all', valueOf_=None):
        super(EntityStateStringType, self).__init__(datatype, operation, mask, var_ref, var_check, entity_check, valueOf_, )
        self.datatype = _cast(None, datatype)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if EntityStateStringType.subclass:
            return EntityStateStringType.subclass(*args_, **kwargs_)
        else:
            return EntityStateStringType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_datatype(self): return self.datatype
    def set_datatype(self, datatype): self.datatype = datatype
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(EntityStateStringType, self).hasContent_()
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='oval-def:', name_='EntityStateStringType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EntityStateStringType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='oval-def:', name_='EntityStateStringType'):
        super(EntityStateStringType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='EntityStateStringType')
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            outfile.write(' datatype=%s' % (quote_attrib(self.datatype), ))
    def exportChildren(self, outfile, level, namespace_='oval-def:', name_='EntityStateStringType', fromsubclass_=False, pretty_print=True):
        super(EntityStateStringType, self).exportChildren(outfile, level, '', name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='EntityStateStringType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            showIndent(outfile, level)
            outfile.write('datatype = %s,\n' % (self.datatype,))
        super(EntityStateStringType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(EntityStateStringType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('datatype', node)
        if value is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            self.datatype = value
        super(EntityStateStringType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EntityStateStringType

class EntityStateRecordType(EntityStateComplexBaseType):
    """The EntityStateRecordType defines an entity that consists of a
    number of uniquely named fields. This structure is used for
    representing a record from a database query and other similar
    structures where multiple related fields must be collected at
    once. Note that for all entities of this type, the only allowed
    datatype is 'record' and the only allowed operation is 'equals'.
    During analysis of a system characteristics item, each field is
    analyzed and then the overall result for elements of this type
    is computed by logically anding the results for each field and
    then applying the entity_check attribute.Note the datatype
    attribute must be set to 'record'.Note the operation attribute
    must be set to 'equals'.Note the var_ref attribute is not
    permitted and the var_check attribute does not apply.Note that
    when the mask attribute is set to 'true', all child field
    elements must be masked regardless of the child field's mask
    attribute value."""
    subclass = None
    superclass = EntityStateComplexBaseType
    def __init__(self, datatype='string', operation='equals', mask=False, var_ref=None, var_check=None, entity_check='all', field=None):
        super(EntityStateRecordType, self).__init__(datatype, operation, mask, var_ref, var_check, entity_check, )
        if field is None:
            self.field = []
        else:
            self.field = field
    def factory(*args_, **kwargs_):
        if EntityStateRecordType.subclass:
            return EntityStateRecordType.subclass(*args_, **kwargs_)
        else:
            return EntityStateRecordType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_field(self): return self.field
    def set_field(self, field): self.field = field
    def add_field(self, value): self.field.append(value)
    def insert_field(self, index, value): self.field[index] = value
    def hasContent_(self):
        if (
            self.field or
            super(EntityStateRecordType, self).hasContent_()
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='oval-def:', name_='EntityStateRecordType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EntityStateRecordType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='oval-def:', name_='EntityStateRecordType'):
        super(EntityStateRecordType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='EntityStateRecordType')
    def exportChildren(self, outfile, level, namespace_='oval-def:', name_='EntityStateRecordType', fromsubclass_=False, pretty_print=True):
        super(EntityStateRecordType, self).exportChildren(outfile, level, '', name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for field_ in self.field:
            field_.export(outfile, level, '', name_='field', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='EntityStateRecordType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(EntityStateRecordType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(EntityStateRecordType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('field=[\n')
        level += 1
        for field_ in self.field:
            outfile.write('model_.EntityStateFieldType(\n')
            field_.exportLiteral(outfile, level, name_='EntityStateFieldType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(EntityStateRecordType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'field':
            obj_ = EntityObjectFieldType.factory()
            obj_.build(child_)
            self.field.append(obj_)
        super(EntityStateRecordType, self).buildChildren(child_, node, nodeName_, True)
# end class EntityStateRecordType

class EntityStateFieldType(GeneratedsSuper):
    """The EntityStateFieldType defines an element with simple content that
    represents a named field in a record that may contain any number
    of named fields. The EntityStateFieldType is much like all other
    entities with one significant difference, the
    EntityStateFieldType has a name attributeThe required name
    attribute specifies a unique name for the field. Field names are
    lowercase and must be unique within a given parent record
    element. When analyzing system characteristics an error should
    be reported for the result of a field that is present in the
    OVAL State, but not found in the system characteristics Item.The
    optional entity_check attribute specifies how to handle multiple
    record fields with the same name in the OVAL Systems
    Characteristics file. For example, while collecting group
    information where one field is the represents the users that are
    members of the group. It is very likely that there will be
    multiple fields with a name of 'user' associated with the group.
    If the OVAL State defines the value of the field with name equal
    'user' to equal 'Fred', then the entity_check attribute
    determines if all values for field entities must be equal to
    'Fred', or at least one value must be equal to 'Fred', etc.Note
    that when the mask attribute is set to 'true' on a field's
    parent element the field must be masked regardless of the
    field's mask attribute value.A string restricted to disallow
    upper case characters."""
    subclass = None
    superclass = None
    def __init__(self, name=None, var_ref=None, var_check=None, datatype='string', mask=False, entity_check='all', operation='equals', valueOf_=None):
        self.name = _cast(None, name)
        self.var_ref = _cast(None, var_ref)
        self.var_check = _cast(None, var_check)
        self.datatype = _cast(None, datatype)
        self.mask = _cast(bool, mask)
        self.entity_check = _cast(None, entity_check)
        self.operation = _cast(None, operation)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if EntityStateFieldType.subclass:
            return EntityStateFieldType.subclass(*args_, **kwargs_)
        else:
            return EntityStateFieldType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_var_ref(self): return self.var_ref
    def set_var_ref(self, var_ref): self.var_ref = var_ref
    def get_var_check(self): return self.var_check
    def set_var_check(self, var_check): self.var_check = var_check
    def get_datatype(self): return self.datatype
    def set_datatype(self, datatype): self.datatype = datatype
    def get_mask(self): return self.mask
    def set_mask(self, mask): self.mask = mask
    def get_entity_check(self): return self.entity_check
    def set_entity_check(self, entity_check): self.entity_check = entity_check
    def get_operation(self): return self.operation
    def set_operation(self, operation): self.operation = operation
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='oval-def:', name_='EntityStateFieldType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EntityStateFieldType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='oval-def:', name_='EntityStateFieldType'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.var_ref is not None and 'var_ref' not in already_processed:
            already_processed.add('var_ref')
            outfile.write(' var_ref=%s' % (quote_attrib(self.var_ref), ))
        if self.var_check is not None and 'var_check' not in already_processed:
            already_processed.add('var_check')
            outfile.write(' var_check=%s' % (quote_attrib(self.var_check), ))
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            outfile.write(' datatype=%s' % (quote_attrib(self.datatype), ))
        if self.mask is not None and 'mask' not in already_processed:
            already_processed.add('mask')
            outfile.write(' mask="%s"' % self.gds_format_boolean(self.mask, input_name='mask'))
        if self.entity_check is not None and 'entity_check' not in already_processed:
            already_processed.add('entity_check')
            outfile.write(' entity_check=%s' % (quote_attrib(self.entity_check), ))
        if self.operation is not None and 'operation' not in already_processed:
            already_processed.add('operation')
            outfile.write(' operation=%s' % (quote_attrib(self.operation), ))
    def exportChildren(self, outfile, level, namespace_='oval-def:', name_='EntityStateFieldType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='EntityStateFieldType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.var_ref is not None and 'var_ref' not in already_processed:
            already_processed.add('var_ref')
            showIndent(outfile, level)
            outfile.write('var_ref = %s,\n' % (self.var_ref,))
        if self.var_check is not None and 'var_check' not in already_processed:
            already_processed.add('var_check')
            showIndent(outfile, level)
            outfile.write('var_check = %s,\n' % (self.var_check,))
        if self.datatype is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            showIndent(outfile, level)
            outfile.write('datatype = %s,\n' % (self.datatype,))
        if self.mask is not None and 'mask' not in already_processed:
            already_processed.add('mask')
            showIndent(outfile, level)
            outfile.write('mask = %s,\n' % (self.mask,))
        if self.entity_check is not None and 'entity_check' not in already_processed:
            already_processed.add('entity_check')
            showIndent(outfile, level)
            outfile.write('entity_check = %s,\n' % (self.entity_check,))
        if self.operation is not None and 'operation' not in already_processed:
            already_processed.add('operation')
            showIndent(outfile, level)
            outfile.write('operation = %s,\n' % (self.operation,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('var_ref', node)
        if value is not None and 'var_ref' not in already_processed:
            already_processed.add('var_ref')
            self.var_ref = value
        value = find_attr_value_('var_check', node)
        if value is not None and 'var_check' not in already_processed:
            already_processed.add('var_check')
            self.var_check = value
        value = find_attr_value_('datatype', node)
        if value is not None and 'datatype' not in already_processed:
            already_processed.add('datatype')
            self.datatype = value
        value = find_attr_value_('mask', node)
        if value is not None and 'mask' not in already_processed:
            already_processed.add('mask')
            if value in ('true', '1'):
                self.mask = True
            elif value in ('false', '0'):
                self.mask = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('entity_check', node)
        if value is not None and 'entity_check' not in already_processed:
            already_processed.add('entity_check')
            self.entity_check = value
        value = find_attr_value_('operation', node)
        if value is not None and 'operation' not in already_processed:
            already_processed.add('operation')
            self.operation = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EntityStateFieldType

GDSClassesMapping = {
    'Object': xmldsig-core-schema.ObjectType,
    'reference': xmldsig-core-schema.ReferenceType,
    'X509Data': xmldsig-core-schema.X509DataType,
    'Signature': xmldsig-core-schema.SignatureType,
    'RetrievalMethod': xmldsig-core-schema.RetrievalMethodType,
    'SignatureMethod': xmldsig-core-schema.SignatureMethodType,
    'SPKIData': xmldsig-core-schema.SPKIDataType,
    'DSAKeyValue': xmldsig-core-schema.DSAKeyValueType,
    'generator': oval-common-schema.GeneratorType,
    'SignatureProperties': xmldsig-core-schema.SignaturePropertiesType,
    'DigestMethod': xmldsig-core-schema.DigestMethodType,
    'state': oval-common-schema.ElementMapItemType,
    'test': oval-common-schema.ElementMapItemType,
    'KeyValue': xmldsig-core-schema.KeyValueType,
    'PGPData': xmldsig-core-schema.PGPDataType,
    'deprecated_info': oval-common-schema.DeprecatedInfoType,
    'element_mapping': oval-common-schema.ElementMapType,
    'object': oval-common-schema.ElementMapItemType,
    'KeyInfo': xmldsig-core-schema.KeyInfoType,
    'Transform': xmldsig-core-schema.TransformType,
    'RSAKeyValue': xmldsig-core-schema.RSAKeyValueType,
    'SignatureProperty': xmldsig-core-schema.SignaturePropertyType,
    'Manifest': xmldsig-core-schema.ManifestType,
    'CanonicalizationMethod': xmldsig-core-schema.CanonicalizationMethodType,
    'Reference': xmldsig-core-schema.ReferenceType,
    'X509IssuerSerial': xmldsig-core-schema.X509IssuerSerialType,
    'item': oval-common-schema.ElementMapItemType,
    'Transforms': xmldsig-core-schema.TransformsType,
    'SignedInfo': xmldsig-core-schema.SignedInfoType,
    'SignatureValue': xmldsig-core-schema.SignatureValueType,
}

USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""

def usage():
    print USAGE_TEXT
    sys.exit(1)

def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass

def parse(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'oval_definitions'
        rootClass = oval_definitions
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('<?xml version="1.0" ?>\n')
    rootObj.export(sys.stdout, 0, name_=rootTag,
        namespacedef_='',
        pretty_print=True)
    return rootObj

def parseEtree(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'oval_definitions'
        rootClass = oval_definitions
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    rootElement = rootObj.to_etree(None, name_=rootTag)
    content = etree_.tostring(rootElement, pretty_print=True,
        xml_declaration=True, encoding="utf-8")
    sys.stdout.write(content)
    sys.stdout.write('\n')
    return rootObj, rootElement

def parseString(inString):
    from StringIO import StringIO
    doc = parsexml_(StringIO(inString))
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'oval_definitions'
        rootClass = oval_definitions
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('<?xml version="1.0" ?>\n')
    rootObj.export(sys.stdout, 0, name_="oval_definitions",
        namespacedef_='')
    return rootObj

def parseLiteral(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'oval_definitions'
        rootClass = oval_definitions
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('#from oval-definitions-schema import *\n\n')
    sys.stdout.write('from datetime import datetime as datetime_\n\n')
    sys.stdout.write('import oval-definitions-schema as model_\n\n')
    sys.stdout.write('rootObj = model_.rootTag(\n')
    rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
    sys.stdout.write(')\n')
    return rootObj

def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()

if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()

__all__ = [
    "DefinitionsType",
    "DefinitionType",
    "MetadataType",
    "AffectedType",
    "ReferenceType",
    "NotesType",
    "CriteriaType",
    "CriterionType",
    "ExtendDefinitionType",
    "TestsType",
    "TestType",
    "ObjectRefType",
    "StateRefType",
    "ObjectsType",
    "ObjectType",
    "StatesType",
    "StateType",
    "VariablesType",
    "VariableType",
    "PossibleValueType",
    "PossibleRestrictionType",
    "RestrictionType",
    "ValueType",
    "LiteralComponentType",
    "ObjectComponentType",
    "VariableComponentType",
    "ArithmeticFunctionType",
    "BeginFunctionType",
    "ConcatFunctionType",
    "EndFunctionType",
    "EscapeRegexFunctionType",
    "SplitFunctionType",
    "SubstringFunctionType",
    "TimeDifferenceFunctionType",
    "RegexCaptureFunctionType",
    "UniqueFunctionType",
    "CountFunctionType",
    "EntitySimpleBaseType",
    "EntityComplexBaseType",
    "EntityObjectIPAddressType",
    "EntityObjectIPAddressStringType",
    "EntityObjectAnySimpleType",
    "EntityObjectBinaryType",
    "EntityObjectBoolType",
    "EntityObjectFloatType",
    "EntityObjectIntType",
    "EntityObjectStringType",
    "EntityObjectVersionType",
    "EntityObjectRecordType",
    "EntityObjectFieldType",
    "EntityStateSimpleBaseType",
    "EntityStateComplexBaseType",
    "EntityStateIPAddressType",
    "EntityStateIPAddressStringType",
    "EntityStateAnySimpleType",
    "EntityStateBinaryType",
    "EntityStateBoolType",
    "EntityStateFloatType",
    "EntityStateIntType",
    "EntityStateEVRStringType",
    "EntityStateVersionType",
    "EntityStateFileSetRevisionType",
    "EntityStateIOSVersionType",
    "EntityStateStringType",
    "EntityStateRecordType",
    "EntityStateFieldType"
    ]